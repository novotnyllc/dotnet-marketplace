{
  "meta": {
    "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
    "timestamp": "2026-02-26T01:36:16.456843+00:00",
    "backend": "claude",
    "model": "haiku",
    "judge_model": "haiku",
    "seed": 42,
    "total_cost": 4.899122,
    "eval_type": "size_impact",
    "aborted": false
  },
  "summary": {
    "dotnet-windbg-debugging": {
      "size_tier": "small",
      "body_bytes": 4596,
      "full_bytes": 4650,
      "full_tokens_estimated": 1162,
      "summary_bytes": 566,
      "summary_tokens_estimated": 141,
      "mean": 0.0333,
      "stddev": 1.3468,
      "n": 9,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.75,
          "stddev": 1.0966,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 0.6833,
          "stddev": 1.3531,
          "n": 3,
          "wins_full": 2,
          "wins_summary": 1,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": -1.3333,
          "stddev": 0.1258,
          "n": 3,
          "wins_summary": 0,
          "wins_baseline": 3,
          "ties": 0
        }
      }
    },
    "dotnet-ado-patterns": {
      "size_tier": "medium",
      "body_bytes": 6112,
      "full_bytes": 6166,
      "full_tokens_estimated": 1541,
      "summary_bytes": 454,
      "summary_tokens_estimated": 113,
      "mean": 0.7083,
      "stddev": 0.8893,
      "n": 12,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 1.1333,
          "stddev": 0.6658,
          "n": 3,
          "wins_full": 3,
          "wins_baseline": 0,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": -0.4333,
          "stddev": 1.0563,
          "n": 3,
          "wins_full": 1,
          "wins_summary": 2,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": 0.8833,
          "stddev": 0.1607,
          "n": 3,
          "wins_summary": 3,
          "wins_baseline": 0,
          "ties": 0
        },
        "full_siblings_vs_full": {
          "mean": 1.25,
          "stddev": 0.2291,
          "n": 3,
          "wins_full_siblings": 3,
          "wins_full": 0,
          "ties": 0
        }
      }
    },
    "dotnet-observability": {
      "size_tier": "medium",
      "body_bytes": 7652,
      "full_bytes": 7706,
      "full_tokens_estimated": 1926,
      "summary_bytes": 290,
      "summary_tokens_estimated": 72,
      "mean": 0.2875,
      "stddev": 0.7508,
      "n": 12,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.0167,
          "stddev": 0.5299,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": -0.0167,
          "stddev": 0.6526,
          "n": 3,
          "wins_full": 2,
          "wins_summary": 1,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": 0.6833,
          "stddev": 0.3547,
          "n": 3,
          "wins_summary": 3,
          "wins_baseline": 0,
          "ties": 0
        },
        "full_siblings_vs_full": {
          "mean": 0.4667,
          "stddev": 1.3175,
          "n": 3,
          "wins_full_siblings": 2,
          "wins_full": 1,
          "ties": 0
        }
      }
    },
    "dotnet-csharp-async-patterns": {
      "size_tier": "medium",
      "body_bytes": 10227,
      "full_bytes": 10281,
      "full_tokens_estimated": 2570,
      "summary_bytes": 268,
      "summary_tokens_estimated": 67,
      "mean": 0.7667,
      "stddev": 1.1374,
      "n": 9,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.9333,
          "stddev": 1.3042,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 0.3,
          "stddev": 0.755,
          "n": 3,
          "wins_full": 2,
          "wins_summary": 1,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": 1.0667,
          "stddev": 1.5495,
          "n": 3,
          "wins_summary": 2,
          "wins_baseline": 1,
          "ties": 0
        }
      }
    },
    "dotnet-csharp-coding-standards": {
      "size_tier": "medium",
      "body_bytes": 5686,
      "full_bytes": 5740,
      "full_tokens_estimated": 1435,
      "summary_bytes": 315,
      "summary_tokens_estimated": 78,
      "mean": 0.6944,
      "stddev": 2.001,
      "n": 9,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.9833,
          "stddev": 2.5891,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 1.65,
          "stddev": 2.3114,
          "n": 3,
          "wins_full": 2,
          "wins_summary": 1,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": -0.55,
          "stddev": 0.3905,
          "n": 3,
          "wins_summary": 0,
          "wins_baseline": 3,
          "ties": 0
        }
      }
    },
    "dotnet-csharp-code-smells": {
      "size_tier": "medium",
      "body_bytes": 8152,
      "full_bytes": 8206,
      "full_tokens_estimated": 2051,
      "summary_bytes": 308,
      "summary_tokens_estimated": 77,
      "mean": 0.3917,
      "stddev": 0.6037,
      "n": 12,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.2833,
          "stddev": 0.9751,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 0.15,
          "stddev": 0.8261,
          "n": 3,
          "wins_full": 2,
          "wins_summary": 1,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": 0.4667,
          "stddev": 0.1443,
          "n": 3,
          "wins_summary": 3,
          "wins_baseline": 0,
          "ties": 0
        },
        "full_siblings_vs_full": {
          "mean": 0.6667,
          "stddev": 0.3512,
          "n": 3,
          "wins_full_siblings": 3,
          "wins_full": 0,
          "ties": 0
        }
      }
    },
    "dotnet-xunit": {
      "size_tier": "medium",
      "body_bytes": 9087,
      "full_bytes": 9141,
      "full_tokens_estimated": 2285,
      "summary_bytes": 415,
      "summary_tokens_estimated": 103,
      "mean": -0.3222,
      "stddev": 1.1573,
      "n": 9,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": -0.5333,
          "stddev": 1.279,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 0.1167,
          "stddev": 1.6825,
          "n": 3,
          "wins_full": 2,
          "wins_summary": 1,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": -0.55,
          "stddev": 0.6764,
          "n": 3,
          "wins_summary": 1,
          "wins_baseline": 2,
          "ties": 0
        }
      }
    },
    "dotnet-efcore-patterns": {
      "size_tier": "large",
      "body_bytes": 18988,
      "full_bytes": 19042,
      "full_tokens_estimated": 4760,
      "summary_bytes": 384,
      "summary_tokens_estimated": 96,
      "mean": 0.1562,
      "stddev": 1.1453,
      "n": 8,
      "errors": 1,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 1.5,
          "stddev": 0.2828,
          "n": 2,
          "wins_full": 2,
          "wins_baseline": 0,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 0.1167,
          "stddev": 0.7588,
          "n": 3,
          "wins_full": 2,
          "wins_summary": 1,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": -0.7,
          "stddev": 1.0332,
          "n": 3,
          "wins_summary": 1,
          "wins_baseline": 2,
          "ties": 0
        }
      }
    },
    "dotnet-security-owasp": {
      "size_tier": "large",
      "body_bytes": 23681,
      "full_bytes": 23735,
      "full_tokens_estimated": 5933,
      "summary_bytes": 474,
      "summary_tokens_estimated": 118,
      "mean": 0.7778,
      "stddev": 1.13,
      "n": 9,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.7333,
          "stddev": 1.7323,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 1.0167,
          "stddev": 0.0289,
          "n": 3,
          "wins_full": 3,
          "wins_summary": 0,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": 0.5833,
          "stddev": 1.4003,
          "n": 3,
          "wins_summary": 2,
          "wins_baseline": 1,
          "ties": 0
        }
      }
    },
    "dotnet-blazor-patterns": {
      "size_tier": "large",
      "body_bytes": 18225,
      "full_bytes": 18279,
      "full_tokens_estimated": 4569,
      "summary_bytes": 356,
      "summary_tokens_estimated": 89,
      "mean": 0.25,
      "stddev": 1.4487,
      "n": 9,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.1667,
          "stddev": 1.4869,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 1.1667,
          "stddev": 0.9929,
          "n": 3,
          "wins_full": 3,
          "wins_summary": 0,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": -0.5833,
          "stddev": 1.6988,
          "n": 3,
          "wins_summary": 1,
          "wins_baseline": 2,
          "ties": 0
        }
      }
    },
    "dotnet-integration-testing": {
      "size_tier": "large",
      "body_bytes": 21367,
      "full_bytes": 21421,
      "full_tokens_estimated": 5355,
      "summary_bytes": 329,
      "summary_tokens_estimated": 82,
      "mean": 0.5222,
      "stddev": 1.4573,
      "n": 9,
      "errors": 0,
      "comparisons": {
        "full_vs_baseline": {
          "mean": 0.5167,
          "stddev": 2.1796,
          "n": 3,
          "wins_full": 2,
          "wins_baseline": 1,
          "ties": 0
        },
        "full_vs_summary": {
          "mean": 0.0167,
          "stddev": 1.5011,
          "n": 3,
          "wins_full": 1,
          "wins_summary": 2,
          "ties": 0
        },
        "summary_vs_baseline": {
          "mean": 1.0333,
          "stddev": 0.8461,
          "n": 3,
          "wins_summary": 3,
          "wins_baseline": 0,
          "ties": 0
        }
      }
    }
  },
  "cases": [
    {
      "id": "dotnet-windbg-debugging/full_vs_baseline/run0",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 1835174230,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:38:54.596348+00:00",
      "cost_judge": 0.07626025,
      "cost_generation_allocated": 0.015597000000000001,
      "judge_attempts": 3,
      "scores": {
        "score_full": 4.2,
        "score_baseline": 4.25,
        "improvement": -0.05,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Both responses use correct WinDbg and SOS commands with proper syntax. Response A correctly distinguishes between .loadby sos clr and coreclr; Response B shows additional valid alternatives like explicit path loading and !sos.eeversion verification, making it slightly more thorough in demonstrating multiple correct approaches."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A covers the core requirements (SOS loading, exception analysis, thread inspection) with 6 phases plus heap analysis. Response B provides 14 comprehensive sections covering all core areas plus advanced diagnostics including AppDomains, assemblies, thread pools, handles, async state machines, IL disassembly, and exception handling info\u2014significantly more thorough coverage for production use."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A excels with practical 'Do's and Don'ts' guidance (verify stacks first, check all threads, correlate evidence) and warns against common mistakes. Response B is more procedurally organized but lacks such practical guidance, focusing instead on comprehensive command documentation rather than diagnostic strategy and pitfalls."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A maintains superior readability with clear sequential phases, excellent markdown formatting, and a practical WinDbg script for automation. Response B is more comprehensive but more complex with 14 sections; while professionally formatted with good tables, it may overwhelm users and lacks the automation script that enhances practical usability."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/full_vs_summary/run0",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 1524757807,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:39:14.075682+00:00",
      "cost_judge": 0.016654000000000002,
      "cost_generation_allocated": 0.015597000000000001,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 4.0,
        "improvement": 1.0,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A correctly lists all standard SOS commands with proper variants (.loadby sos clr vs coreclr). Response B has minor inaccuracies: `.load mscoree.dll` is unnecessary, `.load sos` alone is non-standard (should use `.loadby`), and `!PrintException` is not a standard SOS command (should be `!pe`)."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A provides 6 comprehensive phases with executive summary, symbol setup, exception analysis, thread analysis, heap inspection, and root cause investigation, plus a working WinDbg script. Response B covers 8 sections with good assembly analysis but less workflow guidance; it's structured more as a form than a complete diagnostic guide."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A explicitly addresses critical practices: symbol configuration first, checking ALL threads for hidden deadlocks, MDA diagnostics, PII/secrets removal, IL offset inclusion, and includes a 'Do's and Don'ts' section. Response B mentions key tips but lacks depth on common pitfalls and security considerations like data sanitization."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A uses clear phase-based organization with narrative guidance, practical examples, and a separate quick-reference script for automation. Response B uses a well-formatted checklist/form structure with ASCII dividers, which is clean for data collection but less useful as a practical diagnostic guide for practitioners learning the process."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/summary_vs_baseline/run0",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 628091465,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:39:40.188484+00:00",
      "cost_judge": 0.0207715,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 3.0,
        "score_baseline": 4.45,
        "improvement": -1.45,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A uses accurate SOS commands throughout with only minor issues (e.g., !sos.eeversion prefix). Response B contains some non-standard commands like !PrintException (should be !pe) and !dumpmethod (should be !dumpmd), reducing its technical reliability."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A provides 14 comprehensive sections covering setup, exceptions, threads, stacks, memory, objects, methods, advanced diagnostics, and recommendations. Response B has only 8 sections and is less thorough, plus includes a confusing opening paragraph about system routing that detracts from focus."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A structures the template around the optimal debugging workflow (setup \u2192 analysis \u2192 findings \u2192 recommendations) and covers modern scenarios like async state machines. Response B provides helpful tips (loadby vs load, check exception thread first) but the template itself lacks the structured best-practice guidance embedded in Response A."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A uses professional markdown formatting with clear hierarchy, consistent structure, and excellent visual organization making it immediately usable as a template. Response B uses less elegant ASCII boxes, has inconsistent styling, and opens with a confusing unrelated paragraph about system routing that reduces overall professionalism and clarity."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_vs_baseline/run0",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 1298017781,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:41:25.011585+00:00",
      "cost_judge": 0.0293915,
      "cost_generation_allocated": 0.034717,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.5,
        "score_baseline": 3.2,
        "improvement": 1.3,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A uses standard Azure DevOps tasks correctly but treats all microservices as a monolithic build, which doesn't align with microservices architecture. Response B properly uses YAML templating features (${{ each }}, conditionals, replace functions) and implements per-service builds with correct dependency management, though the NuGet credential setup is slightly convoluted."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A covers basic scenarios (build, test, publish) but lacks critical microservices features like per-service configuration, individual caching strategies, and service-level control. Response B comprehensively addresses all scenarios with service definitions, testable/publishable flags, schedule triggers, NuGet configuration, and detailed troubleshooting section."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A follows standard practices for single projects but doesn't demonstrate microservices best practices like true parallelization or fine-grained caching. Response B exemplifies modern .NET microservices patterns: per-service parallelization, reusable step templates, conditional execution, scalable service configuration model, and proper cross-service dependency management."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Response A is clear and readable with good structure but exhibits redundancy (build/test/publish steps repeated across templates). Response B maintains excellent organization with hierarchical templates and reusable components, though some areas (like NuGet credential setup) introduce unnecessary complexity."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_vs_summary/run0",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 838332709,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:41:57.980778+00:00",
      "cost_judge": 0.03178775,
      "cost_generation_allocated": 0.034717,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.25,
        "score_summary": 3.7,
        "improvement": 0.55,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 3,
            "reasoning": "Response A uses correct Azure DevOps YAML syntax and task references throughout with minor issues around cache variable handling. Response B has critical technical errors: undefined `PACKAGE_VERSION` environment variable will cause the pack task to fail, and test result/coverage file paths may not resolve correctly."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A delivers a fully working end-to-end pipeline with all stages functional, troubleshooting guide, customization examples, and clear workflows for all three phases (build/test/publish). Response B covers main requirements but has incomplete Kubernetes deployment (references non-existent manifests) and provides minimal customization guidance."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Both follow most best practices (parallel execution, caching strategies, --no-restore/--no-build flags, code coverage). Response B has a slight edge using `NUGET_PACKAGES` environment variable and Alpine Docker image, but Response A demonstrates broader good practices overall. Response A's plain-text PAT in nuget.config is a security anti-pattern; Response B avoids this."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A provides excellent documentation with extensive comments, directory structure explanation, troubleshooting tables, and customization examples. Response B is cleaner in places (Dockerfile example, .csproj recommendations) but hardcodes service definitions in the main pipeline reducing flexibility, and provides less comprehensive documentation overall."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/summary_vs_baseline/run0",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 148935456,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:43:38.467294+00:00",
      "cost_judge": 0.08479400000000001,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_summary": 4.7,
        "score_baseline": 3.75,
        "improvement": 0.95,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses use correct Azure DevOps YAML syntax and proper Cache@2, DotNetCoreCLI@2 tasks. Response A explicitly defines the Azure Artifacts Feed variable, while Response B references an undefined variable (AzureArtifactsFeed) in the build template. Both correctly implement cache hit conditions and NuGet restoration patterns."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A covers build, test, and publish stages with multi-stage deployment but lacks Docker integration, Kubernetes deployment, and setup instructions. Response B provides all of the above plus concrete microservice examples (UserService, OrderService, ProductService, ApiGateway, CommonLibrary), Dockerfile configuration, Kubernetes deployment manifest, .csproj optimization settings, and actionable setup instructions."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates solid best practices with cache strategy, separation of concerns, and security recommendations. Response B adds runtime optimization flags (PublishReadyToRun, TieredCompilation), Docker multi-stage builds with health checks, proper semantic versioning, parameterized conditional execution, and comprehensive microservice architecture patterns that are more aligned with production environments."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A is well-organized with clear sections and consistent formatting. Response B excels with parameterized templates featuring detailed parameter descriptions, real-world service names making examples immediately applicable, clear setup instructions, and a professional structure that demonstrates advanced template reusability patterns."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_siblings_vs_full/run0",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 0,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=B,full=A",
      "case_seed": 836307496,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:44:04.007088+00:00",
      "cost_judge": 0.032985249999999994,
      "cost_generation_allocated": 0.07606475000000001,
      "judge_attempts": 1,
      "scores": {
        "score_full_siblings": 5.0,
        "score_full": 3.55,
        "improvement": 1.45,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A has a security vulnerability by storing NuGet passwords in clear text with `StorePasswordInClearText` flag, and uses overly complex NuGetCommand syntax. Response B uses the modern, secure `NuGetAuthenticate@1` task and `Directory.Packages.props` approach, which is the current Azure DevOps recommended pattern."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A provides comprehensive templates but omits critical supporting files like `CodeCoverage.runsettings` and `Directory.Packages.props`. Response B includes all necessary supporting files, example extension patterns, and covers all aspects of a production pipeline with explicit configuration files."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A has security issues (clear text passwords), uses older tasks (`PublishBuildArtifacts@1`), and complex workarounds. Response B follows modern .NET practices with centralized package management, secure credential handling, newer task versions (`PublishPipelineArtifact@1`), pre/post step hooks for extensibility, and proper timeout/governance configurations."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A has reasonable organization but the NuGetCommand task is unnecessarily complex and the overall design lacks some extensibility patterns. Response B is cleaner with better abstractions, pre/post step parameters enabling custom logic injection, clearer parameter documentation, and simpler, more maintainable step implementations throughout."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_vs_baseline/run0",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 1790454172,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:44:48.058644+00:00",
      "cost_judge": 0.027849499999999996,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.45,
        "score_baseline": 4.0,
        "improvement": -0.55,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 2,
            "score_baseline": 4,
            "reasoning": "Response A provides correct, compilable code using IHealthCheck registration patterns appropriately. Response B has a critical bug in health check setup: ExternalServiceHealthCheck requires IHttpClientFactory and ILogger constructor parameters, but the code attempts to instantiate it with `new ExternalServiceHealthCheck()` without arguments, preventing compilation."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A covers required features (tracing, metrics, health checks, OTLP export) with good detail. Response B is more comprehensive, including complete Docker Compose with Grafana, Jaeger, Prometheus, and Dockerfile, plus environment-specific configurations and usage instructions."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Response A uses AddCheck<T>() correctly for DI-based health check registration and includes activity filtering and structured logging. Response B demonstrates modern patterns (IMeterFactory, ServiceInstanceId, enrichment callbacks, CancellationToken support, memory limiting) but these strengths are undermined by the critical health check registration bug."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_baseline": 4,
            "reasoning": "Response A is well-organized with clear sections, proper error handling, and runnable examples. Response B has excellent architecture (separate OrderMetrics class, HealthCheckResponseWriter utility) and documentation, but the compilation error significantly reduces practical code quality and trustworthiness."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_vs_summary/run0",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3043052045,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:45:51.342039+00:00",
      "cost_judge": 0.0454921,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 2.95,
        "score_summary": 3.7,
        "improvement": -0.75,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 2,
            "score_summary": 3,
            "reasoning": "Response A has a namespace typo ('Microsoft.AspNetcore' should be 'Microsoft.AspNetCore' on lines for /health/ready and /health/live endpoints) causing compile errors. Response B has a more critical issue: ExternalServiceHealthCheck has required constructor parameters (IHttpClientFactory, ILogger) but is instantiated as 'new ExternalServiceHealthCheck()' without arguments, which will fail at compile time. Response A demonstrates better understanding of DI patterns by using AddCheck<T>() for classes with dependencies."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A covers tracing, metrics, health checks, and OTLP export with good examples and configuration files. Response B provides the same core functionality plus a more complete observability infrastructure with Prometheus, Jaeger, Grafana, OpenTelemetry Collector configuration, and Dockerfile. Both adequately address the main requirements."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A follows best practices with proper generic health check registration (AddCheck<T>), ResourceBuilder customization, sampling strategies based on environment, and health check filtering from tracing. Response B includes a full stack approach but has the health check registration error, uses ActivitySource inefficiently by creating new instances per request instead of as singletons, and misses environment-based sampling strategies."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A is well-organized with clear section headers, XML documentation, and proper separation of concerns. The typo is a minor surface-level issue. Response B is also well-structured with good separation, but the health check registration bug is a more serious quality issue that indicates architectural misunderstanding. Response B also creates ActivitySource instances inefficiently inside endpoint handlers."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/summary_vs_baseline/run0",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 557022478,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:46:30.734301+00:00",
      "cost_judge": 0.023607399999999997,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.0,
        "score_baseline": 3.25,
        "improvement": 0.75,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 3,
            "score_baseline": 3,
            "reasoning": "Response A uses the superior IMeterFactory pattern for dependency injection but contains a namespace typo (`Microsoft.AspNetcore.Diagnostics.HealthChecks` should be `AspNetCore`) that causes a compilation error. Response B creates the Meter directly (less ideal) and uses a hardcoded observable gauge value of 42, which is a logic error that allows compilation but produces incorrect metric data."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides comprehensive coverage with a dedicated ApplicationMetrics class, separate health check files, custom ResourceDetector, and example endpoints with full metric recording. Response B is complete but shows more deployment scenarios (full OTEL stack with Jaeger/Prometheus) while having less modular organization with metrics defined inline in Program.cs."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A demonstrates excellent .NET patterns: IMeterFactory for DI, separate metrics class, XML documentation, environment-based sampling strategies, and proper health check filtering. Response B lacks proper observable gauge implementation (hardcoded value), doesn't follow the factory pattern for metrics, and defines metrics inline rather than injected\u2014reducing testability and maintainability."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 3,
            "score_baseline": 3,
            "reasoning": "Response A is well-structured and readable with excellent organization, but the namespace typo is a critical defect preventing compilation. Response B is similarly readable with good use of records and DTOs, but the hardcoded gauge value (42) represents poor implementation that would fail functional validation despite compiling successfully."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_siblings_vs_full/run0",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 0,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=A,full=B",
      "case_seed": 2361176802,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:47:18.680825+00:00",
      "cost_judge": 0.0286778,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full_siblings": 4.55,
        "score_full": 3.7,
        "improvement": 0.85,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A correctly implements ActivitySource as a static field (best practice) and uses proper OpenTelemetry patterns throughout. Response B creates a new ActivitySource instance in each endpoint handler, which is an anti-pattern that violates OpenTelemetry SDK conventions\u2014ActivitySource should be created once and reused, not instantiated per-request."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 4,
            "score_full": 5,
            "reasoning": "Response A covers all requested elements well with solid examples. Response B is more comprehensive, including multi-stage Dockerfile, appsettings.Production.json, Grafana for visualization, comprehensive health check implementations (DatabaseHealthCheck, ExternalServiceHealthCheck), and more detailed docker-compose orchestration."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A demonstrates modern .NET best practices including source-generated logging with [LoggerMessage], proper semantic conventions, IMeterFactory integration, and correct ActivitySource patterns. Response B lacks source-generated logging, uses direct logger calls, and the per-request ActivitySource creation violates established OpenTelemetry patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 4,
            "score_full": 4,
            "reasoning": "Both responses are well-organized with clear section headers and readable code. Response A has slightly better code organization and documentation strings. Response B includes valuable additions like Dockerfile and comprehensive docker-compose, but the ActivitySource anti-pattern reduces code quality and maintainability."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/full_vs_baseline/run0",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 2460034459,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:48:11.892691+00:00",
      "cost_judge": 0.0322152,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full": 5.0,
        "score_baseline": 3.75,
        "improvement": 1.25,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A correctly uses Channel<T>, async/await, and cancellation tokens but employs WaitToReadAsync() with TryRead() instead of the more standard ReadAllAsync() pattern. Response B demonstrates perfect API usage including linked cancellation tokens, ConfigureAwait(false), and proper async all-the-way implementation."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides a comprehensive multi-stage pipeline with validation, processing, and state monitoring. Response B covers the core pipeline requirements and additionally includes a practical testing example with detailed rules comments, making it more complete for production guidance."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A lacks ConfigureAwait(false), doesn't use ValueTask optimization, and has a design issue where Start() doesn't properly integrate producer tasks (fire-and-forget risk). Response B exemplifies modern .NET best practices: ConfigureAwait(false), ValueTask, linked tokens, sealed classes, and includes educational RULE comments explaining why patterns matter."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A is well-structured with good documentation and clear naming, but has some redundancy and manual task tracking. Response B excels with cleaner architecture, independent stage classes (LogProducer, LogTransformer, LogAggregator), sealed classes for performance, and inline educational comments that aid maintainability and learning."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/full_vs_summary/run0",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 2692203566,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:48:57.736065+00:00",
      "cost_judge": 0.030285799999999995,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.75,
        "score_summary": 4.35,
        "improvement": 0.4,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 5,
            "reasoning": "Response A uses modern ReadAllAsync() pattern consistently, while Response B uses older WaitToReadAsync() + TryRead() pattern. Both are technically correct API usage, though Response A employs more contemporary .NET conventions. Response B has a design inconsistency with SingleReader=true on a channel that exposes a public ConsumeAsync() method."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response B provides two comprehensive execution examples (normal and with cancellation) plus demonstrates statistics tracking and multi-stage transformation. Response A provides one main scenario with a simplified test example but includes detailed architectural documentation for the three-stage pipeline."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A consistently applies modern async patterns with ReadAllAsync(), proper linked token creation, sealed classes, and strategic ConfigureAwait(false). Response B uses valid but older patterns (WaitToReadAsync) and relies on lock statements for thread safety rather than more modern alternatives like Interlocked operations."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A has clean, well-organized code with no dead code and clear separation of concerns across producer/transformer/aggregator classes. Response B has unused ProcessStage1Async method marked as dead code, which reduces maintainability and suggests incomplete refactoring. Response A's architecture is more explicit about data flow."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/summary_vs_baseline/run0",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 925437655,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:49:32.053055+00:00",
      "cost_judge": 0.023704599999999996,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.25,
        "score_baseline": 4.55,
        "improvement": -0.3,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A has a minor structural issue with ProcessStage1Async being defined but never called, creating confusion about the multi-stage design. Response B's implementation is consistent and all code is actively used throughout the pipeline."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates producer/transformer/consumer with two execution scenarios. Response B provides more explicit multi-stage architecture (Input\u2192Validation\u2192Processing\u2192Output), includes channel state monitoring, and shows a more realistic practical workflow in the Main method."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A consistently uses ConfigureAwait(false) throughout, demonstrates linked cancellation tokens correctly, and shows excellent async/await patterns for library code. Response B lacks ConfigureAwait(false) entirely, which is a significant omission for code that may be called from UI contexts or high-concurrency scenarios."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses have well-organized, readable code with clear separation of concerns and good documentation. Response A uses lock for statistics (less modern), while Response B's task tracking approach is simple but could be fragile. Both are maintainable and production-ready with minor trade-offs."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/full_vs_baseline/run0",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 3708212755,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:50:06.931697+00:00",
      "cost_judge": 0.013833,
      "cost_generation_allocated": 0.016246,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_baseline": 3.05,
        "improvement": 1.95,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates correct usage of all modern C# features (file-scoped namespaces, nullable references, expression bodies, async/await, pattern matching) with compilable code. Response B is technically accurate in concepts but provides only a trivial Person class example without demonstrating more complex patterns."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 2,
            "reasoning": "Response A provides a comprehensive OrderService refactoring covering dependency injection, async operations, validation, error handling, documentation, and configuration guidance. Response B only lists what would be done and offers a minimal Person class example, missing critical patterns like async/await, CancellationToken, and real-world error handling."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A demonstrates best practices throughout: async-by-default I/O, CancellationToken support, defensive null handling, readonly fields with proper naming, IReadOnlyList returns, XML documentation, and modern pattern matching. Response B mentions many best practices (records, auto-properties, pattern matching) but fails to demonstrate how they integrate into actual code."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A presents well-organized, readable code with clear before/after comparison, proper naming conventions (_field prefix), comprehensive documentation, and meaningful method names. Response B's Person example is clean but oversimplified and doesn't illustrate real-world complexity or integration of multiple patterns."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/full_vs_summary/run0",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3672129727,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:50:25.642993+00:00",
      "cost_judge": 0.014078,
      "cost_generation_allocated": 0.016246,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 2.3,
        "improvement": 2.7,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A makes valid claims about modern .NET standards but provides no code to verify correctness. Response B demonstrates technically sound patterns throughout: correct file-scoped namespace syntax, proper async/await with CancellationToken, accurate nullable reference type usage, correct pattern matching, and proper throw expression syntax."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A requests user input but provides no concrete examples or demonstrations of the refactoring process. Response B comprehensively covers all requested standards with a detailed before/after example, includes XML documentation, .editorconfig settings, and practical patterns for dependency injection, async operations, and error handling."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A lists best practices without demonstration. Response B actively demonstrates multiple modern .NET best practices including defensive programming with throw expressions, CancellationToken support, pattern matching over traditional null checks, readonly field usage with underscore naming, IReadOnlyList for immutability, async-first approach, proper exception types (ArgumentNullException, InvalidOperationException), and idiomatic C# conventions."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A provides no actual code to assess. Response B delivers high-quality, maintainable code with proper PascalCase/camelCase naming conventions, clear variable names (orderRepository vs repo), excellent documentation via XML comments, consistent formatting, appropriate expression bodies, and clear separation of concerns with improved readability throughout."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/summary_vs_baseline/run0",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 1250321953,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:50:43.025881+00:00",
      "cost_judge": 0.013391,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 3.55,
        "score_baseline": 4.55,
        "improvement": -1.0,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Both responses correctly understand modern .NET standards. Response B is more specific and precise in listing techniques (init-only properties, method group conversions, LINQ), while Response A introduces async/await which isn't directly relevant to the refactoring request."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response B provides a more comprehensive list of modernization techniques and crucially includes a concrete before/after code example that demonstrates the transformation. Response A lacks this practical demonstration and covers fewer specific techniques."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response B demonstrates more nuanced understanding of best practices by using contextual qualifiers like 'where suitable' and 'where beneficial,' showing that practices should be applied conditionally. Response A presents recommendations more generically without this contextual awareness."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response B provides superior quality communication by including a concrete before/after code example that illustrates quality expectations. Response A uses clear formatting but remains abstract, making it harder for the user to visualize the actual refactored code."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_vs_baseline/run0",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 1222070392,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:50:57.979135+00:00",
      "cost_judge": 0.010919,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.75,
        "score_baseline": 3.5,
        "improvement": 1.25,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A accurately covers classic code smells but omits modern .NET-specific issues. Response B references actual .NET Analyzer rules (CA2213, CA1851, CA1827, CA1826, CA2200) and correctly identifies async/await pitfalls, LINQ anti-patterns, and EF Core issues that are essential to contemporary C# development."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A covers 20 traditional code smell categories but misses modern .NET concerns like async void, LINQ materializations, and IDisposable patterns. Response B comprehensively includes resource management, LINQ/collection anti-patterns, exception handling, and async/event issues alongside design smells, better addressing current C# development practices."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A follows classic design principles without referencing official Microsoft guidelines. Response B explicitly aligns with modern .NET best practices by citing Analyzer rules, emphasizing proper async patterns, recommending `.Any()` over `.Count()`, null-conditional operators, and EF Core-specific considerations."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Both responses are well-structured and professional. Response A uses clear formatting with checkmarks and sections. Response B provides superior visual organization with emoji categorization, more granular section headers, and slightly better readability while maintaining professional clarity."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_vs_summary/run0",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3786666617,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:51:30.248896+00:00",
      "cost_judge": 0.022018,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 4.3,
        "improvement": 0.7,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 5,
            "reasoning": "Both responses correctly identify legitimate .NET code smells and anti-patterns. Response B references specific Roslyn analyzer codes (CA2213, CA1827, CA2200, etc.) that are accurate, demonstrating deeper technical knowledge while maintaining correctness."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A covers 9 categories of issues including the 3 requested items (god classes, feature envy, primitive obsession). Response B covers 20+ specific anti-patterns with measurable thresholds (>500 LOC, >5 parameters) and specific analyzer codes, providing significantly more comprehensive guidance."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A mentions modern considerations appropriately. Response B demonstrates superior alignment with current .NET best practices by referencing industry-standard Roslyn analyzers, mentioning modern C# features (using declarations, null-conditional operators), and providing specific, measurable metrics aligned with FxCop guidelines."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A is well-organized with clear headers and structure. Response B exceeds this with superior visual organization using emojis, better hierarchical categorization, more detailed grouping of related issues, and enhanced readability while maintaining conciseness."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/summary_vs_baseline/run0",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 2500932131,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:52:08.543619+00:00",
      "cost_judge": 0.026955,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.55,
        "score_baseline": 4.25,
        "improvement": 0.3,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates superior .NET-specific technical knowledge, explicitly mentioning IDisposable patterns, async anti-patterns, dependency injection lifetimes, NRT violations, and LINQ N+1 queries\u2014all critical to C# development. Response B's code smells are accurate but presented generically without C#/.NET specificity."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response B provides a comprehensive list of 20+ code smells covering structural, behavioral, and organizational patterns comprehensively. Response A covers the user's requested smells (god classes, feature envy, primitive obsession) plus 6 additional .NET-specific categories, which is thorough but narrower in scope."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A showcases excellent modern .NET best practices knowledge (resource management, async/await patterns, DI, nullable reference types) that are directly applicable to contemporary C# development. Response B follows a structured analysis methodology (severity levels, root cause, impact analysis) which is sound, but lacks domain-specific best practice guidance."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses are well-organized and clearly formatted. Response A is concise and focused; Response B uses visual markers (\u2705) for enhanced readability. Both effectively communicate their intent despite neither providing actual code implementation."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_siblings_vs_full/run0",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 0,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=A,full=B",
      "case_seed": 3232348256,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:52:42.475885+00:00",
      "cost_judge": 0.021521000000000002,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full_siblings": 5.0,
        "score_full": 4.7,
        "improvement": 0.3,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Both responses accurately list code analysis rules and smells. Response A includes CA2000 (Dispose objects before losing scope) and CA1031 (Catch specific exceptions), which are critical .NET rules that Response B omits. Response B includes CA1826 (Where().First() pattern), but A's additional rules are more fundamental to proper .NET resource management and error handling."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 5,
            "reasoning": "Both responses comprehensively cover all requested code smell categories (god classes, feature envy, primitive obsession) plus additional anti-patterns. Response B adds valuable context requests (.NET version, frameworks), while Response A mentions async context exception handling. Each has different but equally complete coverage."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 5,
            "reasoning": "Both demonstrate strong understanding of modern .NET best practices. Response A explicitly addresses 'using' statements and async/await patterns. Response B shows sophistication by requesting .NET version context, recognizing that best practices vary by framework version. Both are exemplary in their approach."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 5,
            "score_full": 5,
            "reasoning": "Both responses are well-structured with clear formatting and logical organization. Response B uses emoji icons for visual enhancement and slightly better scannability. Response A uses consistent bold formatting for clarity. Both are professional, readable, and maintainable in presentation."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/full_vs_baseline/run0",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 1619751895,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:55:03.380847+00:00",
      "cost_judge": 0.034132749999999996,
      "cost_generation_allocated": 0.086666,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.0,
        "score_baseline": 5.0,
        "improvement": -2.0,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A uses deprecated System.Data.SqlClient (should be Microsoft.Data.SqlClient) and has an anti-pattern where OrderServiceFixture calls InitializeAsync on DatabaseFixture that's already injected (xUnit will initialize it automatically). Response B correctly uses Microsoft.Data.SqlClient with Dapper, proper async patterns, and CancellationToken support throughout."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A shows fixture and test patterns but omits implementations for OrderRepository and OrderService classes. Response B provides complete implementations including OrderProcessingService, SqlOrderRepository with Dapper, OrderValidator, MockPaymentService, unit tests, and integration tests covering all scenarios."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates some patterns (ValueTask, theories, custom assertions) but has fixture composition issues and lacks CancellationToken support in tests. Response B exemplifies modern .NET practices: proper IAsyncLifetime usage, comprehensive CancellationToken support with timeout testing, clean separation of unit/integration tests, proper mocking, and well-organized test regions."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A has good naming and clear test structure but is incomplete with referenced-but-missing implementations. Response B is fully functional and complete with clear organization using regions, helper methods, proper async/await patterns throughout, and all code directly usable without modifications or missing dependencies."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/full_vs_summary/run0",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 1552754252,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:55:31.004890+00:00",
      "cost_judge": 0.031174,
      "cost_generation_allocated": 0.063831,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.2,
        "score_summary": 5.0,
        "improvement": -1.8,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 2,
            "score_summary": 5,
            "reasoning": "Response A correctly implements IAsyncLifetime with Task, uses SQLite in-memory databases appropriately for unit tests, and all code patterns are correct. Response B has a critical error: it creates a .db file path and uses System.Data.SqlClient.SqlConnection with it, which is technically incorrect\u2014SQL Server doesn't work with file paths like SQLite; this code won't compile or run as written. Response B correctly uses ValueTask (better for v3) in other places, but the database setup is fundamentally broken."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 5,
            "reasoning": "Both responses comprehensively cover shared fixtures, parameterized theories, and async lifecycle management. Response A includes concurrent processing, base integration classes, and parallel configuration. Response B includes repository pattern, detailed error-case testing, .editorconfig guidance, and a helpful pattern summary table. Both are thorough; Response B adds architectural depth while Response A adds concurrency examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_summary": 5,
            "reasoning": "Response A demonstrates modern async patterns, in-memory SQLite for unit test speed/isolation, proper collection fixture usage, and custom assertions. Response B uses ValueTask (preferable for xUnit v3), includes Assert.Multiple and TheoryDataRow<T> (xUnit v3 features), and implements repository pattern; however, attempting to use SQL Server for unit tests contradicts best practices for speed and isolation."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_summary": 5,
            "reasoning": "Response A is well-organized with clear naming, logical flow, and comprehensive documentation; all code is functional. Response B has excellent structural organization and includes helpful documentation artifacts (pattern table, .editorconfig), but the non-functional database code undermines overall quality despite good architectural decisions elsewhere."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/summary_vs_baseline/run0",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 1934295035,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:55:51.208610+00:00",
      "cost_judge": 0.0334715,
      "cost_generation_allocated": 0.086715,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 3.75,
        "score_baseline": 5.0,
        "improvement": -1.25,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A correctly implements IAsyncLifetime and xUnit patterns but has minor fixture initialization order concerns with OrderServiceFixture dependencies. Response B is fully correct with comprehensive service implementation, proper mock/repository patterns, and CancellationToken handling throughout."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates fixture patterns and parameterized theories but lacks actual service implementation and real database integration tests. Response B provides complete domain models, service/repository implementations, validators, both unit tests with mocks and integration tests with real SQL Server, plus project configuration."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A follows xUnit patterns well but mixes TheoryData<T> and IEnumerable<object[]> approaches inconsistently. Response B exemplifies modern .NET practices with clear separation of unit/integration tests, proper DI patterns, base class infrastructure, Moq for mocking, and realistic service error handling with validation results."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A is well-organized with clear sections and readable tests, but shows some code duplication in test data setup. Response B demonstrates production-quality code with excellent organization using region markers, minimal duplication, comprehensive helper methods, and includes full supporting implementations (OrderProcessingService, SqlOrderRepository, validators) that are immediately usable."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/full_vs_baseline/run0",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 2093726184,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:58:42.708985+00:00",
      "cost_judge": 0.145314,
      "cost_generation_allocated": 0.057622,
      "judge_attempts": 3,
      "judge_error": "Failed to parse valid judge JSON after 3 attempts",
      "raw_judge_text": "```json\n{\n  \"criteria\": [\n    {\n      \"name\": \"technical_accuracy\",\n      \"score_a\": 4.5,\n      \"score_b\": 4,\n      \"reasoning\": \"Response A correctly implements all EF Core patterns with precise API usage (EF.CompileAsyncQuery, IsRowVersion, AsSplitQuery). Response B is also technically sound but uses [ConcurrencyCheck] attribute alongside [Timestamp] which is redundant (though not incorrect) since [Timestamp] already makes a property a concurrency token.\"\n    },\n    {\n      \"name\": \"completeness\",\n      \"score_a\": 4.5,\n      \"score_b\": 4,\n      \"reasoning\": \"Response A provides more comprehensive coverage with 6 entity types, multiple specialized repositories, extensive query examples, more service layer patterns, and detailed configuration. Response B covers all required features but with narrower scope (3 entity types, fewer repositories) and more focused implementation.\"\n    },\n    {\n      \"name\": \"best_practices\",\n      \"score_a\": 4,\n      \"score_b\": 4.5,\n      \"reasoning\": \"Response B demonstrates more modern .NET patterns: sealed classes, IDbContextFactory for service isolation, records for DTOs, ArgumentNullException.ThrowIfNull(), [EnumeratorCancellation] on async enumerables, and ExecutionStrategy for resilience. Response A uses solid traditional patterns but is less contemporary in its C# idioms.\"\n    },\n    {\n      \"name\": \"code_quality\",\n      \"score_a\": 4.5,\n      \"score_b\": 4.5,\n      \"reasoning\": \"Both responses exhibit excellent code quality with clear organization, good naming, comprehensive documentation, and maintainable structure. Response A has slightly better documentation with XML comments and a helpful summary table. Response B demonstrates more modern C# style with records and sealed classes. Overall quality is equivalent.\"\n    }\n  ],\n  \"overall_winner\": \"A\"\n}\n```"
    },
    {
      "id": "dotnet-efcore-patterns/full_vs_summary/run0",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 1725379068,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T01:59:35.894776+00:00",
      "cost_judge": 0.05037150000000001,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 2.75,
        "score_summary": 3.45,
        "improvement": -0.7,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 2,
            "score_summary": 3,
            "reasoning": "Response A demonstrates advanced EF Core patterns (streaming queries, execution strategy, compiled queries) but contains a critical compilation error: the interface declares `Task<IReadOnlyList<OrderDto>> GetCustomerOrdersAsync()` while the implementation returns `async IAsyncEnumerable<OrderDto>` - these signatures are incompatible. Response B's implementation is technically correct and compiles without errors, though it defines a compiled query in ProductRepository that is never used (design inefficiency rather than a compilation error)."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A provides exceptionally comprehensive coverage including API controller examples, seed data implementation, transaction management with ExecuteInTransactionAsync, concurrency error handling with retry logic, program.cs startup configuration, and multiple service examples. Response B covers core patterns well but lacks controller examples, seed data, transaction management details, and fewer practical usage examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 2,
            "score_summary": 4,
            "reasoning": "Response A uses excellent patterns (sealed classes, execution strategies, DbContextFactory isolation, proper null checks) but the interface/implementation mismatch is a critical best practices violation. Response B follows solid best practices throughout including clean DI extension methods, consistent interface/implementation contracts, proper async patterns, and default QueryTrackingBehavior configuration; minor issues include unnecessary Task.FromResult wrapping in some methods."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 2,
            "score_summary": 4,
            "reasoning": "Response A's code is well-organized and readable overall, but the compilation error significantly impairs code quality - code that doesn't compile cannot be considered production-ready. Response B maintains clean, professional code organization with consistent patterns throughout, proper formatting, XML documentation, and compilable working implementations without errors."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/summary_vs_baseline/run0",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 3252524408,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:00:09.513760+00:00",
      "cost_judge": 0.04168025,
      "cost_generation_allocated": 0.057622,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 3.45,
        "score_baseline": 5.0,
        "improvement": -1.55,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A correctly implements compiled queries, split queries, optimistic concurrency with proper RowVersion configuration, and transactions with explicit BeginTransactionAsync/CommitAsync/RollbackAsync. Response B has a critical flaw: its SaveChangesAsync returns bool and silently handles DbUpdateConcurrencyException by refreshing values, which masks errors and provides no clear error communication to callers\u2014violating proper exception handling patterns."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers all requested features (repository, UoW, concurrency, compiled/split queries) plus comprehensive error handling with custom exception hierarchy, transaction management, service layer examples, and complete entity models. Response B covers requested features but omits custom exceptions, explicit transaction management (BeginTransaction/CommitAsync), and has incomplete entity coverage in examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates excellent modern .NET practices: proper exception hierarchy, explicit transaction handling, async/await throughout with CancellationToken, Lazy<T> for repository initialization, clear separation of concerns, and comprehensive documentation. Response B lacks custom exception classes entirely, uses silent bool-based error handling instead of throwing exceptions, and omits explicit transaction support\u2014both anti-patterns for production data access layers."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A provides excellent code organization with detailed XML documentation, clear naming, proper namespace separation, and comprehensive comments explaining design decisions. Response B is well-structured and readable but has less documentation, less detailed comments, and the concurrency handling approach in UnitOfWork creates confusing semantics where a bool return could mean various failure types."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/full_vs_baseline/run0",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 1571838325,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:01:24.209163+00:00",
      "cost_judge": 0.0343915,
      "cost_generation_allocated": 0.044027000000000004,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.75,
        "score_baseline": 5.0,
        "improvement": -1.25,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A correctly implements JWT, rate limiting, and security headers but uses questionable patterns (AuthorizationHandler<Requirement, Document>) and anti-forgery tokens inappropriate for REST APIs. Response B uses standard patterns throughout with more sophisticated rate limiting (PartitionedRateLimiter) and properly implements BCrypt password hashing with refresh token rotation."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A covers the five requested aspects but omits critical production elements: no password hashing shown, no refresh token mechanism, incomplete code (TokenService and AppDbContext referenced but not provided), no global exception handling. Response B provides complete end-to-end implementation with password hashing, refresh tokens, comprehensive validators, exception handling, and usage examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A uses sealed classes and records appropriately but includes outdated patterns (anti-forgery on JSON APIs) and lacks refresh token rotation. Response B demonstrates modern .NET best practices: FluentValidation for comprehensive input validation, refresh token rotation, BCrypt hashing, XML documentation attributes, proper error handling, and resource ownership verification aligned with industry standards."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A is well-organized with good section headers and comments but references incomplete classes (AppDbContext, TokenService) and uses an unconventional authorization pattern. Response B excels with clear organization, API documentation attributes ([Produces], [ProduceResponseType]), comprehensive error responses, practical usage examples, and a security checklist\u2014only minor inconsistency in NuGet package references (AspNetCoreRateLimit mentioned but built-in used)."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/full_vs_summary/run0",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 1202750075,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:02:19.059182+00:00",
      "cost_judge": 0.06365399999999999,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full": 5.0,
        "score_summary": 4.0,
        "improvement": 1.0,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A correctly implements all .NET APIs and patterns without issues. Response B has technical concerns: regex-based SQL/XSS detection is unreliable for security, the PBKDF2 password hashing implementation is suboptimal (should use bcrypt/Argon2), and the CSRF token endpoint doesn't properly return the token in the response body."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A comprehensively implements SSRF prevention with a detailed URL validator, resource-based authorization handler, audit logging middleware, and covers all OWASP items thoroughly. Response B omits SSRF prevention entirely, has less detailed authorization implementation, and the CSRF token endpoint is incomplete."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A uses sealed records for immutability, extensible IAuthorizationHandler patterns, proper async/await, and avoids problematic patterns. Response B relies on regex-based input validation for security (an anti-pattern), uses suboptimal password hashing, and applies global antiforgery validation which may be overly strict."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A is excellently organized with clear section headers (=====), includes comprehensive OWASP coverage tables, security checklist summaries, and consistent documentation. Response B has readable code but less polished organization, fewer documentation aids, and no summary tables comparing implementations to OWASP requirements."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/summary_vs_baseline/run0",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 82627024,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:04:09.109637+00:00",
      "cost_judge": 0.11395649999999999,
      "cost_generation_allocated": 0.044027000000000004,
      "judge_attempts": 3,
      "scores": {
        "score_summary": 3.45,
        "score_baseline": 4.25,
        "improvement": -0.8,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates solid technical implementation with proper JWT, FluentValidation, and authorization patterns. However, it has a critical HSTS header logic error (adds HSTS when NOT https) and uses obsolete RNGCryptoServiceProvider. Response B's regex-based input validation in middleware is fundamentally flawed for security\u2014regex patterns cannot reliably detect SQL injection/XSS and create a false sense of security."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A provides a comprehensive production-ready system including service layer, validators, authorization handlers, refresh token rotation, email verification, and resource ownership checks. Response B is missing key components like refresh token implementation, proper service/repository layer, and has less complete error handling scenarios."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A uses industry-standard FluentValidation, proper layered architecture, comprehensive authorization patterns, and follows SOLID principles. Response B uses built-in PBKDF2 (better than third-party BCrypt) and sophisticated token bucket rate limiting, but the regex-based input validation in middleware violates best practices\u2014input validation belongs in model/business logic layers, not as defensive middleware patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses are well-organized with clear comments and good naming conventions. Response A has better separation of concerns with distinct validators and services. Response B has some complex middleware logic (InputValidationMiddleware) that could be fragile. Both are readable and maintainable overall."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/full_vs_baseline/run0",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 2002954552,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:04:44.620435+00:00",
      "cost_judge": 0.03801525,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.5,
        "score_baseline": 3.5,
        "improvement": 1.0,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A has a significant compilation error in the virtualized list component's RefreshAsync method: `await errorBoundary?.CurrentException?.InvokeAsync()` attempts to invoke an Exception object, which is not callable. Response B's implementation is technically sound, though its render mode detection via `OperatingSystem.IsBrowser()` is somewhat simplified for determining all render mode variants."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides all requested features with comprehensive search, caching, and customization for the virtualized list. Response B provides all features plus a complete working demo application, notification system, theme context, thread-safe notification handling, and shows real-world integration patterns in Program.cs."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A uses static helper methods and direct property access, which works but is less flexible. Response B follows modern .NET conventions better: uses interface-based DI (IRenderModeDetectionService), implements IAsyncDisposable for proper cleanup, uses sealed classes, thread-safe collections with locking, and demonstrates proper service registration patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A has excellent structure and documentation but the compilation error in error boundary recovery significantly impacts code quality. Response B demonstrates consistently clean code with well-organized service abstractions, proper separation of concerns, comprehensive styling, and a complete working demo that could be immediately tested."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/full_vs_summary/run0",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 4202689537,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:05:23.906200+00:00",
      "cost_judge": 0.040814,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.7,
        "score_summary": 3.75,
        "improvement": 0.95,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A uses correct Blazor APIs (RendererInfo, AssignedRenderMode) but the RenderModeDetectionService is defined with parameters it never receives in the shown example. Response B uses OperatingSystem.IsBrowser() for detection which works practically but is less direct than leveraging built-in Blazor runtime properties. Both have merits in different approaches."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A covers all four requirements (render mode detection, cascading parameters, error boundaries, virtualization) with solid implementations. Response B goes further by including service registration extensions, a complete demo app with integration, a bonus notification system, multiple cascading contexts, and comprehensive data models. B provides more production-ready completeness."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A uses records and async patterns well but lacks service interfaces, dependency injection registration, error logging, and accessibility features. Response B demonstrates enterprise-level practices including interface definitions, IServiceCollection extensions, IAsyncDisposable, thread-safe implementations, XML documentation throughout, accessibility attributes (role, aria-live), proper logging injection, and environment-aware configuration."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A has good organization and styling but shows an inconsistency where RenderModeDetectionService is defined but not actually used as shown in the example. Response B demonstrates higher code quality with comprehensive XML documentation, consistent patterns throughout, proper parameter validation, well-organized structure, and production-ready error handling with callbacks. No internal inconsistencies observed."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/summary_vs_baseline/run0",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 55234841,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:05:55.216199+00:00",
      "cost_judge": 0.03549525,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 5.0,
        "score_baseline": 3.7,
        "improvement": 1.3,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A contains a critical bug in RefreshAsync: `await errorBoundary?.CurrentException?.InvokeAsync()` attempts to invoke an Exception type as a callback, which will not compile. Response B uses all APIs correctly with no compilation errors."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A covers all requested features including render mode detection, error boundaries, and virtualization with a 10k item example. Response B adds more depth with theme cascading, multiple error boundary types, performance optimization notes, and a helpful feature matrix table."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A uses static utility classes and event-based error propagation. Response B demonstrates superior modern .NET practices: service-based dependency injection, records with required properties, CascadingValue with IsFixed=true for performance, switch expressions, and avoids restrictive interface constraints on generic items."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A is well-organized with good documentation but includes the aforementioned bug and some inline styling. Response B has cleaner component composition, professional CSS animations, better visual feedback patterns (shimmer loading state), and polished styling with no detectable bugs or issues."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/full_vs_baseline/run0",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 0,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 1859578600,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:06:32.473882+00:00",
      "cost_judge": 0.03177525,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 2.7,
        "score_baseline": 4.7,
        "improvement": -2.0,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 2,
            "score_baseline": 4,
            "reasoning": "Response A's CreateAuthenticatedClient extension method instantiates a TestAuthenticationHandler that is never connected to the DI-registered handler in the request pipeline, making authenticated test requests fail. Response B's JWT token generation approach correctly integrates with the actual authentication middleware and is validated properly."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers fixtures, fake services, and collection patterns but lacks practical authenticated request examples (CreateAuthenticatedClient is not used in test samples). Response B includes full Program.cs configuration, project file setup, JWT token generation with multiple claim options, and complete working test examples with both roles and custom claims."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 2,
            "score_baseline": 5,
            "reasoning": "Response A's custom authentication handler approach is not idiomatic for testing JWT-protected APIs and its extension method has architectural flaws. Response B follows Microsoft's recommended patterns by using real JWT authentication validation, standard AddJwtBearer middleware, IAsyncLifetime correctly, and proper service lifetime management in factories."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A has good structure and documentation but the authentication helper contains a design flaw that undermines its functionality. Response B demonstrates clean, professional code organization with proper XML documentation, logical separation of concerns (factory, helpers, base class), and all code patterns are working correctly with no architectural issues."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/full_vs_summary/run0",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 0,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3644074149,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:07:24.473602+00:00",
      "cost_judge": 0.03979774999999999,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.95,
        "score_summary": 4.0,
        "improvement": -0.05,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A's JWT token generation approach is straightforward and works end-to-end. Response B has several good patterns (ConfigureTestServices, RemoveAll<T>) but the TestAuthenticationHandler implementation is flawed\u2014the CreateAuthenticatedClient extension method manually instantiates a handler that isn't actually used by the client, and there's no mechanism to set different userId/roles per test, limiting functionality."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A covers WebApplicationFactory, Testcontainers, authentication helpers, and test examples well but omits transaction-based database isolation. Response B provides all of the above plus DatabaseTestBase class for test isolation, migration setup, configuration overrides, comprehensive examples (endpoint and repository tests), setup checklist, and running instructions."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A follows solid patterns (IAsyncLifetime, service overrides, collection fixtures) but has DRY violations (JWT secret hardcoded multiple times). Response B employs modern best practices (ConfigureAppConfiguration, ConfigureTestServices, RemoveAll<T>, ValueTask for efficiency, database isolation), though the authentication handler design shows a conceptual misunderstanding of ASP.NET Core authentication state management."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A is well-organized with clear separation of concerns, though JWT generation logic is duplicated between factory and helper class. Response B has excellent documentation with setup checklist and running tests section, but the TestAuthenticationHandler and its extension method contain implementation issues that would confuse users trying to adapt it."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/summary_vs_baseline/run0",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 0,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 3078176598,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:07:43.174061+00:00",
      "cost_judge": 0.02239275,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 5.0,
        "score_baseline": 3.75,
        "improvement": 1.25,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A has a design flaw where the WithServiceOverrides method doesn't cleanly integrate with the factory pattern, requiring workarounds in tests. Response B's service override pattern using Dictionary<Type, object> is technically cleaner and the fixture-based approach is more architecturally sound for PostgreSQL lifecycle management."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A covers core components but lacks proper xUnit collection fixture definitions and configuration file examples. Response B includes all requested aspects plus additional practical items: collection fixtures, appsettings.Testing.json, advanced test scenarios, expired/invalid token helpers, and test email service verification capabilities."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A has some anti-patterns: the WithServiceOverrides doesn't integrate well requiring factory recreation per test, missing proper xUnit Collection definitions, and using conditionals in Program.cs for testing environment. Response B follows best practices throughout: proper fixture separation, clean service injection pattern, appropriate test isolation with ClearDatabaseAsync, and idiomatic xUnit patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A is well-written but contains workarounds like CreateAuthenticatedClientWithFactory and awkward factory instantiation in tests. Response B presents cleaner, more maintainable code with better separation of concerns, practical real-world examples demonstrating email verification and role-based authorization tests, and consistent patterns throughout."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/full_vs_baseline/run1",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 623770604,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:08:31.204014+00:00",
      "cost_judge": 0.018166500000000002,
      "cost_generation_allocated": 0.015767,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.75,
        "score_baseline": 2.75,
        "improvement": 2.0,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 2,
            "reasoning": "Response A uses accurate SOS commands (!threads, !pe, !clrstack, !dumpheap -stat, !eeheap -gc). Response B contains multiple errors: uses non-existent commands like !sos.eestack, !sos.Thread, !sos.HeapStat (should be !dumpheap -stat), !sos.FindRoots (should be !gcroot), and !sos.dumpil; inconsistently uses !sos. prefix; references .tlist as WinDbg command when it's standalone."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Both responses comprehensively cover dump analysis, exception analysis, thread inspection, and heap analysis. Response B adds a PowerShell automation script and official documentation links. Response A includes a quick-start command sequence and key principles section. Both adequately address all requested components."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A emphasizes critical practices like symbol validation first, distinguishing managed vs. native analysis, and backing claims with evidence. Response B includes helpful automation practices and checklists but undermines best practices with command inaccuracies that would lead users astray during actual debugging."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 2,
            "reasoning": "Response A presents clean, well-structured markdown with accurate command syntax, clear examples, and consistent formatting. Response B has good organizational structure and formatting but is significantly diminished by incorrect command syntax and inconsistent naming conventions that would cause debugging failures."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/full_vs_summary/run1",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 2651001544,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:09:02.214746+00:00",
      "cost_judge": 0.025260249999999998,
      "cost_generation_allocated": 0.015767,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 3.15,
        "improvement": 1.85,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A uses accurate, well-researched SOS commands like !pe, !clrstack, !dumpheap -stat, and correctly distinguishes .NET Framework vs Core loading. Response B contains multiple non-existent or incorrectly specified commands (!printexception, !dumpallobjectsformt, !dumpstack, !heapstat, !heapsg, !threadstate, !lh) and invalid syntax (piping with grep in WinDbg, -gen2 parameters) that would fail in practice."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A provides exhaustive coverage including pre-analysis checklist, symbol status verification, exception chain analysis, thread analysis, heap inspection, synchronization analysis, root cause narratives, and supporting evidence sections. Response B covers similar ground with 10 numbered sections but lacks some depth in prerequisite checking and includes problematic commands that reduce practical utility."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A explicitly emphasizes critical best practices (symbol validation first, managed vs native distinction, evidence-backed claims, heap integrity checking) and includes a dedicated principles section. Response B has good structure but doesn't emphasize essential practices like symbol precedence or clearly separate managed/native command contexts, and includes some commands outside the SOS ecosystem without proper distinction."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A demonstrates professional formatting with clear visual hierarchy, comprehensive command reference organized by category, practical quick-start sequences, and key principles callouts. Response B is well-structured with numbered sections and includes useful aliases, but the inaccurate commands and mixed command contexts reduce overall code quality and trustworthiness for a diagnostic template."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/summary_vs_baseline/run1",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 3844918495,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:09:27.836655+00:00",
      "cost_judge": 0.022359000000000004,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 3.45,
        "score_baseline": 4.8,
        "improvement": -1.35,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A contains several non-standard or questionable commands such as `!dumpallobjectsformt`, `!printexception`, `!threadstate`, and uses grep piping which doesn't work in WinDbg. Response B uses consistent, verified SOS commands with the modern `!sos.` prefix convention and all commands are documented and accurate."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers 10 major sections comprehensively. Response B provides 13 sections plus includes a dedicated 'Common Diagnostic Scenarios' section addressing unhandled exceptions, stack overflow, memory leaks, and deadlocks, plus a PowerShell automation script and official documentation references, making it more practically complete."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A uses mixed SOS syntax (e.g., `!pe` without `!sos.` prefix) which is outdated. Response B follows modern WinDbg conventions with consistent `!sos.` prefixes, includes symbol configuration best practices, provides structured checklists, automation scripting, and references official Microsoft documentation for validation and learning."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses have excellent markdown formatting, clear section organization, and professional presentation. Response B has a slight edge with the inclusion of an executable PowerShell script, structured data collection checklist, findings summary template, and direct links to official documentation, making it more immediately actionable."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_vs_baseline/run1",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 2774496922,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:12:44.726408+00:00",
      "cost_judge": 0.103209,
      "cost_generation_allocated": 0.032702,
      "judge_attempts": 3,
      "scores": {
        "score_full": 4.15,
        "score_baseline": 3.75,
        "improvement": 0.4,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 3,
            "score_baseline": 4,
            "reasoning": "Response A uses Cache@2 which is the current standard task, while Response B uses CacheBeta@1 which is an older beta version. However, Response B's conditional dependsOn syntax with empty string fallback could cause issues in Azure DevOps YAML parsing."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A covers build, test, publish, caching, and includes environment deployments. Response B provides all of that plus variable templates, SBOM generation, approval gating, scheduled builds, variable group integration, troubleshooting guide, and migration examples for new services."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A applies optimization flags like --no-restore/--no-build correctly. Response B demonstrates superior DRY principles with centralized variable templates, modular step/job/stage templates that scale to many microservices, includes SBOM for supply chain security, and comprehensive conditional feature handling."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A is well-structured and readable with good comments. Response B excels with excellent organization, comprehensive documentation including feature tables and troubleshooting guides, minimal code duplication, reusable templates, and professional presentation making it more maintainable for teams."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_vs_summary/run1",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 1210081335,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:14:04.556843+00:00",
      "cost_judge": 0.076654,
      "cost_generation_allocated": 0.032702,
      "judge_attempts": 2,
      "scores": {
        "score_full": 4.45,
        "score_summary": 4.75,
        "improvement": -0.3,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A uses CacheBeta@1 which is deprecated in favor of Cache@2. Response B uses current APIs and includes practical configuration examples (NuGet.config, .csproj) demonstrating correct syntax, making it more technically current and immediately usable."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A provides 9 sections with advanced features like SBOM generation and security scanning. Response B provides 8 sections that are more immediately actionable, including actual configuration files (NuGet.config, .csproj examples) and step-by-step implementation guidance."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A demonstrates enterprise-grade practices including SBOM/CycloneDX for supply chain security, vulnerability scanning, ContinuousIntegrationBuild flags, and sophisticated artifact organization. Response B follows solid practices (test separation, code quality gating, dynamic discovery) but lacks advanced security practices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 5,
            "reasoning": "Both responses demonstrate excellent code quality with clear documentation and professional formatting. Response A excels with comprehensive tables and troubleshooting guides; Response B provides more practical readability with side-by-side configuration examples and performance metrics (41s \u2192 8s improvements)."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/summary_vs_baseline/run1",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 2852466681,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:14:28.558503+00:00",
      "cost_judge": 0.02563275,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.7,
        "score_baseline": 3.7,
        "improvement": 1.0,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A correctly implements Azure DevOps YAML syntax with proper artifact flows and cache configurations. Response B has a critical parameter/implementation mismatch: the `projects` parameter is defined but not used in build-job.yml, instead hardcoding '**/*.csproj', which reduces template reusability and could cause confusion."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides 8 comprehensive sections including a centralized variables-template.yml, .csproj configuration, NuGet.config, and clear implementation steps. Response B includes advanced deployment stages but provides less configuration detail and lacks a dedicated variables template, making it less complete for production adoption."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates excellent separation of concerns, explicit conditional restore optimization, proper artifact versioning, and comprehensive caching strategy with detailed benefits. Response B includes good practices like parallel execution and deployment environments, but the parameter/implementation inconsistencies and less detailed cache optimization explanation weaken adherence to maintainability best practices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A excels with clear section headers, detailed comments explaining each component (e.g., '80% faster caching'), consistent naming conventions, and explicit implementation steps. Response B has good structure but includes less detailed explanations and the advanced pipeline section lacks implementation specificity, affecting overall clarity and maintainability."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_siblings_vs_full/run1",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 1,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=A,full=B",
      "case_seed": 385705267,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:15:28.527656+00:00",
      "cost_judge": 0.07149649999999999,
      "cost_generation_allocated": 0.0777651,
      "judge_attempts": 2,
      "scores": {
        "score_full_siblings": 5.0,
        "score_full": 3.7,
        "improvement": 1.3,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A uses modern task versions (Cache@2, PublishPipelineArtifact@1) which are current standards. Response B uses CacheBeta@1 (older/beta version) and PublishBuildArtifacts@1 (legacy), plus has a questionable conditional syntax in publish-job.yml's dependsOn parameter that could break at runtime."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A provides 9 comprehensive sections including setup instructions, gotchas table, and sophisticated test filtering. Response B covers the basics well but the test reporting stage is somewhat redundant, and it lacks detailed setup guidance. Response B does add unique features (SBOM, vulnerability scanning, metadata) but misses some fundamentals."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A follows modern Azure DevOps patterns with proper caching strategies, conditional execution, and test filtering. Response B demonstrates good security practices (SBOM, scanning) and approval gating, but the choice of older task versions undermines adherence to current best practices for the Azure DevOps platform specifically."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A has superior documentation with comprehensive comments, clear parameter explanations, gotchas section with solutions, and ADO setup instructions. Response B has good structure and readability but provides less detailed guidance and explanatory context for implementation decisions and potential issues."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_vs_baseline/run1",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 2930227178,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:15:50.797386+00:00",
      "cost_judge": 0.023593999999999997,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.55,
        "score_baseline": 4.45,
        "improvement": 0.1,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A correctly uses the modern IMeterFactory DI pattern for custom metrics, which is the recommended approach in current .NET OpenTelemetry best practices. Response B creates Meter and ActivitySource directly without DI integration, using an older pattern that still works but is less aligned with modern conventions."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response B is more comprehensive, including actual Prometheus metrics endpoint mapping via MapPrometheusScrapingEndpoint(), Jaeger UI configuration, explicit prometheus.yml, and appsettings.json. Response A's /metrics endpoint is just a placeholder and lacks explicit Prometheus configuration details."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates superior architectural patterns with IMeterFactory, modular ObservabilityExtensions for DI, and proper separation of concerns across multiple files. Response B uses direct Meter creation and puts everything in Program.cs, which is less modular and doesn't fully leverage dependency injection for lifecycle management."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response B has superior readability with clear section headers, comprehensive inline comments, and an all-in-one view that's easy to follow. Response A is well-organized across multiple files with good naming, but the distributed structure requires more navigation; however, it demonstrates better production-grade modularity."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_vs_summary/run1",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 1231553961,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:16:58.944902+00:00",
      "cost_judge": 0.0690465,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full": 4.75,
        "score_summary": 4.25,
        "improvement": 0.5,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A correctly uses IMeterFactory for DI-integrated metrics (modern .NET best practice), while Response B creates Meter directly with `new()` which is less flexible and could have disposal issues. Both handle OTLP, ActivitySource, and health checks correctly, but A follows the recommended pattern."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response B is more comprehensive with explicit appsettings.json, prometheus.yaml, comprehensive usage/testing instructions, and health check response writer utility. Response A covers core requirements well but lacks some configuration details and testing guidance."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A demonstrates superior .NET practices: IMeterFactory pattern, clean extension methods for configuration, semantic conventions, and structured logging. Response B has good patterns in health checks but uses direct Meter instantiation and KeyValuePair instead of TagList (slightly outdated), and verbose Program.cs configuration."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A has excellent separation of concerns with dedicated ObservabilityExtensions class, realistic OrderProcessingService example, and modular design. Response B has inline configuration making Program.cs verbose but transparent, with good dedicated health check classes but less sophisticated service examples."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/summary_vs_baseline/run1",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 2687514423,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:17:53.989770+00:00",
      "cost_judge": 0.04631525,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 5.0,
        "score_baseline": 4.0,
        "improvement": 1.0,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Both use correct OpenTelemetry APIs, but Response A demonstrates the proper DI pattern by registering ActivitySource and custom metrics as singletons via AddSingleton(), following Microsoft best practices more closely. Response B creates ActivitySource and Meter as local variables, which works but is less conventional for dependency injection and potential reuse across services."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides 11 comprehensive sections with separate dedicated files for health checks (DatabaseHealthCheck, ExternalApiHealthCheck), custom metrics (OrderMetrics class), and response writers, plus realistic implementations with actual database/HTTP checks. Response B covers all required features but keeps implementations inline and provides only simulated checks, reducing depth and reusability."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates superior separation of concerns with modular files, comprehensive resource attributes, HTTP request enrichment, and custom exception tracking with semantic conventions. Response B includes good practices like explicit filter exclusions for health checks, development/production sampling strategies, and console exporters for debugging, but lacks the architectural separation and comprehensive error handling patterns shown in Response A."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A organizes code across 11 well-structured files with clear single responsibilities, making it highly maintainable and testable for production systems. Response B concentrates all logic in Program.cs with good readability and organization but reduced modularity; while appropriate for minimal APIs, this structure becomes harder to test and maintain as the application grows."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_siblings_vs_full/run1",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 1,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=A,full=B",
      "case_seed": 1843187731,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:18:19.388021+00:00",
      "cost_judge": 0.026785249999999997,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full_siblings": 4.0,
        "score_full": 5.0,
        "improvement": -1.0,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 4,
            "score_full": 5,
            "reasoning": "Response B uses pinned package versions (9.0.0, 1.9.0), explicitly configures OTLP timeout and protocol, and uses modern TagList struct. Response A uses wildcards (1.*) and lacks timeout configuration. Both correctly implement ActivitySource and IMeterFactory, but B is more precise."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 4,
            "score_full": 5,
            "reasoning": "Response A covers core requirements (tracing, metrics, health checks, OTLP) with testing examples. Response B provides the same plus Docker Compose setup, OpenTelemetry Collector configuration, Prometheus/Grafana integration, and complete infrastructure for local development."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 4,
            "score_full": 5,
            "reasoning": "Response A correctly implements source-generated logging and semantic conventions. Response B adds production best practices: console exporter for development, AspNetCore instrumentation filters (excluding health endpoints), explicit timeout configuration, memory limiters in collector config, and TagList struct usage (more modern than KeyValuePair arrays)."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 4,
            "score_full": 5,
            "reasoning": "Both are well-structured with clear separation of concerns and good documentation. Response B has superior code organization with explicit interfaces (IOrderProcessingService), more complete record type definitions, comprehensive XML documentation, and clearer method implementations with better error handling examples."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/full_vs_baseline/run1",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 1974974841,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:20:00.824831+00:00",
      "cost_judge": 0.0889965,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full": 4.25,
        "score_baseline": 4.75,
        "improvement": -0.5,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A uses `Parallel.ForEachAsync([item], ...)` to process single items sequentially, which defeats the purpose of parallelization and indicates a confusing design pattern. Response B uses a cleaner async/await pattern with explicit consumer tasks that aligns better with async I/O workloads and shows proper use of all APIs."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Both cover async streams, Channel<T>, and cancellation propagation. Response A demonstrates multiple pipeline stages and timeout handling, but lacks operational features. Response B includes all requested features plus metrics collection, monitoring, and retry logic with exponential backoff, making it more complete for production scenarios."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A consistently applies `ConfigureAwait(false)` throughout and uses `Task.WhenAll` for explicit exception propagation. Response B omits `ConfigureAwait(false)` in several places and creates a fire-and-forget producer task without explicit error tracking, which is less ideal than Response A's explicit task coordination."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A is well-structured but includes odd patterns like single-item Parallel.ForEachAsync that reduce clarity. Response B has better real-world patterns with explicit consumer tasks, cleaner async models, metrics class for monitoring, and a dedicated monitoring task that better reflects production code structure."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/full_vs_summary/run1",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 2960759782,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:21:18.046802+00:00",
      "cost_judge": 0.0728165,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full": 4.25,
        "score_summary": 4.75,
        "improvement": -0.5,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A uses correct APIs throughout but the validation stage exhibits a questionable pattern: wrapping a single item in an array and using Parallel.ForEachAsync with MaxDegreeOfParallelism=1 is inefficient and defeats the purpose of parallel processing. Response B's patterns are all correctly implemented without such inefficiencies."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A thoroughly covers all requested features including per-item timeout management via LinkedTokenSource, three explicit pipeline stages, and extensive configuration options. Response B covers all core requirements well but with simpler (global) timeout handling and less explicit per-stage control, though it compensates with practical metrics collection."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A demonstrates excellent async/await patterns overall but the single-item parallel processing in the validation stage is not idiomatic. Response B follows modern .NET best practices consistently throughout with clean separation of concerns, fluent API design for extensibility, and no questionable design choices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A is well-documented and structured but the monolithic DataProcessingPipeline class and the odd validation stage pattern reduce maintainability. Response B's modular architecture (DataSource, TransformationStage, DataProcessingPipeline), fluent API design, and single responsibility principle make it more readable, maintainable, and extensible."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/summary_vs_baseline/run1",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 3019163906,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:21:42.409605+00:00",
      "cost_judge": 0.025523999999999998,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.75,
        "score_baseline": 4.0,
        "improvement": 0.75,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Both use Channel<T>, async streams, and cancellation tokens correctly. Response B has a cleaner architectural flow with Parallel.ForEachAsync and consistent token propagation, while Response A's linked token setup and the relationship between StartAsync/ProduceAndProcessAsync creates unnecessary complexity and potential logic issues."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A is more feature-complete with retry logic, active monitoring tasks, detailed metrics tracking, and a comprehensive demo. Response B covers core pipeline requirements and multi-stage architecture elegantly but lacks retry mechanisms and active monitoring that Response A provides."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response B consistently uses ConfigureAwait(false) throughout, employs modern C# patterns (namespace declarations, fluent API, Parallel.ForEachAsync), and keeps library code clean. Response A is inconsistent with ConfigureAwait usage, includes Console.WriteLine in library code (poor practice), and mixes concerns in its async flow design."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response B demonstrates superior code organization with clear separation of concerns (DataSource, TransformationStage, Pipeline), elegant fluent API design, and comprehensive documentation. Response A is well-documented but more complex; the relationship between StartAsync and ProduceAndProcessAsync is confusing, and the overall architecture is harder to follow."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/full_vs_baseline/run1",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 846773346,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:22:19.655636+00:00",
      "cost_judge": 0.014001,
      "cost_generation_allocated": 0.017971,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_baseline": 2.05,
        "improvement": 2.95,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A correctly lists modern .NET features but provides no code demonstration. Response B accurately implements file-scoped namespaces, nullable reference types, expression bodies, proper async/await patterns with CancellationTokens, pattern matching, sealed classes, required properties, and appropriate use of modern APIs like DateTime.UtcNow."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 1,
            "reasoning": "Response A is incomplete\u2014it requests code from the user rather than providing a refactored example. Response B comprehensively demonstrates refactoring with before/after code, multiple files, XML documentation, EditorConfig configuration, error handling, and a detailed comparison table covering all requested standards."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 2,
            "reasoning": "Response A mentions best practices theoretically but lacks substantiation through code examples. Response B exemplifies modern .NET best practices in action: dependency injection, proper null validation, async naming conventions, IReadOnlyList return types, sealed classes, enum usage instead of magic strings, expression-bodied members, and comprehensive XML documentation."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 2,
            "reasoning": "Response A contains no code to evaluate. Response B demonstrates high code quality with clear organization across files, consistent naming conventions (PascalCase/camelCase), descriptive method names (GetByIdAsync vs GetOrderById), proper whitespace and formatting, logical member ordering, and a helpful comparison table showing improvements."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/full_vs_summary/run1",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 2790237557,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:22:50.955332+00:00",
      "cost_judge": 0.021594000000000002,
      "cost_generation_allocated": 0.017971,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 1.75,
        "improvement": 3.25,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A demonstrates technically correct implementations of file-scoped namespaces, nullable reference types, expression-bodied members, sealed classes, CancellationToken patterns, and modern null-checking patterns. Response B shows only a minimal example with `file class` syntax that, while potentially valid in C# 11, is less clear than file-scoped namespaces, and lacks demonstration of key patterns like cancellation tokens and sealed classes."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 1,
            "reasoning": "Response A provides complete before/after code for multiple related classes (OrderService, interfaces, Order model, enum), XML documentation, error handling, and EditorConfig configuration. Response B does not provide the actual refactored code; instead it asks for the legacy code as input, making it incomplete relative to the stated task of refactoring."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A exemplifies numerous modern .NET best practices including sealed classes, CancellationToken support, IReadOnlyList return types, required keyword, null-coalescing throw patterns, UTC timestamps, XML documentation, and dependency injection. Response B lists intended improvements but demonstrates only a small, incomplete example lacking cancellation tokens, sealed classes, expression bodies, XML docs, and interface patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A provides well-organized, readable code with clear naming conventions, proper access modifiers, consistent styling, and comprehensive documentation across multiple files. Response B provides minimal code for evaluation; its small example is clean but insufficient in scope to demonstrate code quality across a realistic refactoring scenario."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/summary_vs_baseline/run1",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 971170209,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:23:11.141911+00:00",
      "cost_judge": 0.014071999999999998,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 3.45,
        "score_baseline": 3.8,
        "improvement": -0.35,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A contains a technical error with 'file namespace MyNamespace;' which is invalid syntax\u2014the 'file' modifier applies to types, not namespaces. File-scoped namespaces use 'namespace MyNamespace;' (C# 10+). Response B correctly shows the proper syntax and demonstrates accurate knowledge of modern .NET conventions."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A covers the main requirements (file-scoped namespaces, nullable types, expression bodies, naming conventions). Response B is more comprehensive, including additional modern features like primary constructors (C# 12+), target-typed new expressions, async/await patterns, and pattern matching improvements."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates best practices through a concrete before/after example showing immutability, init-only properties, and the 'required' keyword. Response B lists best practices more comprehensively, including removal of obsolete patterns and improved maintainability, though without demonstrating them in an example."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A provides a clear, well-formatted before/after code example that helps users visualize the transformation, though the example doesn't fully demonstrate nullable reference types. Response B has a well-structured response with numbered deliverables but lacks a concrete code example to illustrate quality."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_vs_baseline/run1",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 2589499244,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:23:34.051499+00:00",
      "cost_judge": 0.014634,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.0,
        "score_baseline": 4.7,
        "improvement": -0.7,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Response A provides accurate .NET-specific knowledge with concrete thresholds (>500 lines for god classes, proper IDisposable patterns). Response B provides accurate general OOP anti-pattern terminology (divergent change, shotgun surgery). Both are technically sound, but A excels in .NET specifics while B covers broader design principles equally well."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers 6 categories of issues with good detail in resource management and LINQ anti-patterns. Response B explicitly lists 9 code smells and 6 anti-patterns with broader coverage, and specifically mentions priority levels (critical/important/nice-to-have) which adds practical value for analysis output."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates strong .NET best practices (using statements, async/await patterns, LINQ optimizations, proper exception handling). Response B takes a more strategic approach by covering SOLID principles, dependency management, and architectural anti-patterns that lead to long-term code maintainability, making it slightly more comprehensive for general code quality."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A is well-formatted with clear categories and emoji highlights. Response B has slightly superior organization with distinct sections for 'Code Smells', 'Anti-Patterns', and 'Deliverables', appearing more professional and easier to scan. Both use good markdown but B's structure is marginally clearer."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_vs_summary/run1",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 597055942,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:24:31.635677+00:00",
      "cost_judge": 0.036124,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.3,
        "score_summary": 3.75,
        "improvement": 0.55,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Both responses correctly identify .NET concepts and patterns, but Response B provides industry-standard thresholds (>500 lines, >30 lines, >5 params) aligned with tools like SonarQube, making it more technically precise. Response A covers concepts well but lacks specific metrics."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 3,
            "reasoning": "Response B is more comprehensive by explicitly requesting project context (type, purpose, size) and specific areas of concern upfront, enabling more thorough analysis. Response A simply asks for code, missing critical contextual information needed for proper analysis."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A covers modern patterns like DI lifetime issues and NRT (Nullable Reference Types), demonstrating knowledge of contemporary C# features. Response B provides concrete examples of anti-patterns (.Any() vs .Count(), throw ex; stack trace loss) showing practical idiom understanding. Both are strong but different in scope vs. depth."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response B has slightly better visual organization with bold category headers, checkmark formatting for deliverables, and a clearer workflow (analyze \u2192 provide \u2192 deliver). Response A is well-structured but less visually hierarchical. Both are professional and scannable, with B having a marginal organizational advantage."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/summary_vs_baseline/run1",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 1652082405,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:24:53.845247+00:00",
      "cost_judge": 0.016022,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.55,
        "score_baseline": 4.0,
        "improvement": 0.55,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates deeper C# expertise with modern .NET specifics: NRT violations, DI captive dependencies, async/await pitfalls, and LINQ N+1 issues. Response B is accurate but covers general software patterns without C#-specific technical depth."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response B provides a more comprehensive list of code smells (9 vs 3 explicitly named), explicitly promises structured deliverables (problem ID, impact, refactoring, priority levels), and requests additional context (project size/architecture). Response A covers key issues but is less thorough in promised analysis structure."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A emphasizes modern .NET best practices including Nullable Reference Types, proper async patterns, IDisposable compliance, and DI lifetime management. Response B focuses on general OOP principles without addressing contemporary C# idioms and conventions."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses are well-organized with clear formatting and logical structure. Response B is slightly more professional in tone, while Response A uses emoji formatting which adds clarity but may appear less formal in enterprise settings."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_siblings_vs_full/run1",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 1,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=B,full=A",
      "case_seed": 993733360,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:25:38.821120+00:00",
      "cost_judge": 0.030385,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full_siblings": 5.0,
        "score_full": 4.3,
        "improvement": 0.7,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 5,
            "score_full": 5,
            "reasoning": "Both responses accurately identify legitimate C# code smells with correct thresholds (god classes >500 lines, long methods >30 lines, >5 parameters). Response B is marginally more precise by explicitly distinguishing between `throw ex;` (stack trace loss) vs bare `throw`, and mentions `.Join()` for nested loop optimization."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Both cover major code smell categories comprehensively. Response B is more complete by addressing additional edge cases like static event cleanup, nested loop optimization patterns, and explicitly references CA (Roslyn) code analysis rules as a standard resource for developers."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A follows best practices but Response B more explicitly ties recommendations to industry standards by mentioning CA rules, parameter objects pattern, and guard clauses by name, demonstrating stronger alignment with modern .NET conventions and established coding standards."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Both responses are well-organized with clear sections and visual formatting. Response B has marginally superior presentation with better emphasis on key concepts, clearer numbered instructions for code submission, and more refined visual hierarchy that improves readability."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/full_vs_baseline/run1",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 2620778477,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:26:34.345299+00:00",
      "cost_judge": 0.03187275,
      "cost_generation_allocated": 0.030296,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.25,
        "score_baseline": 3.9,
        "improvement": 0.35,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A correctly implements IAsyncLifetime with ValueTask (xUnit v3 requirement), uses records for models, and demonstrates proper async patterns. Response B has a critical error: it implements IAsyncLifetime.InitializeAsync() returning Task instead of ValueTask, which is incorrect for xUnit v3 where the interface signature requires ValueTask."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers all requested features (shared fixtures, theories, async lifecycle) but with some incomplete implementations (repositories, service details). Response B provides fully functional, complete code with 40+ test cases, performance tests, EF Core integration, and covers all scenarios comprehensively with working implementations."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A demonstrates excellent xUnit v3 best practices including ValueTask in IAsyncLifetime, records for models, custom assertions via extensions, collection fixture patterns, sequential collections with DisableParallelization, and configuration examples. Response B violates the core xUnit v3 lifecycle pattern by using Task instead of ValueTask, misses custom assertions, and uses classes instead of records."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A is well-organized with clear sections, helpful tables, and clean patterns, but includes some incomplete code snippets (repository implementations). Response B is production-ready with complete, functional code, excellent organization via regions, proper null checks, clear naming, and fully implemented services and database context."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/full_vs_summary/run1",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3978204729,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:27:03.294107+00:00",
      "cost_judge": 0.032043999999999996,
      "cost_generation_allocated": 0.030296,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.75,
        "score_summary": 3.4,
        "improvement": 1.35,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A uses `Task` for `IAsyncLifetime.InitializeAsync()` and `IAsyncLifetime.DisposeAsync()`, but xUnit v3 (released May 2024) requires `ValueTask` as the return type. This is a critical API incompatibility. Response B correctly uses `ValueTask` throughout, which is the xUnit v3 specification."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A provides a comprehensive, end-to-end implementation including domain models, OrderProcessingService, OrderDbContext, EntityFramework configuration, and full repository implementation. Response B focuses on test patterns and fixtures but references OrderService and repositories without providing their implementations, making it less complete as a standalone solution."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response B demonstrates modern xUnit v3 best practices including `Assert.Multiple()` (xUnit v3 feature), custom assertion extension methods, proper `ValueTask` usage, sequential collection with `DisableParallelization`, and xUnit v3-specific patterns like `IEnumerable<TheoryDataRow<>>`. Response A uses traditional patterns but misses xUnit v3-specific improvements and has the wrong async interface signature."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Both are well-structured, but Response B has superior documentation including inline explanations of xUnit v3 features, configuration examples, CLI usage, xunit.runner.json setup, and .csproj details. Response A is verbose with good organization but lacks configuration guidance and external documentation."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/summary_vs_baseline/run1",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 456434058,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:27:37.464120+00:00",
      "cost_judge": 0.0411415,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.25,
        "score_baseline": 4.75,
        "improvement": -0.5,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A has correct xUnit v3 patterns but includes a questionable lock in SharedDatabaseFixture.InitializeAsync() which is poor practice in async code. Response B implements all patterns cleanly without threading concerns and proper in-memory database context management."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A comprehensively covers all parameterized theory patterns (InlineData, MemberData, ClassData) with advanced data generators, fully addressing the explicit request. Response B only uses InlineData parameterization and lacks MemberData/ClassData examples, though it adds performance tests and project configuration not in Response A."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response B demonstrates superior best practices with cleaner async patterns, comprehensive validation, proper exception handling, and no anti-patterns. Response A has good patterns overall but the lock usage in async initialization and some weak sequential tests (clearing and basic creation) detract from best practice adherence."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response B excels with clear section organization, excellent inline documentation, included project file and running instructions, and consistent patterns throughout. Response A has good readability but shows some redundancy in test setup and has less comprehensive documentation, missing project configuration details."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/full_vs_baseline/run1",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 804234516,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:28:03.845147+00:00",
      "cost_judge": 0.03438525,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.5,
        "score_baseline": 2.8,
        "improvement": 1.7,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A correctly implements compiled queries, optimistic concurrency with DbUpdateConcurrencyException handling, and split queries with proper caveats documented. Response B has implementation errors: ThenInclude cast logic is broken, usage example contains copy-paste errors (repeated Orders.Add), and repository interfaces are referenced but incomplete."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A provides end-to-end implementation including domain models, interceptors, repositories, unit of work, concurrency handling, DI setup, application service layer, controller examples, and startup configuration. Response B shows fragments with incomplete implementations (ProductRepository sketched but not finished, referenced repositories missing, no controller or service examples)."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A demonstrates modern EF Core patterns: interceptors for audit concerns, lazy repository loading, AsNoTracking() defaults, proper query splitting configuration, and resilience strategies. Response B over-engineers with a QueryBuilder abstraction layer and uses less elegant timestamp management in SaveChangesAsync; lacks interceptor pattern and split query configuration clarity."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 2,
            "reasoning": "Response A features clean structure, proper sealed classes, clear naming, architecture diagrams, and production-ready code. Response B includes meta-commentary about system skills ('I need to acknowledge the routing requirement'), copy-paste errors in usage examples, incomplete method implementations with TODO comments, and unnecessary complexity from over-abstraction."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/full_vs_summary/run1",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3611622338,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:28:52.201552+00:00",
      "cost_judge": 0.049059,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.25,
        "score_summary": 4.0,
        "improvement": 0.25,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A has some technical quirks (GetKeyPredicate builds expressions dynamically for 'Id' property, CategoryRepository's Take(0) pattern) and compiled query parameter handling issues. Response B has a minor inconsistency where GetOrderWithDetailsAsync doesn't use its defined compiled query despite one existing, and compiled queries lack CancellationToken support\u2014but both acknowledge and document these limitations appropriately."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 5,
            "reasoning": "Both responses comprehensively cover all requested features: repository pattern, unit of work, optimistic concurrency, compiled queries, and split queries. Response A adds custom ConcurrencyException and CommandTimeoutInterceptor; Response B adds DbContextFactory and ExecutionStrategy. Both provide service layer examples, DI setup, and controller integration."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 3,
            "reasoning": "Response A lacks modern C# features (records, sealed classes, nullable reference types) and the global UseQuerySplittingBehavior configuration affects all queries indiscriminately, which may not be optimal. Response B embraces current best practices: sealed class implementations, record DTOs, nullable reference types, DbContextFactory for background services, and ExecutionStrategy for resilience\u2014demonstrating stronger alignment with contemporary EF Core and .NET standards."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A has clear structure and comprehensive XML documentation but exhibits some verbosity and questionable patterns (empty collection projections). Response B demonstrates superior readability through modern C# idioms, cleaner domain model organization, sealed implementations, and more concise method signatures; however, Response A provides equally thorough documentation and both are well-structured and maintainable."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/summary_vs_baseline/run1",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 4227430095,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:29:23.075869+00:00",
      "cost_judge": 0.039589,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.25,
        "score_baseline": 3.8,
        "improvement": 0.45,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A has minor issues with ProductNameExistsAsync not properly handling the excludeId parameter with compiled queries, and an overly complex GetKeyPredicate helper. Response B has an incomplete QueryBuilder.ThenInclude implementation (acknowledged with 'Note: Proper implementation would track...' comment) and the cast may not work correctly with LINQ's IIncludableQueryable."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A thoroughly covers all requested features with working implementations, comprehensive examples, and detailed Program.cs setup. Response B covers most features but the QueryBuilder is incomplete, split queries aren't configured globally (defeating their purpose), and the service example contains a bug (adding order twice instead of adding the detail)."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A follows modern .NET patterns well but has inconsistent CancellationToken support across methods. Response B has more consistent CancellationToken support and better exponential backoff in retry logic, but the QueryBuilder is unnecessarily over-engineered when split queries can be handled more simply, and global split query configuration is missing."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A presents well-organized, production-ready code with excellent XML documentation and clear separation of concerns. Response B has good structural organization (entity base classes, automatic audit trail) but suffers from incomplete implementations (QueryBuilder.ThenInclude), a functional bug in the service example (duplicate order.Add), and unnecessary complexity in some areas, impacting practical usability."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/full_vs_baseline/run1",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 2394968260,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:30:08.897396+00:00",
      "cost_judge": 0.061441499999999996,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full": 4.7,
        "score_baseline": 2.75,
        "improvement": 1.95,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A has JWT configuration correct but contains a critical flaw: the `[RateLimitingPolicy]` attribute doesn't exist (should be `[RequireRateLimiting]`), and its SQL injection prevention via string pattern matching is technically naive and unreliable. Response B correctly uses `[RequireRateLimiting]`, proper EF Core parameterized queries, and integrates ASP.NET Core Identity correctly, though the bearer token setup could be clearer."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A defines InputValidationMiddleware but never registers it in the middleware pipeline, lacks real database integration (only TODOs), and has incomplete authentication (just simulates validation). Response B provides a complete end-to-end implementation with DbContext, models, controllers, middleware registration, migration instructions, and curl examples for testing all endpoints."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 2,
            "reasoning": "Response A uses anti-patterns like string-based SQL injection detection, unsafe CSP headers with 'unsafe-inline', no password hashing implementation, and incomplete authorization. Response B follows modern .NET conventions with ASP.NET Core Identity for password policy/hashing, resource-based authorization preventing IDOR, proper SSRF mitigation with IP validation, and comprehensive audit logging."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A is well-commented but has incomplete examples, undefined middleware registration, and the InputValidationMiddleware quality is poor. Response B demonstrates professional code quality with consistent patterns, comprehensive error handling via ApiResponse wrapper, proper dependency injection, logical organization, and clear OWASP mapping comments throughout."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/full_vs_summary/run1",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 484084124,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:30:35.563950+00:00",
      "cost_judge": 0.03346275,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.25,
        "score_summary": 3.2,
        "improvement": 1.05,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 3,
            "reasoning": "Response A uses correct .NET APIs (ASP.NET Identity, EF Core, proper rate limiting) with a complete, usable implementation. Response B has correct JWT and rate limiting configurations but lacks actual token generation, user storage, and authentication workflow implementation, making it incomplete from a technical standpoint."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A fully implements all 5 requested features (input validation, authentication with registration/login, CSRF, security headers, rate limiting) plus bonus IDOR prevention, SSRF mitigation, and audit logging. Response B covers the structure of each feature but omits critical implementations like actual user management, database integration, and real authentication flow."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 3,
            "reasoning": "Response A follows industry-standard practices with ASP.NET Identity, proper ownership-based authorization, security-by-default architecture, and comprehensive audit logging. Response B demonstrates good pattern knowledge (JWT, extension methods, config-driven approach) but the incomplete authentication implementation and lack of practical user storage patterns reduce adherence to real-world best practices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A provides well-organized, readable code with clear separation by feature and practical examples, though some error handling shows duplication and configuration could be more modular. Response B excels in documentation style with XML comments and cleaner separation via extension methods, but incomplete implementations (template-like controllers, missing database context) limit overall code quality assessment."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/summary_vs_baseline/run1",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 4088563306,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:31:04.643760+00:00",
      "cost_judge": 0.032278999999999995,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.0,
        "score_baseline": 3.45,
        "improvement": 0.55,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A has correct JWT configuration, authorization policies, and rate limiting implementation with proper attribute usage (`[EnableRateLimiting(...)]`). Response B contains a critical error: uses `[RateLimitingPolicy(\"strict\")]` which is not a valid .NET API; the correct attribute is `[EnableRateLimiting(...)]`. This would cause compilation/runtime failures."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses comprehensively cover authentication, authorization, rate limiting, CORS, CSRF, security headers, and input validation. Response A includes extension methods, testing commands, and a detailed OWASP mapping table. Response B includes custom validation middleware and a best practices checklist. Both adequately address the prompt requirements."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A follows modern .NET patterns with proper middleware ordering, separation of concerns across files, and comprehensive configuration. Response B has good structure but includes incomplete implementations (e.g., `ValidateUser` method marked TODO) and the critical rate limiting attribute error violates .NET conventions, reducing credibility for production use."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A provides well-organized code with clear section comments, good naming conventions, and helpful documentation including a reference table. Response B has excellent readability and structure with clean Program.cs layout and a practical checklist. Both have high-quality presentation, though Response A's completeness of implementations is slightly better."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/full_vs_baseline/run1",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 3205148007,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:31:33.749331+00:00",
      "cost_judge": 0.03351025,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.45,
        "score_baseline": 5.0,
        "improvement": -1.55,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A's custom ErrorBoundary doesn't actually catch exceptions from child components\u2014it only provides a method that can be called, missing the framework's exception-catching mechanism. Response B correctly inherits from the framework's ErrorBoundary and uses RendererInfo for render mode detection, which are the proper framework patterns."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Both responses cover all four requested features with good examples. Response B provides additional production-ready features like ItemsProvider delegate for async data loading, RefreshDataAsync, ScrollToTopAsync, and ScrollToItemAsync methods that enhance the virtualized list component."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A attempts to reimplement ErrorBoundary and uses reflection-based render mode detection (checking assembly presence), both anti-patterns. Response B follows ASP.NET Core conventions by inheriting from framework components, using RendererInfo directly, integrating ILogger for proper error logging, and leveraging ItemsProviderDelegate for scalable data loading patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A has clear naming, good organization, and comprehensive CSS styling. Response B demonstrates superior structure with better documentation, more professional error handling UI, more practical cascading parameter design (ThemeInfo), and stronger integration with Bootstrap standards and logging infrastructure."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/full_vs_summary/run1",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 2714812833,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:32:17.003104+00:00",
      "cost_judge": 0.0445165,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.7,
        "score_summary": 3.4,
        "improvement": 0.3,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 3,
            "score_summary": 2,
            "reasoning": "Response A uses a custom RenderMode enum with reflection-based detection via Type.GetType(), which is unconventional but functional. Response B correctly uses IComponentRenderMode interface (modern approach) but has a critical flaw: DetectRenderMode() is not actually implemented\u2014it just returns a field and comments indicate incomplete work ('In a real scenario, this would examine...'). Neither is ideal, but A delivers working detection while B does not."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A provides all 4 requested features fully implemented with 13 detailed sections, CSS styling, Program.cs configuration, and a working example with 10,000 items. Response B covers all features but the render mode detection service is incomplete/stubbed, and it mentions VirtualizationService without showing implementation. A is production-ready; B is partially incomplete."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A uses [DynamicallyAccessedMembers] for AOT safety and IAsyncDisposable, but creates a custom RenderMode enum (should use IComponentRenderMode) and implements a custom ErrorBoundary instead of extending the built-in component. Response B follows modern patterns better: uses IComponentRenderMode, properly extends ErrorBoundary, includes structured logging with ILogger<T>, and better inheritance hierarchy. However, Response B has minor issues like using List<T> instead of IReadOnlyList<T> in parameters."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Response A has clear XML documentation, logical organization, and readable examples. Response B demonstrates superior architecture with better folder organization (subdirectories for specific concerns), strong inheritance patterns, and excellent modularity. Both are well-written, but B's architectural design is slightly more sophisticated and maintainable, while A's is more straightforward and practical."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/summary_vs_baseline/run1",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 3022902071,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:32:56.742692+00:00",
      "cost_judge": 0.038947749999999996,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 2.7,
        "score_baseline": 3.75,
        "improvement": -1.05,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 2,
            "score_baseline": 4,
            "reasoning": "Response A correctly uses RendererInfo and the Virtualize component from the Blazor framework, all of which are valid and working APIs. Response B's RenderModeDetectionService has a critical flaw: it attempts to detect and cache the render mode in the constructor of a scoped service, but the DetectRenderMode method doesn't actually show how the mode would be determined\u2014it just returns a null-initialized field, making the service non-functional as written."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A provides fully implemented, functional versions of all requested features including RenderModeDetector, ThemeProvider, EnhancedErrorBoundary, and VirtualizedDataList with comprehensive example usage and global styles. Response B covers all features but leaves some incomplete\u2014VirtualizedGrid is mentioned in the project structure but never implemented, and several components are template-like rather than production-ready."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 3,
            "score_baseline": 3,
            "reasoning": "Response A follows solid practices with XML documentation and proper error handling but uses older pattern conventions (like RendererInfo). Response B uses modern C# patterns (records, nullable reference types) and attempts a service-based architecture with dependency injection, but the flawed RenderModeDetectionService design undermines its architectural advantage; both have merit but with different strengths."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A delivers production-ready, well-documented code with complete implementations, integrated styling, helper methods (RefreshData, ScrollToItem), and a comprehensive demo page that is immediately usable. Response B has better project structure and abstraction with base classes, but several components are incomplete stubs or templates rather than fully realized implementations."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/full_vs_baseline/run1",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 1,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 77795694,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:33:20.192975+00:00",
      "cost_judge": 0.0268815,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.8,
        "score_baseline": 3.0,
        "improvement": 1.8,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A has a significant issue: building the service provider inside ConfigureServices and performing database operations can cause disposal problems. Response B correctly uses ConfigureTestServices instead of ConfigureServices, properly handles transient DbContext, and avoids service provider creation issues. Response B's header-based authentication is also more practical for tests than JWT generation."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A covers the three main areas but lacks guidance on test parallelization, collection fixtures, and container sharing. Response B provides comprehensive coverage including xunit.runner.json configuration, collection fixture setup, multiple test scenarios (round-trip, email verification, authentication), and explicit guidance on running tests."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A uses IAsyncLifetime but misses key best practices: doesn't use transient DbContext (less test isolation), lacks collection fixture guidance, and doesn't configure parallel execution safely. Response B exemplifies best practices: transient DbContext for isolation, ConfigureTestServices, sequential collection execution configuration, service fakes instead of mocks, and proper disposal patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A provides readable code with good organization but lacks comprehensive documentation and offers fewer examples. Response B has extensive XML documentation, clear file structure with paths, fluent API design, a best practices table, and multiple rich test examples demonstrating different scenarios, making it significantly more maintainable and easier to understand."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/full_vs_summary/run1",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 1,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 712267396,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:33:44.614056+00:00",
      "cost_judge": 0.02996275,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 3.45,
        "improvement": 1.55,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A correctly implements WebApplicationFactory using ConfigureTestServices for overrides, proper IAsyncLifetime patterns, and a working authentication handler with header-based claims parsing. Response B has a critical flaw: attempting to modify IOptionsMonitor<TestAuthenticationOptions> directly won't work reliably in ASP.NET Core, and confuses ConfigureServices with ConfigureTestServices, which undermines the test isolation pattern."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A comprehensively covers all requested features with multiple test examples (CreateOrderTests, ListOrdersTests), xunit.runner.json configuration, NuGet package versions, InternalsVisibleTo guidance, service fakes with state tracking, and parallel execution configuration. Response B covers the basics but defines a DatabaseFixture that never gets used in the actual test examples, and the BaseIntegrationTest creates new factories per test class rather than leveraging shared fixtures."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A follows production-ready patterns: transient DbContext for isolation, shared fixtures via ICollectionFixture, sequential collection execution to prevent conflicts, proper service overrides, and service fakes (not mocks). Response B has good structural ideas (BaseIntegrationTest) but creates new Testcontainers per test class (inefficient), doesn't integrate the DatabaseFixture into tests, and the authentication implementation violates ASP.NET Core options patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A features comprehensive XML documentation, clear separation of concerns, logical file organization, practical examples using modern APIs (PostAsJsonAsync), and detailed explanations with summary tables. Response B has clean structure and documentation but is less detailed, test examples use manual JSON serialization instead of HttpClient extensions, and the authentication code examples contain patterns that won't execute correctly as written."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/summary_vs_baseline/run1",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 1,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 661603256,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:34:17.489803+00:00",
      "cost_judge": 0.035289,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 5.0,
        "score_baseline": 3.25,
        "improvement": 1.75,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A uses incorrect `ReadAsAsync<UserDto>()` API that doesn't exist in modern .NET, and builds a service provider in ConfigureWebHost which violates lifetime management patterns. Response B uses correct JSON deserialization and proper DI patterns throughout with no technical issues."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A covers core requirements well but lacks example Program.cs, collection fixtures, and email service verification testing. Response B includes all of these plus more comprehensive test scenarios, fake services with assertion helpers, and a complete minimal API example."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A has anti-patterns with service provider building in ConfigureWebHost and missing XUnit collection fixtures for database sharing. Response B exemplifies modern .NET best practices with proper IAsyncLifetime implementation, collection fixtures, authentication handler pattern, extension methods, and clean separation of concerns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A has sparse documentation and uses deprecated patterns. Response B features comprehensive XML documentation, proper namespace organization, idiomatic C# (nullable annotations, proper namespacing), consistent styling, and no deprecated APIs. Code is significantly more maintainable and professional."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/full_vs_baseline/run2",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 4099152568,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:35:08.716380+00:00",
      "cost_judge": 0.023714,
      "cost_generation_allocated": 0.016062,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.45,
        "score_baseline": 4.15,
        "improvement": 0.3,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A contains several non-existent or incorrectly-named SOS commands (e.g., `!sos.DumpAsync`, `!sos.HistInit`, `!sos.clrthreads`, `!sos.sostatus`), which would fail if users follow them. Response B sticks to well-proven, standard SOS commands like `!threads`, `!clrstack`, `!syncblk`, though it has minor issues with command flag syntax (`!PrintException --all` doesn't support the `--all` flag)."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A is exhaustive with 19 sections covering preflight, SOS loading, exception analysis, thread analysis, heap, domains, synchronization, async, advanced analysis, native stacks, memory corruption, stress logs, breakpoints, findings, recommendations, and appendices. Response B uses a 7-phase workflow structure that covers core scenarios effectively but omits advanced topics like domain analysis, finalization queue inspection, and some GC analysis scenarios."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A follows professional report structure but recommends less commonly-used SOS commands that may not align with typical troubleshooting workflows. Response B exemplifies best practices by organizing analysis into logical phases, including 'Check' and 'Expected output' guidance, providing an end-to-end example diagnostic session, and adding privacy/security sanitization notes\u2014demonstrating a practical, realistic methodology."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 5,
            "reasoning": "Both responses are excellently formatted with clear markdown structure, organized sections, and well-designed reference tables. Response A uses emoji headers and extensive detail; Response B uses phase numbers and includes inline explanations of expected outputs. Both are highly readable and maintainable, though Response B's phase-based structure makes the workflow flow slightly more logical."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/full_vs_summary/run2",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 1346787241,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:35:37.151978+00:00",
      "cost_judge": 0.02699525,
      "cost_generation_allocated": 0.016062,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.95,
        "score_summary": 4.75,
        "improvement": -0.8,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 3,
            "score_summary": 5,
            "reasoning": "Response A uses correct WinDbg/SOS command syntax throughout. Response B contains technical errors: `!PrintException --all` is not valid SOS syntax (no --all flag exists), and 'mcp_mcp-windbg_open_windbg_dump' appears to be a UI artifact rather than a valid WinDbg command."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A provides 10 comprehensive sections covering all diagnostic aspects including domains, assemblies, pinned handles, and code inspection. Response B covers 7 phases well but omits domain/assembly analysis, pinned handles, and code inspection sections that are valuable for crash analysis."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response B excels in practical best practices by including expected output descriptions, root cause analysis checklist, action item templates, and privacy/security considerations. Response A is methodologically sound but lacks these actionable frameworks for practitioners."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A has superior organization with clear visual hierarchy, professional formatting, comprehensive reference card, and detailed command explanations. Response B has clean structure and good markdown but is slightly less polished overall and contains some organizational artifacts in the command sections."
          }
        ]
      }
    },
    {
      "id": "dotnet-windbg-debugging/summary_vs_baseline/run2",
      "entity_id": "dotnet-windbg-debugging",
      "skill_name": "dotnet-windbg-debugging",
      "prompt": "Write a diagnostic report template for analyzing a .NET crash dump using WinDbg. Include commands for loading SOS, analyzing the exception, and inspecting managed threads.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 1206093991,
      "size_tier": "small",
      "body_bytes": 4596,
      "condition_sizes": {
        "full": {
          "bytes": 4650,
          "tokens_estimated": 1162
        },
        "summary": {
          "bytes": 620,
          "tokens_estimated": 155
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:36:01.437642+00:00",
      "cost_judge": 0.024531499999999998,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 3.8,
        "score_baseline": 5.0,
        "improvement": -1.2,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A provides accurate WinDbg/SOS commands but uses mixed notation (both `!` and `!sos.` prefixes inconsistently). Response B uses modern, consistent `!sos.` notation throughout and includes additional accurate commands like `!sos.VerifyHeap`, `!sos.FinalizeQueue`, and `!sos.DumpAsync` that are technically correct."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers core crash dump analysis (threads, heap, exceptions, locks) but omits advanced topics like async/task analysis, heap verification, finalization queues, and stress logs. Response B provides 19 comprehensive sections including async analysis, memory corruption detection, finalization queues, custom breakpoints, and process information."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates good structure and provides clear command options but lacks modern command notation and official documentation links. Response B follows current best practices with consistent modern syntax, includes official Microsoft documentation links, clearly distinguishes .NET Framework vs .NET Core approaches, and better aligns with current SOS tooling conventions."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A has good visual formatting with ASCII art but inconsistent command notation and some redundancy across sections. Response B excels with professional markdown structure, proper code block language specification (dbgcmd), clear visual hierarchy, well-formatted reference tables, and consistent notation throughout, making it more suitable as an actual professional diagnostic template."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_vs_baseline/run2",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 2206083256,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:37:39.895485+00:00",
      "cost_judge": 0.030584,
      "cost_generation_allocated": 0.030631999999999996,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.45,
        "score_baseline": 2.75,
        "improvement": 1.7,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A has correct Azure DevOps YAML syntax and task usage, but contains a syntax error in the main pipeline's dependsOn parameter (extra closing brace). Response B has correct syntax overall but uses hardcoded service paths throughout the main pipeline, limiting scalability for multi-project scenarios."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A comprehensively covers build, test, publish stages with multi-project loops, dependency caching, code quality checks (SonarQube), integration tests, NuGet publishing, scheduled builds, and configuration options. Response B lacks SonarQube integration, scheduled builds, proper secrets management, and has hardcoded service references instead of dynamic multi-project support."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 2,
            "reasoning": "Response A follows enterprise best practices with modular templates, DRY principle, parameter-driven approach, proper --no-restore/--no-build flags, incremental builds, and deterministic versioning. Response B violates DRY principle by hardcoding service names in the main pipeline; the variables.yml template exists but is never referenced, and the architecture doesn't scale for adding new microservices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A provides well-organized templates with clear naming conventions, comprehensive documentation, usage examples, and customization guidance with a helpful feature comparison table. Response B has readable code and includes helpful setup instructions and project structure, but the hardcoded service references in the main pipeline and unused variables template reduce maintainability."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_vs_summary/run2",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 2299124043,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:38:11.246033+00:00",
      "cost_judge": 0.0316515,
      "cost_generation_allocated": 0.030631999999999996,
      "judge_attempts": 1,
      "scores": {
        "score_full": 2.7,
        "score_summary": 4.25,
        "improvement": -1.55,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 2,
            "score_summary": 4,
            "reasoning": "Response A uses correct Azure Pipelines YAML syntax throughout with proper task definitions and template structure. Response B has critical structural errors: stage templates incorrectly define `stages:` at the top level when they should only contain stage content, and the condition syntax in the main pipeline (e.g., `${{ if eq(...) }}succeeded() else 'false' }}`) is malformed and would fail validation. The `cacheKey` parameter in dotnet-cache.yml is also unused."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 3,
            "score_summary": 5,
            "reasoning": "Response A covers all four requested stages (Prepare, Build, Test, Publish), includes setup instructions, directory structure, lock file configuration, variable group setup, and even a commented deployment stage. Response B omits the Prepare stage, lacks setup instructions, and the structural issues prevent full functionality. Response A provides more comprehensive coverage of edge cases like code analysis and manifest creation."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A follows DRY principles with proper template reuse, implements secure variable management, uses packages.lock.json for caching, includes versioning strategies, and demonstrates proper dependency ordering. Response B shows good intent with step-level composition and parameter-driven design, but the structural issues undermine adherence to best practices. Additionally, Response B references undefined variables (SONAR_HOST_URL, SONAR_TOKEN) for SonarQube integration."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A features excellent readability with clear visual section separators, consistent indentation, descriptive naming, and helpful comments explaining each stage's purpose. Response B presents well-organized directory structure and includes a helpful feature comparison table, but the structural YAML errors and unused parameters reduce overall code quality and practical usability."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/summary_vs_baseline/run2",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 2638627714,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:38:44.776633+00:00",
      "cost_judge": 0.02715525,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.0,
        "score_baseline": 3.3,
        "improvement": 0.7,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Both responses correctly implement Azure DevOps YAML syntax and .NET conventions. Response A's conditional restore logic is sound; Response B's --locked-mode approach is also valid. Both use Cache@2, DotNetCoreCLI@2, and artifact publishing tasks correctly, though Response A runs tests twice (inefficient redundancy)."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A covers core requirements (build, test, publish, caching) with 9 sections but lacks artifact versioning, manifest generation, and comprehensive variable groups setup. Response B provides more complete enterprise solution with manifest.json creation, service versioning, variable groups integration, optional deployment stage, and archive packaging\u2014better addressing full microservices workflow."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response B demonstrates stronger enterprise patterns: artifact versioning with build numbers, manifest generation for deployment tracking, explicit variable groups for secrets, environment variable standardization (NUGET_PACKAGES), and reportgenerator for comprehensive coverage reporting. Response A follows good practices but lacks artifact versioning, manifest tracking, and robust variable management."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response B has superior organization with clear visual separators, consistent formatting, comprehensive header documentation, and modular stage templates. Response A is well-structured but has redundancy (running tests twice for coverage), inconsistent artifact publishing tasks (PublishBuildArtifacts vs PublishPipelineArtifact), and less polished presentation. Response B's professional structure and consistent approach make it more maintainable."
          }
        ]
      }
    },
    {
      "id": "dotnet-ado-patterns/full_siblings_vs_full/run2",
      "entity_id": "dotnet-ado-patterns",
      "skill_name": "dotnet-ado-patterns",
      "prompt": "Create Azure DevOps YAML pipeline templates for a .NET microservices solution that builds, tests, and publishes multiple projects with proper dependency caching.\n",
      "run_index": 2,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=A,full=B",
      "case_seed": 1959225122,
      "size_tier": "medium",
      "body_bytes": 6112,
      "condition_sizes": {
        "full": {
          "bytes": 6166,
          "tokens_estimated": 1541
        },
        "summary": {
          "bytes": 508,
          "tokens_estimated": 127
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 21104,
          "tokens_estimated": 5276
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:39:13.141491+00:00",
      "cost_judge": 0.030144,
      "cost_generation_allocated": 0.06214009999999999,
      "judge_attempts": 1,
      "scores": {
        "score_full_siblings": 4.45,
        "score_full": 3.45,
        "improvement": 1.0,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 4,
            "score_full": 3,
            "reasoning": "Response A uses correct Azure DevOps task syntax throughout, though the cache restoration variable condition `ne(variables.CACHE_RESTORED, 'true')` may have scoping issues. Response B has a problematic condition syntax in publish-stage.yml: `${{ if eq(variables['Build.SourceBranch']...) }}succeeded() else 'false' }}` which is malformed, and overly broad patterns like `**/*.csproj` and `**/*IntegrationTests.csproj` that could fail in some solutions."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A provides 15 comprehensive template files covering variables, steps, jobs, and stages with detailed microservices configuration, conditional deployment, multiple setup examples, and nuget.config. Response B shows a simpler structure with fewer templates and less detailed multi-service configuration; it adds code quality checks (positive) but omits service dependency handling and detailed setup examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 4,
            "score_full": 4,
            "reasoning": "Response A implements fail-fast testing, version injection, proper caching strategy, and clear separation of concerns, though it has some template nesting redundancy. Response B includes valuable code quality checks and SonarQube integration, but conflates build and test operations in a single job template and uses overly generic integration test patterns that may not scale well for microservices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A is exceptionally well-organized with clear naming conventions, comprehensive comments, proper YAML formatting, and a helpful feature checklist. Response B is clean and includes a helpful features table, but has confusing parameter designs (like `restoreOnly` in dotnet-build.yml) and less thorough documentation overall."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_vs_baseline/run2",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 4024596476,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:39:43.232651+00:00",
      "cost_judge": 0.027274,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.75,
        "score_baseline": 4.25,
        "improvement": 0.5,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A correctly implements OpenTelemetry APIs but has minor issues: an observable gauge is created but never used, and health checks reference hardcoded external URLs and SQL Server that may not exist in dev. Response B implements all APIs correctly with no unused code or assumptions that won't work out-of-box."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A provides extensive coverage with Docker Compose (Jaeger, Prometheus), Prometheus config, 4 endpoint examples, and dev/prod appsettings. Response B covers core requirements with Aspire Dashboard, 2 endpoints, and focused scope; it omits Jaeger/Prometheus configurations and fewer endpoint examples, though still sufficient for the requirements."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates solid practices (liveness/readiness separation, filtering health checks from tracing, ResourceBuilder pattern) but adds Serilog dependency that increases complexity beyond Minimal API needs. Response B follows modern .NET best practices better: uses built-in logging, avoids over-engineering, includes HEALTHCHECK in Dockerfile, and aligns well with Minimal API philosophy."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A is well-organized with clear headers but includes dead code (unused observable gauge), hard-coded assumptions (SQL Server connection string, external API URL), and spans 1000+ lines making it verbose. Response B is clean, focused (~300 lines), has no dead code, all examples work out-of-box, and uses anonymous types appropriately for simplicity."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_vs_summary/run2",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3976431791,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:40:17.635650+00:00",
      "cost_judge": 0.030939,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.45,
        "score_summary": 4.25,
        "improvement": 0.2,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 4,
            "reasoning": "Both responses correctly implement OpenTelemetry APIs. Response A uses explicit `.AddOtlpExporter()` calls while Response B uses `.UseOtlpExporter()` with environment variable configuration; both are valid. Response A's demo/in-memory counters alongside real metrics could cause minor confusion about production readiness."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A provides comprehensive coverage including separate metric/health check files, full docker-compose with Jaeger/Prometheus/OTel collector, collector configuration files, prometheus.yml, and extensive examples. Response B covers core requirements (tracing, metrics, health checks, OTLP) with Aspire Dashboard but omits collector and monitoring backend configuration details."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A demonstrates excellent patterns (resource builder, activity status codes, proper scope management) but mixes demo code with production metrics. Response B better aligns with modern .NET practices by using `.UseOtlpExporter()` with OTEL_* standard environment variables, recommending Microsoft's Aspire Dashboard, and maintaining cleaner separation between development and production configurations."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A is well-documented but verbose (~400+ lines in Program.cs) with mixed concerns and could benefit from extension methods. Response B is more concise, readable, and maintainable with clear section headers, elegant use of method references, and better separation through inline handler functions. B sacrifices some modularity for clarity and developer experience."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/summary_vs_baseline/run2",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 4040161463,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:40:55.450952+00:00",
      "cost_judge": 0.03819399999999999,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.25,
        "score_baseline": 3.95,
        "improvement": 0.3,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A includes the required OpenTelemetry base package and provides technically correct implementations. Response B is missing the 'OpenTelemetry' package reference in .csproj (only has Exporter and Extensions), which would cause compilation errors. Additionally, Response B's observable gauge is created but never populated, and logging OpenTelemetry configuration lacks the exporter setup needed to actually export logs to OTLP."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 5,
            "reasoning": "Both responses provide comprehensive coverage including .csproj, Program.cs, health checks, custom metrics, OTLP export, Docker Compose, configuration files, and example endpoints. Response B adds a production Dockerfile and more endpoint implementations (batch processing), while Response A includes detailed OTLP collector configuration. Both adequately address the complete requirements."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A follows solid patterns with proper resource builders and activity management but has thread-safety concerns in BusinessMetrics (mutable state without synchronization). Response B adopts Serilog for structured logging (excellent .NET practice) and uses observable gauges appropriately, but implementations are incomplete (gauge created without tracking logic, mock endpoints). Response B's Serilog integration provides an edge, but incomplete implementations balance it."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A is well-organized with clear sections, complete working implementations, and good documentation; minor issues include code duplication and Windows-specific path in disk check. Response B has cleaner organization and better endpoint examples but includes mock/simulated implementations (GetOrder returns static data) and the observable gauge is declared but non-functional. Response A's completeness in working code provides an advantage despite some duplication."
          }
        ]
      }
    },
    {
      "id": "dotnet-observability/full_siblings_vs_full/run2",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Set up OpenTelemetry tracing and metrics for a .NET Minimal API with custom business metrics, health checks, and OTLP export to a collector.\n",
      "run_index": 2,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=A,full=B",
      "case_seed": 2054933312,
      "size_tier": "medium",
      "body_bytes": 7652,
      "condition_sizes": {
        "full": {
          "bytes": 7706,
          "tokens_estimated": 1926
        },
        "summary": {
          "bytes": 344,
          "tokens_estimated": 86
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 17808,
          "tokens_estimated": 4452
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:41:22.900466+00:00",
      "cost_judge": 0.0270015,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full_siblings": 5.0,
        "score_full": 3.45,
        "improvement": 1.55,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A correctly uses IMeterFactory pattern for meter instantiation through DI lifecycle management. Response B creates meters directly with `new Meter()`, bypassing DI lifecycle management and violating modern OpenTelemetry best practices for .NET, which is a significant technical issue for production code."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A provides comprehensive coverage including full OrderMetrics and OrderService classes with detailed error handling, Docker Compose with multiple backends (Jaeger, Prometheus), testing examples, and both dev/prod configurations. Response B covers the essentials but lacks some implementation details and error handling patterns, keeping endpoints inline in Program.cs."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 3,
            "reasoning": "Response A exemplifies modern .NET conventions: IMeterFactory usage, static ActivitySource fields, ActivityStatusCode error handling, dimensional attributes on metrics, structured logging with named placeholders, and CancellationToken usage. Response B's direct meter creation circumvents proper lifecycle management, and while Aspire Dashboard and UseOtlpExporter() are good modern choices, the meter pattern issue is a critical violation of best practices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response A demonstrates excellent organization with clear section separators, comprehensive XML documentation, proper separation of concerns (OrderMetrics and OrderService as dedicated classes), and professional structure. Response B is concise and clean with good section headers, but concentrates everything in Program.cs, lacks dedicated classes for business logic, and the meter creation issue affects overall code quality for maintainability."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/full_vs_baseline/run2",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 67833152,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:41:44.992172+00:00",
      "cost_judge": 0.0265115,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_baseline": 2.95,
        "improvement": 2.05,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 2,
            "reasoning": "Response A contains a critical compilation error: `Interlocked.Decrement(ref _processorTasks.Count)` attempts to pass a property as a ref parameter, which is invalid. Response B correctly uses all Channel<T> APIs, Parallel.ForEachAsync, linked tokens, and async patterns with no technical errors."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides three examples but the fatal bug prevents any code from compiling/running. Response B fully implements producer, processor, consumer stages, error handling, timeout management, execution tracking, and includes comprehensive unit tests and DI setup examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A uses some patterns correctly (EnumeratorCancellation, linked tokens, nested while loops) but inconsistently applies ConfigureAwait(false) and lacks modern patterns like Parallel.ForEachAsync. Response B consistently demonstrates ConfigureAwait(false), ValueTask usage, sealed immutable records, integrated logging, proper error isolation, and timeout management with CancelAfter."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A is well-documented and structured but the critical bug and potential thread-safety issues with counter management undermine confidence. Response B demonstrates professional-grade code organization with sealed types, init-only properties, comprehensive XML documentation, unit tests, and dependency injection patterns that show production-readiness."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/full_vs_summary/run2",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 4034671258,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:42:09.684095+00:00",
      "cost_judge": 0.02658025,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 4.0,
        "improvement": 1.0,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Both responses correctly implement async streams, Channel<T>, and cancellation tokens. Response B demonstrates more sophisticated concurrent patterns with Parallel.ForEachAsync and better timeout management via CancelAfter on linked tokens, showing slightly deeper technical mastery."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A covers the core pipeline stages but executes them sequentially and lacks error aggregation patterns. Response B is more comprehensive with dedicated error handling, configuration management, concurrent execution via Task.WhenAll, and includes practical unit test examples demonstrating usage."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A demonstrates good practices like ConfigureAwait(false) and cooperative cancellation. Response B goes further with sealed classes/records for encapsulation, configuration pattern for extensibility, AllowSynchronousContinuations=false optimization, and demonstrates Parallel.ForEachAsync\u2014more aligned with modern .NET idioms."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A is well-documented with clear structure and a helpful summary table. Response B maintains excellent documentation while offering superior organization with dedicated configuration and result classes, test examples for clarity, and better separation of concerns through specialized error handling patterns."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-async-patterns/summary_vs_baseline/run2",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Implement a concurrent data processing pipeline using async streams, Channel<T>, and proper cancellation token propagation in .NET.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 531605446,
      "size_tier": "medium",
      "body_bytes": 10227,
      "condition_sizes": {
        "full": {
          "bytes": 10281,
          "tokens_estimated": 2570
        },
        "summary": {
          "bytes": 322,
          "tokens_estimated": 80
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:42:36.133420+00:00",
      "cost_judge": 0.02690525,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 5.0,
        "score_baseline": 2.25,
        "improvement": 2.75,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 2,
            "reasoning": "Response A correctly implements all async/await patterns, Channel<T> operations, and cancellation token handling. Response B has a critical compilation error in ProcessItemsAsync's finally block: it attempts to use Interlocked.Decrement(ref _processorTasks.Count), but List<T>.Count is a property, not a field, and cannot be passed by ref to Interlocked methods."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A comprehensively covers producer, transformer, aggregator, and orchestrator with dependency injection integration, proper logging infrastructure, and timeout handling. Response B covers the core pipeline but lacks DI integration and uses Console.WriteLine instead of logging, and the compilation error prevents it from functioning at all."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 2,
            "reasoning": "Response A demonstrates excellent modern .NET practices: ConfigureAwait(false) throughout, ILogger<T> dependency injection, IAsyncDisposable pattern, EnumeratorCancellation attribute, and linked cancellation tokens. Response B omits ConfigureAwait(false) from most operations, uses Console output instead of ILogger, lacks DI, and contains the non-compiling finally block logic."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 2,
            "reasoning": "Response A is well-structured with excellent XML documentation, clear separation of concerns, logical flow, and a helpful summary table. Response B has readable organization and multiple examples, but the compilation error in the processor finalization logic is a critical fatal flaw that prevents the code from running."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/full_vs_baseline/run2",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 3847015528,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:43:06.560088+00:00",
      "cost_judge": 0.018259,
      "cost_generation_allocated": 0.006661,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.05,
        "score_baseline": 5.0,
        "improvement": -1.95,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response A correctly presents modern patterns but is incomplete. Response B demonstrates all patterns with technically correct implementations including required properties, init-only members, collection expressions (C# 12), nullable annotations, and ArgumentNullException.ThrowIfNull()."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 2,
            "score_baseline": 5,
            "reasoning": "Response A asks for user input and provides only one small template example. Response B provides two complete, production-ready classes before and after refactoring, covering constructors, properties, collections, methods, validation, documentation, and project configuration."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A mentions best practices theoretically. Response B applies best practices comprehensively: immutability with readonly/init, proper encapsulation via IReadOnlyList<T>, required keyword, pattern matching, null-coalescing, LINQ over loops, expression-bodied members, consistent naming, and full nullable reference types."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_baseline": 5,
            "reasoning": "Response A presents well-structured guidance but the code is a template. Response B provides production-ready, fully refactored code with excellent readability, proper organization, clear naming conventions, appropriate documentation, and demonstrates actual implementation of all modern patterns."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/full_vs_summary/run2",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 153105518,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:43:35.486837+00:00",
      "cost_judge": 0.019528999999999998,
      "cost_generation_allocated": 0.006661,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.0,
        "score_summary": 5.0,
        "improvement": -1.0,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A correctly implements all modern .NET patterns including file-scoped namespaces, nullable reference types, expression bodies, records with required properties, and ArgumentNullException.ThrowIfNull(). Response B has a discrepancy: the table lists ArgumentNullException.ThrowIfNull as modern, but the actual code example uses the older null-coalescing throw pattern (?? throw), reducing technical consistency."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A provides a comprehensive before/after example demonstrating all four requested features (file-scoped namespaces, nullable types, expression bodies, naming conventions) plus additional modern features like records, collection initializers, and XML docs. Response B covers the features but the code example is simpler and introduces async/await patterns beyond scope, while the actual implementation of requested features in code is less thorough."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A demonstrates best practices throughout: immutable records with init properties, IReadOnlyList return types for encapsulation, pattern matching (is null), modern exception handling, and XML documentation. Response B mentions good practices in its table but the code example uses null-coalescing throw (older style) instead of the modern ThrowIfNull pattern it recommends, showing misalignment between guidance and implementation."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A provides highly readable, well-structured code with consistent naming conventions, excellent use of modern C# features, and comprehensive XML documentation that enhances maintainability. Response B's code is readable and structured but demonstrates fewer modern features in the actual example and is less comprehensive in scope compared to Response A's detailed refactoring."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-coding-standards/summary_vs_baseline/run2",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Refactor a legacy C# class to follow modern .NET coding standards including naming conventions, nullable reference types, expression bodies, and file-scoped namespaces.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 1767049346,
      "size_tier": "medium",
      "body_bytes": 5686,
      "condition_sizes": {
        "full": {
          "bytes": 5740,
          "tokens_estimated": 1435
        },
        "summary": {
          "bytes": 369,
          "tokens_estimated": 92
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:44:17.904638+00:00",
      "cost_judge": 0.033394,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.5,
        "score_baseline": 4.8,
        "improvement": -0.3,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 5,
            "reasoning": "Both responses demonstrate technically correct C# code with proper nullable reference types, file-scoped namespaces, collection expressions, and modern syntax. Response A uses DateTime.UtcNow (more correct than Now), while Response B uses records correctly. No technical errors in either."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers 11 distinct modernizations, includes .csproj configuration, and provides a comprehensive checklist. Response B covers the main modernizations and uses a helpful comparison table, but lacks .csproj guidance and is less exhaustive in scope."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates more breadth of best practices including init-only properties, DateTime.UtcNow, explicit readonly usage, and LINQ patterns. Response B uses records (which is excellent for data entities) but shows fewer distinct patterns overall. Both use ArgumentNullException.ThrowIfNull() and IReadOnlyList<T> correctly."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides comprehensive content but is quite verbose and potentially overwhelming. Response B is more concise, uses an effective comparison table format, and maintains excellent readability while conveying the same information more efficiently."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_vs_baseline/run2",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 3934066676,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:44:39.296117+00:00",
      "cost_judge": 0.015807,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.3,
        "score_baseline": 4.0,
        "improvement": 0.3,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A correctly identifies .NET-specific technical concerns (IDisposable patterns, LINQ anti-patterns, async anti-patterns, Roslyn analyzers, CA rules) that are directly relevant to C# development. Response B covers classic refactoring smells accurately but with less C#/.NET specificity."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 5,
            "reasoning": "Response B provides a more comprehensive checklist with 14 specific code smells compared to Response A's implicit ~8-10 categories. Response B explicitly covers additional important patterns like Data Classes, Switch Statements, Lazy Classes, and Message Chains that Response A omits."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A emphasizes modern .NET best practices including automated analysis tools (Roslyn, CA rules) and contemporary patterns like proper disposal and async handling. Response B relies on classic refactoring literature without addressing modern C# tooling and approaches."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Both responses are well-structured, professionally written, and clearly formatted. Response A uses emoji icons for visual distinction while Response B uses checkmarks; both approaches enhance readability equally well."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_vs_summary/run2",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 2254678358,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:45:40.246691+00:00",
      "cost_judge": 0.040486999999999995,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_full": 4.2,
        "score_summary": 5.0,
        "improvement": -0.8,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A correctly identifies core code smells with appropriate heuristics (e.g., >500 lines for god classes). Response B uses more precise and advanced terminology (captive dependencies, NRT violations, N+1 queries) reflecting deeper .NET expertise."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A covers major smell categories adequately. Response B is more thorough, explicitly addressing Dependency Injection patterns with lifetime concepts, specific async deadlock scenarios, and string allocation issues that Response A omits."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Both demonstrate solid understanding of .NET best practices. Response B showcases deeper expertise in modern conventions: Nullable Reference Types compliance, DI lifetime management, and async pitfalls are increasingly critical in contemporary .NET development."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 5,
            "reasoning": "Both responses are well-structured with clear formatting and emoji markers for visual hierarchy. Response B has marginally better logical flow with the 'How to Proceed' section, but both achieve excellent readability and professional presentation."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/summary_vs_baseline/run2",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 1527283009,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:45:59.980249+00:00",
      "cost_judge": 0.012077,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 4.0,
        "score_baseline": 3.45,
        "improvement": 0.55,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A lists generic code smells applicable to any language. Response B demonstrates deeper C# expertise by explicitly addressing IDisposable misuse, NRT (Nullable Reference Types) violations, async/await deadlocks, and LINQ-specific pitfalls\u2014all technically accurate to the .NET ecosystem."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A covers 14 distinct items including the three requested smells. Response B organizes analysis into 8 focused categories with explanatory context for each. Both adequately cover the prompt's requirements, though Response B better emphasizes modern C#-specific edge cases."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 3,
            "reasoning": "Response A promises generic best practice guidelines without demonstrating specific modern .NET conventions. Response B explicitly references contemporary best practices like NRT compliance, proper async patterns, service locator anti-patterns, and resource management\u2014showing alignment with current C# idioms."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 4,
            "reasoning": "Response A uses clear formatting with checkmarks and simple structure. Response B employs better organizational hierarchy with labeled sections, emoji headings, and concrete example deliverables, making it slightly more readable and professional."
          }
        ]
      }
    },
    {
      "id": "dotnet-csharp-code-smells/full_siblings_vs_full/run2",
      "entity_id": "dotnet-csharp-code-smells",
      "skill_name": "dotnet-csharp-code-smells",
      "prompt": "Analyze a C# codebase for common code smells and anti-patterns. Identify issues like god classes, feature envy, and primitive obsession, with refactoring recommendations.\n",
      "run_index": 2,
      "comparison": "full_siblings_vs_full",
      "condition_a": "full_siblings",
      "condition_b": "full",
      "ab_assignment": "full_siblings=B,full=A",
      "case_seed": 3726697179,
      "size_tier": "medium",
      "body_bytes": 8152,
      "condition_sizes": {
        "full": {
          "bytes": 8206,
          "tokens_estimated": 2051
        },
        "summary": {
          "bytes": 362,
          "tokens_estimated": 90
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        },
        "full_siblings": {
          "bytes": 18306,
          "tokens_estimated": 4576
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "full_siblings",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:46:15.669398+00:00",
      "cost_judge": 0.011302,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full_siblings": 4.55,
        "score_full": 3.55,
        "improvement": 1.0,
        "winner": "full_siblings",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response B demonstrates superior technical precision by citing specific CA rule numbers (CA2000, CA2213, CA1851, CA2200) throughout, whereas Response A mentions rules generically. Both correctly identify code smells, but B shows deeper .NET framework knowledge with concrete rule references."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full_siblings": 4,
            "score_full": 3,
            "reasoning": "Response B covers more ground with additional categories like Deep Nesting and more detailed LINQ anti-patterns (e.g., `.Count() > 0` vs `.Any()`). Response A is solid but somewhat surface-level in comparison, though both adequately request the necessary code input."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full_siblings": 5,
            "score_full": 4,
            "reasoning": "Response B aligns better with modern .NET best practices through explicit CA rule citations, EF Core pattern awareness, and async-specific guidance. Response A references Roslyn analyzers generically, while B provides the authoritative CA rule framework that modern .NET teams follow."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full_siblings": 4,
            "score_full": 3,
            "reasoning": "Response B maintains cleaner, more professional formatting with structured headers and minimal decoration, while Response A uses decorative emojis (\u2705 \u274c \ud83d\udd27  \ud83d\udccb) that reduce professional polish. Both are well-organized, but B's presentation is more suitable for enterprise code review contexts."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/full_vs_baseline/run2",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 342631278,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:47:46.506181+00:00",
      "cost_judge": 0.05691900000000001,
      "cost_generation_allocated": 0.029156,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.75,
        "score_baseline": 3.7,
        "improvement": 0.05,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A correctly uses ValueTask for IAsyncLifetime as per xUnit v3 spec, while Response B incorrectly uses Task instead of ValueTask, which is a violation of xUnit v3 requirements. However, Response A only demonstrates simulated async (Task.Delay), whereas Response B shows real EF Core async operations."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Both responses cover the core requirements: shared database fixtures, parameterized theories ([Fact], [Theory], [InlineData], [MemberData]), and async lifecycle management. Response A includes custom assertions and xUnit config. Response B adds cancellation token handling and integration tests with multiple classes, making them roughly equivalent in coverage."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_baseline": 4,
            "reasoning": "Response B demonstrates significantly more modern .NET patterns including proper dependency injection, logging with ILogger, mocking with Moq, cancellation token support throughout, service interface definitions, and DTOs. Response A lacks these practical patterns despite correct xUnit fixture patterns and custom assertions."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Response A is well-organized with clear sections and good documentation. Response B demonstrates slightly superior organization with comprehensive XML documentation, proper EF Core configuration, professional test structure, and a complete project configuration file including all dependencies."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/full_vs_summary/run2",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 2738557667,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:48:32.146491+00:00",
      "cost_judge": 0.04420399999999999,
      "cost_generation_allocated": 0.029156,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.75,
        "score_summary": 3.95,
        "improvement": 0.8,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A implements IAsyncLifetime with Task instead of ValueTask, which is incorrect for xUnit v3 specifications; Response B correctly uses ValueTask throughout, demonstrating proper async pattern implementation for modern xUnit versions."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Response A provides extensive coverage including full domain models, EF Core configuration, seeding, multiple fixture patterns, parameterized tests with ClassData, error scenarios, and project configuration. Response B is well-organized but uses in-memory mocking instead of real database integration, providing less comprehensive integration testing scenarios."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A follows good modern practices (FluentAssertions, nullable refs, cancellation tokens, argument validation) but misses xUnit v3-specific features. Response B excels with Assert.Multiple usage, proper ValueTask async patterns, custom domain-specific assertions, xunit.runner.json configuration, C# 12 primary constructors, and demonstrates xUnit v3 design patterns consistently."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A is well-documented and structured but verbose with significant code duplication across test classes. Response B is concise, highly maintainable with region-based organization, custom assertion helpers that improve readability, and cleaner test class structure without sacrificing clarity."
          }
        ]
      }
    },
    {
      "id": "dotnet-xunit/summary_vs_baseline/run2",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit v3 tests for a .NET order processing service with shared database fixtures, parameterized theories, and async lifecycle management.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 3624985976,
      "size_tier": "medium",
      "body_bytes": 9087,
      "condition_sizes": {
        "full": {
          "bytes": 9141,
          "tokens_estimated": 2285
        },
        "summary": {
          "bytes": 469,
          "tokens_estimated": 117
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:49:55.122628+00:00",
      "cost_judge": 0.0938915,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_summary": 4.55,
        "score_baseline": 4.45,
        "improvement": 0.1,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A uses ValueTask consistently throughout, which is the xUnit v3-optimized pattern for async operations. Response B uses Task, which is functionally correct but not specifically tailored to xUnit v3's async lifecycle features. This is a critical distinction when the prompt explicitly requests xUnit v3 tests."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A demonstrates more pattern variety including [Theory] with both [InlineData] and [ClassData], multiple database options (SQL Server and in-memory), and comprehensive fixture patterns. Response B includes [MemberData] and strong integration/concurrent testing but lacks [ClassData] and multiple database provider examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response B demonstrates superior production-ready patterns with ILogger<T> dependency injection, Moq mocking, and a custom NullLogger implementation. Response A omits logging entirely from the service layer, which is a significant gap in modern .NET practices. However, A's consistent use of ValueTask is an xUnit v3-specific best practice that B misses."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response B shows superior organization with logical test sections via regions, includes sophisticated concurrent processing scenarios, and demonstrates real mocking patterns. Response A is well-structured but exhibits more test repetition and simpler test scenarios overall."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/full_vs_baseline/run2",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 1446421205,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:50:20.586267+00:00",
      "cost_judge": 0.031914,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_baseline": 3.7,
        "improvement": 1.3,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A has critical syntax errors in compiled queries (GetCustomerWithOrderCountQuery uses .Select() after CompileAsyncQuery which returns Task, not IQueryable; GetPaginatedOrdersQuery incorrectly uses ToList()). Response B correctly implements all compiled queries with proper IAsyncEnumerable returns and async patterns throughout."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Both cover repository, unit of work, optimistic concurrency, compiled queries, and split queries. Response B additionally includes audit timestamp management, CancellationToken support throughout, NuGet dependencies, and explicit QuerySplittingBehavior configuration. Response A covers more edge cases but with some implementation errors."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response B excels with CancellationToken parameters throughout (essential for modern async scalability), sealed implementations, readonly collections in domain models, proper encapsulation (no DbContext exposure), and IAsyncEnumerable usage. Response A lacks CancellationToken support entirely and has encapsulation violations in examples (direct Context access)."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response B demonstrates superior code quality with clean sealed/readonly patterns, zero syntax errors, consistent null-checking, clear documentation, and proper modern C# idioms. Response A has good structure but contains compile-time errors in key examples and some architectural violations in the service layer demonstration."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/full_vs_summary/run2",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 347094901,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:50:43.229853+00:00",
      "cost_judge": 0.03419275,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.75,
        "score_summary": 3.95,
        "improvement": 0.8,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A correctly implements EF.CompileAsyncQuery() for actual compiled queries with proper IAsyncEnumerable returns. Response B's code comments mention 'compiled queries' but the actual methods use regular Include() calls without EF.CompileAsyncQuery(), which misses the core technical requirement. Additionally, Response A uses DateTimeOffset (best practice for UTC), while Response B uses DateTime."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 4,
            "score_summary": 5,
            "reasoning": "Both cover all requested features comprehensively. Response A covers compiled queries, split queries, repository pattern, unit of work, and concurrency handling. Response B adds more practical examples including controller usage, database migration example, and a more sophisticated concurrency conflict resolver with exponential backoff retry logic, making it slightly more complete for real-world scenarios."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A correctly implements IAsyncDisposable on IUnitOfWork, uses DateTimeOffset for timestamps, configures split query behavior globally, and follows modern async patterns throughout. Response B implements IDisposable instead of IAsyncDisposable on IUnitOfWork and uses DateTime instead of DateTimeOffset, both of which are less aligned with current .NET best practices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A presents clean, focused code with excellent XML documentation and a helpful summary table. Response B is more verbose and complex in some areas (e.g., ConcurrencyConflictResolver, though well-implemented), making it slightly harder to follow. Both have good structure, but Response A's conciseness and clarity give it a slight edge."
          }
        ]
      }
    },
    {
      "id": "dotnet-efcore-patterns/summary_vs_baseline/run2",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Design an EF Core data access layer with repository pattern, unit of work, optimistic concurrency, and query optimization using compiled queries and split queries.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 4071217208,
      "size_tier": "large",
      "body_bytes": 18988,
      "condition_sizes": {
        "full": {
          "bytes": 19042,
          "tokens_estimated": 4760
        },
        "summary": {
          "bytes": 438,
          "tokens_estimated": 109
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:51:43.440031+00:00",
      "cost_judge": 0.079464,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_summary": 3.7,
        "score_baseline": 4.7,
        "improvement": -1.0,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 3,
            "score_baseline": 4,
            "reasoning": "Response A claims to implement compiled queries but uses regular LINQ queries instead of EF.CompileAsyncQuery(), which is a significant technical discrepancy. Response B actually attempts to use EF.CompileAsyncQuery() despite minor syntax issues in some examples, demonstrating genuine compiled query implementation."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A covers all major features but misleadingly labels regular LINQ queries as 'compiled queries.' Response B comprehensively covers all requested patterns including actual compiled queries, query extensions, multiple concurrency strategies, connection pooling, pagination support, and diverse usage examples."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A demonstrates good async/await patterns and DI setup but lacks connection pooling and has limited concurrency resolution strategies. Response B follows superior practices: IAsyncDisposable for proper resource management, DbContextPool for production performance, multiple concurrency resolution strategies, query tagging for diagnostics, and DDD principles with aggregate roots."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A has well-structured, readable code with good documentation and helpful summary tables. Response B is equally well-documented with slightly cleaner extension methods, more practical service examples showing different scenarios (transactions, pagination, concurrency), and better overall code organization despite the compiled query syntax issues."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/full_vs_baseline/run2",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 4229973630,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:54:42.279695+00:00",
      "cost_judge": 0.036520250000000004,
      "cost_generation_allocated": 0.10341225000000001,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.5,
        "score_baseline": 3.0,
        "improvement": 1.5,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A has several incomplete implementations (TODOs for password hashing, refresh tokens, database queries) and uses overly-strict regex-based validation patterns that would reject legitimate input. Response B uses established patterns like ASP.NET Core Identity, proper EF Core integration, and includes SSRF prevention with IP validation\u2014all technically sound and production-ready."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A lacks database integration, has incomplete authentication flows, and missing several OWASP areas (no SSRF prevention). Response B comprehensively covers all requested security areas with working implementations: database context, resource-based authorization, audit event logging to database, SSRF prevention, account lockout mechanisms, and complete auth flows."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A uses custom authentication and validation approaches with some outdated patterns (regex injection detection is inferior to parameterized queries). Response B demonstrates modern .NET best practices: ASP.NET Core Identity framework, sealed classes for immutability, custom IAuthorizationHandler for resource-based authorization, proper HTTP client configuration for SSRF prevention, and environment-specific error handling."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A has duplicate security headers, redundant validation in multiple layers, and multiple TODO comments indicating incomplete work. Response B is well-organized with no incomplete implementations, includes XML documentation comments, proper logging scopes, consistent sealed class usage, and clear OWASP mappings\u2014though slightly more verbose due to comprehensiveness."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/full_vs_summary/run2",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 960607117,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:55:12.604800+00:00",
      "cost_judge": 0.04316275,
      "cost_generation_allocated": 0.11297225000000001,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.5,
        "score_summary": 3.5,
        "improvement": 1.0,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_summary": 3,
            "reasoning": "Response A demonstrates correct ASP.NET Core Identity, JWT, and middleware patterns throughout. Response B has compilation errors (`CreateApplicationBuilder()` should be `builder.Build()`), attribute naming issues (`[RateLimiterPolicy]` doesn't exist), missing BCrypt package reference, and problematic SQL injection detection via regex instead of parameterized queries."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A provides comprehensive coverage including Document management entities, DTOs, complete authorization handlers, audit logging with middleware, SSRF prevention, and service layer implementation. Response B covers core scenarios but lacks complete flows like refresh token validation and SSRF mitigation details."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 4,
            "reasoning": "Response A uses modern .NET patterns (sealed classes, resource-based authorization, structured logging with scopes, async/await consistently). Response B employs FluentValidation and Serilog (good practices) but includes anti-patterns like regex-based SQL injection detection, which provides false security, and doesn't fully embrace parameter-based protection."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_summary": 3,
            "reasoning": "Response A is well-structured with clear separation of concerns, good naming, and comprehensive documentation. Response B has decent organization but compilation errors, attribute mismatches, and the in-memory user dictionary lacks clear designation as demo-only, reducing production-readiness perception."
          }
        ]
      }
    },
    {
      "id": "dotnet-security-owasp/summary_vs_baseline/run2",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Implement OWASP Top 10 mitigations for a .NET web API including input validation, authentication, CSRF protection, security headers, and rate limiting.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 2294225804,
      "size_tier": "large",
      "body_bytes": 23681,
      "condition_sizes": {
        "full": {
          "bytes": 23735,
          "tokens_estimated": 5933
        },
        "summary": {
          "bytes": 528,
          "tokens_estimated": 132
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:55:44.852026+00:00",
      "cost_judge": 0.041873999999999995,
      "cost_generation_allocated": 0.09524400000000001,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 5.0,
        "score_baseline": 3.0,
        "improvement": 2.0,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A provides functionally correct implementations with proper JWT validation, BCrypt password hashing integration, and rate limiting using modern .NET 8 built-ins. Response B has numerous TODO comments indicating incomplete technical implementations, particularly for password hashing and refresh token validation logic."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 2,
            "reasoning": "Response A delivers a full end-to-end implementation with working authentication, CSRF protection, rate limiting, security headers, and audit logging. Response B contains significant gaps with TODOs for password validation, token refresh logic, database integration, and audit persistence, making it more of a skeleton than a complete solution."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A uses industry-standard practices (FluentValidation for typed validation, Serilog for structured logging, System.Threading.RateLimiting for modern rate limiting, IDistributedCache for scalability). Response B uses some good patterns (built-in anti-forgery, clear middleware ordering) but relies on a third-party rate limiter and custom, less type-safe validation."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 5,
            "score_baseline": 3,
            "reasoning": "Response A presents clean, well-organized, production-ready code with consistent patterns and comprehensive examples. Response B has readable structure but numerous TODO placeholders indicate incomplete development, reducing practical usability and maintainability for immediate deployment."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/full_vs_baseline/run2",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=A,baseline=B",
      "case_seed": 2761020389,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:58:37.781222+00:00",
      "cost_judge": 0.04088025,
      "cost_generation_allocated": 0.10280550000000001,
      "judge_attempts": 1,
      "scores": {
        "score_full": 4.5,
        "score_baseline": 3.45,
        "improvement": 1.05,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 4,
            "score_baseline": 3,
            "reasoning": "Response A demonstrates AOT-safe patterns with source-generated JSON serialization and correct async/cancellation patterns. Response B uses JSRuntime.InvokeAsync with eval, which is an anti-pattern and security risk, significantly undermining technical correctness despite otherwise sound service architecture."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A provides comprehensive implementation with IItemProvider<TItem> pattern supporting filtering, sorting, pagination, and server-side data fetching. Response B covers all required features but uses pre-loaded ICollection<TItem>, limiting scalability for truly large datasets, and provides a simpler overall feature set."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A explicitly addresses AOT safety, uses source-generated serialization, proper IAsyncDisposable patterns, and CancellationTokenSource for cleanup\u2014modern .NET best practices. Response B has good service architecture and code-behind patterns but the eval usage, event-based error handling without weak event patterns, and lack of AOT consideration represent significant departures from best practices."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 4,
            "score_baseline": 4,
            "reasoning": "Response A has excellent documentation, structure, and naming with clear separation of concerns, though RenderModeProvider<TItem> class definition is questionable. Response B excels in file organization and code-behind structure with excellent readability; both are well-formatted and maintainable, but neither has significant advantage overall."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/full_vs_summary/run2",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=B,summary=A",
      "case_seed": 3545417641,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:58:58.506424+00:00",
      "cost_judge": 0.03348025,
      "cost_generation_allocated": 0.09417450000000001,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_summary": 2.75,
        "improvement": 2.25,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A uses `.Result` on async operations in Virtualize component which is an anti-pattern that defeats async/await and risks deadlocks. Response B demonstrates correct async patterns throughout, proper cancellation token usage, and explicitly AOT-safe design with source-generated serialization."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A covers the four core features but lacks advanced patterns like pagination state, sorting/filtering abstractions, and proper data provider interfaces. Response B includes all requested features plus comprehensive pagination management, filtering, sorting, data table component, and realistic example with 5000 items."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_summary": 2,
            "reasoning": "Response A has critical issues: calling `.Result` on async operations (major anti-pattern), missing cancellation token support, oversimplified render mode detection, and not designed for AOT compilation. Response B follows modern .NET practices: proper IAsyncDisposable implementation, cancellation tokens throughout, source-generated JSON serialization, accessibility considerations, and explicit AOT-safety."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_summary": 3,
            "reasoning": "Response A is well-organized with clear structure but the async/await patterns are problematic. Response B demonstrates excellent code quality with clean abstractions (IItemProvider<T>), proper resource management, semantic HTML with ARIA labels, pattern matching, and production-ready polish throughout."
          }
        ]
      }
    },
    {
      "id": "dotnet-blazor-patterns/summary_vs_baseline/run2",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Build a Blazor component library with render mode detection, cascading parameters, error boundaries, and virtualized list rendering for large datasets.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=A,baseline=B",
      "case_seed": 682027349,
      "size_tier": "large",
      "body_bytes": 18225,
      "condition_sizes": {
        "full": {
          "bytes": 18279,
          "tokens_estimated": 4569
        },
        "summary": {
          "bytes": 410,
          "tokens_estimated": 102
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:59:20.069987+00:00",
      "cost_judge": 0.032124,
      "cost_generation_allocated": 0.081377,
      "judge_attempts": 1,
      "scores": {
        "score_summary": 2.7,
        "score_baseline": 4.7,
        "improvement": -2.0,
        "winner": "baseline",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 2,
            "score_baseline": 4,
            "reasoning": "Response A has a critical flaw: `Items?.ToListAsync().Result` in VirtualizedDataList blocks on async code, causing potential deadlocks and defeating async patterns. Response B uses proper async/await throughout without blocking calls. Response A's render mode detection via OperatingSystem.IsBrowser() is also less reliable than Response B's JS interop approach."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Both cover all four requested features (render mode detection, cascading parameters, error boundaries, virtualized lists), but Response B provides more comprehensive examples, multiple demonstration components, and covers more edge cases with better error scenarios and configuration options."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 2,
            "score_baseline": 5,
            "reasoning": "Response A violates async best practices with blocking `.Result` calls and tight component coupling. Response B demonstrates excellent modern .NET patterns: proper IAsyncDisposable implementation, event-driven error handling, separation of concerns via service layer, clean dependency injection, and consistent async/await usage throughout."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 3,
            "score_baseline": 5,
            "reasoning": "Response A has readable code but the anti-pattern of `.Result` and mixed concerns (error handling tightly bound to UI) reduce quality. Response B excels with clear folder structure (/Components, /Services, /Models), well-separated concerns, reusable base classes, comprehensive styling, and maintainable service architecture that scales better for production use."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/full_vs_baseline/run2",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 2,
      "comparison": "full_vs_baseline",
      "condition_a": "full",
      "condition_b": "baseline",
      "ab_assignment": "full=B,baseline=A",
      "case_seed": 2247479051,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T02:59:49.050445+00:00",
      "cost_judge": 0.030213999999999998,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 5.0,
        "score_baseline": 3.25,
        "improvement": 1.75,
        "winner": "full",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A has critical flaws in the authentication implementation\u2014the TestAuthenticationHandler constructor parameters (userId, roles, claims) are never wired from the factory, and the Base64 token creation doesn't integrate with the handler. Response B uses dependency injection to pass AuthContext to the handler, ensuring proper claim propagation and correct technical implementation throughout."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 4,
            "reasoning": "Response A covers the three core requirements with project structure and NuGet setup but lacks advanced scenarios. Response B provides more comprehensive coverage including multi-user authorization tests, role-based access control validation, Program.cs configuration guidance, practical fake implementations, and real-world patterns that Response A omits."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A uses IAsyncLifetime and collection fixtures correctly but employs Moq for external dependencies (anti-pattern) and uses a non-idiomatic authentication approach. Response B follows standard ASP.NET Core practices with fake implementations instead of mocks, proper DI-based authentication, extension methods for ergonomics, and ConfigureTestServices for cleaner service overrides."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 5,
            "score_baseline": 3,
            "reasoning": "Response A has good structure but the authentication section is confusing and non-functional. Response B demonstrates excellent code quality with comprehensive XML documentation, clear extension methods, maintainable test organization, practical helper patterns, and code that would actually execute successfully in production scenarios."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/full_vs_summary/run2",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 2,
      "comparison": "full_vs_summary",
      "condition_a": "full",
      "condition_b": "summary",
      "ab_assignment": "full=A,summary=B",
      "case_seed": 1622921028,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T03:00:13.950874+00:00",
      "cost_judge": 0.027311500000000002,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 1,
      "scores": {
        "score_full": 3.0,
        "score_summary": 4.45,
        "improvement": -1.45,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A creates redundant PostgreSQL containers (both in PostgresFixture and ApiTestFactory), and the custom authentication handler using AuthenticationSchemeOptions is unconventional for Minimal APIs. Response B uses standard JWT token generation and clean service override patterns without redundancy."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_full": 3,
            "score_summary": 4,
            "reasoning": "Response A covers the core requirements but lacks comprehensive test scenarios and has unclear integration with Program.cs for the custom auth handler. Response B provides more complete examples including expired token handling, a reusable ApiTestBase pattern, and explicit migration support."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_full": 3,
            "score_summary": 5,
            "reasoning": "Response A uses IAsyncLifetime correctly but employs an unconventional custom authentication handler and creates redundant containers. Response B follows industry-standard JWT token authentication, implements the DRY principle with ApiTestBase, uses Bearer tokens (standard for APIs), and provides clean service overrides via fluent API."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_full": 3,
            "score_summary": 5,
            "reasoning": "Response A is well-documented but has architectural redundancy and unnecessarily complex authentication patterns. Response B has excellent structure with no redundancy, provides highly reusable helper methods (GetAdminClient, ExecuteInDbContext), cleaner separation of concerns, and eliminates duplication through ApiTestBase inheritance."
          }
        ]
      }
    },
    {
      "id": "dotnet-integration-testing/summary_vs_baseline/run2",
      "entity_id": "dotnet-integration-testing",
      "skill_name": "dotnet-integration-testing",
      "prompt": "Set up integration tests for a .NET Minimal API using WebApplicationFactory with custom service overrides, Testcontainers for database isolation, and authentication test helpers.\n",
      "run_index": 2,
      "comparison": "summary_vs_baseline",
      "condition_a": "summary",
      "condition_b": "baseline",
      "ab_assignment": "summary=B,baseline=A",
      "case_seed": 1873984185,
      "size_tier": "large",
      "body_bytes": 21367,
      "condition_sizes": {
        "full": {
          "bytes": 21421,
          "tokens_estimated": 5355
        },
        "summary": {
          "bytes": 383,
          "tokens_estimated": 95
        },
        "baseline": {
          "bytes": 0,
          "tokens_estimated": 0
        }
      },
      "conditions_present": [
        "baseline",
        "full",
        "summary"
      ],
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "27906ad7-5a1c-47d7-b3c0-e6eaa0a8d5af",
      "seed": 42,
      "timestamp": "2026-02-26T03:01:01.977340+00:00",
      "cost_judge": 0.0542615,
      "cost_generation_allocated": 0.0,
      "judge_attempts": 2,
      "scores": {
        "score_summary": 4.55,
        "score_baseline": 4.45,
        "improvement": 0.1,
        "winner": "summary",
        "per_criterion": [
          {
            "name": "technical_accuracy",
            "weight": 0.3,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response A uses a simplified Base64-encoded token approach with TestAuthenticationHandler that bypasses JWT validation, which doesn't fully test real JWT middleware behavior. Response B implements proper JWT token generation using JwtSecurityToken with HS256 signing, enabling actual JWT validation testing in production scenarios."
          },
          {
            "name": "completeness",
            "weight": 0.25,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A is more comprehensive with project structure, NuGet setup, sample Program.cs, appsettings.Testing.json, explicit collection fixtures, detailed test examples (9+ test cases), and a best practices summary. Response B covers core requirements but omits appsettings configuration and provides fewer test examples (5 test cases)."
          },
          {
            "name": "best_practices",
            "weight": 0.25,
            "score_summary": 5,
            "score_baseline": 4,
            "reasoning": "Response B demonstrates superior patterns: proper JWT token generation for realistic authentication testing, reusable ApiTestBase class reducing test boilerplate, in-memory database option for lightweight tests, and clean extension methods for HttpClient. Response A's test handler approach is valid but doesn't align with production JWT validation patterns."
          },
          {
            "name": "code_quality",
            "weight": 0.2,
            "score_summary": 4,
            "score_baseline": 5,
            "reasoning": "Response A excels with comprehensive XML documentation, clear examples, and FluentAssertions usage that makes assertions highly readable. Response B has clean code with good inheritance patterns and extension methods but provides fewer examples and less detailed inline documentation, making it slightly less instructive."
          }
        ]
      }
    }
  ],
  "artifacts": {}
}
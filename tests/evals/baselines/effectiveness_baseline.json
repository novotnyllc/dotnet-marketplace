{
  "meta": {
    "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
    "timestamp": "2026-02-26T01:36:15.704702+00:00",
    "backend": "claude",
    "model": "haiku",
    "judge_model": "haiku",
    "seed": 42,
    "total_cost": 2.835646,
    "eval_type": "effectiveness",
    "aborted": false
  },
  "summary": {
    "dotnet-blazor-patterns": {
      "mean": 1.4167,
      "stddev": 0.5401,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-containers": {
      "mean": 1.3083,
      "stddev": 0.6256,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-csharp-async-patterns": {
      "mean": 0.8583,
      "stddev": 0.7151,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-csharp-coding-standards": {
      "mean": 0.9167,
      "stddev": 0.367,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-efcore-patterns": {
      "mean": 1.325,
      "stddev": 1.1286,
      "n": 6,
      "wins_enhanced": 5,
      "wins_baseline": 1,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 0.8333
    },
    "dotnet-minimal-apis": {
      "mean": 0.875,
      "stddev": 0.6586,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-native-aot": {
      "mean": 0.9,
      "stddev": 0.6221,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-observability": {
      "mean": 0.9417,
      "stddev": 0.4271,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-resilience": {
      "mean": 1.3333,
      "stddev": 0.7292,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    },
    "dotnet-security-owasp": {
      "mean": 0.775,
      "stddev": 0.4824,
      "n": 6,
      "wins_enhanced": 5,
      "wins_baseline": 1,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 0.8333
    },
    "dotnet-testing-strategy": {
      "mean": 0.575,
      "stddev": 0.5027,
      "n": 6,
      "wins_enhanced": 5,
      "wins_baseline": 1,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 0.8333
    },
    "dotnet-xunit": {
      "mean": 1.825,
      "stddev": 0.5931,
      "n": 6,
      "wins_enhanced": 6,
      "wins_baseline": 0,
      "ties": 0,
      "errors": 0,
      "total_cases": 6,
      "win_rate": 1.0
    }
  },
  "cases": [
    {
      "id": "dotnet-blazor-patterns/0/0",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Set up a Blazor Web App with InteractiveAuto render mode. The home page should be Static SSR for SEO, the dashboard should use streaming rendering for slow data, and a real-time counter component should be interactive. Show proper render mode boundaries and PersistentComponentState usage.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1293773937,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:36:56.370837+00:00",
      "cost": 0.0242305,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.5,
        "baseline_score": 2.4,
        "improvement": 2.1,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "render_mode_selection",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A correctly uses StaticRenderMode for Home (SEO), InteractiveServerRenderMode for Dashboard, and InteractiveWebAssembly for Counter with explicit @rendermode directives. Response B defaults to InteractiveAuto globally (set in App.razor and passed to Routes), causing Home to be interactive rather than static SSR, violating the SEO requirement. The [ExcludeFromInteractiveRouting] attribute alone doesn't change render mode."
        },
        {
          "name": "streaming_and_prerendering",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A implements @attribute [StreamRendering] on Dashboard to send initial HTML immediately while data loads, plus proper PersistentComponentState registration to preserve data across prerender-to-interactive transitions. Response B omits [StreamRendering] entirely, meaning the 1500ms delay blocks HTML delivery, defeating the streaming rendering purpose explicitly requested. Response B has PersistentComponentState on Counter but not where it's needed for streaming."
        },
        {
          "name": "project_structure",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A explicitly references the .Client project with proper assembly configuration (typeof(BlazorAutoApp.Client.Program)) and shows WebAssembly Program.cs setup, demonstrating clear server/client separation. Response B uses standard structure but doesn't explicitly show Client project setup or component discovery boundaries, making the architecture less clear."
        },
        {
          "name": "routing_and_navigation",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A uses basic Router and Routes setup with @page directives but lacks navigation UI components. Response B provides a more complete navigation experience with NavMenu and NavLink components for proper enhanced navigation, making the example more production-ready for navigation patterns."
        },
        {
          "name": "aot_safe_patterns",
          "score_a": 5,
          "score_b": 1,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A implements source-generated JsonSerializerContext with [JsonSerializable] attributes and ConfigureHttpJsonOptions registration with TypeInfoResolverChain.Insert, fully addressing AOT safety for serialization. Response B provides no AOT-safe patterns, JsonSerializerContext, or source generation configuration, leaving the app vulnerable to reflection-based failures under trimming/AOT."
        }
      ]
    },
    {
      "id": "dotnet-blazor-patterns/1/0",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "I need to choose the right Blazor hosting model for a Line-of-Business app with 200 concurrent users, offline requirements for some features, and SEO for public-facing pages. Compare the options and show the project setup.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3086254366,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:37:30.837465+00:00",
      "cost": 0.021176099999999996,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.35,
        "baseline_score": 1.95,
        "improvement": 1.4,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "render_mode_selection",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A covers Static, InteractiveServer, and InteractiveWebAssembly but omits InteractiveAuto, which is the optimal choice for 200 concurrent users with offline capability. Response B explicitly recommends InteractiveAuto as the 'sweet spot' and correctly explains the transition from Server to WASM, directly addressing the specific requirements."
        },
        {
          "name": "streaming_and_prerendering",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Neither response implements [StreamRendering] or PersistentComponentState patterns. Response A shows no streaming discussion and Response B mentions prerendering conceptually but lacks technical implementation of either feature for avoiding double data-fetching and flicker."
        },
        {
          "name": "project_structure",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A references LobApp.Client project but doesn't demonstrate proper separation of WASM-targeted components into the .Client project directory. Response B explicitly shows LobApp.Client/ structure with clear file path comments like '* Pages/OrderForm.razor - Client project *' and demonstrates proper Server vs Client project boundaries."
        },
        {
          "name": "routing_and_navigation",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A uses custom routing logic checking PageType.Name.StartsWith(), which is non-idiomatic and over-engineered. Response B shows standard @page directives and explicit NavigationManager.NavigateTo() usage in functional examples, though neither demonstrates route constraints or [SupplyParameterFromQuery] attributes."
        },
        {
          "name": "aot_safe_patterns",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response addresses AOT safety, source-generated JsonSerializerContext, or trimming considerations despite targeting .NET 10. Both use reflection-agnostic patterns implicitly but provide no explicit AOT guidance for WASM deployment."
        }
      ]
    },
    {
      "id": "dotnet-containers/0/0",
      "entity_id": "dotnet-containers",
      "skill_name": "dotnet-containers",
      "prompt": "Create a production-ready Dockerfile for a multi-project .NET solution with an API project and a shared library. It should use multi-stage builds, optimized layer caching, rootless execution, and a health check endpoint.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 4209049223,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:38:39.724691+00:00",
      "cost": 0.0423296,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.55,
        "baseline_score": 3.65,
        "improvement": 0.9,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "multi_stage_build",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses a clean 3-stage build (SDK\u2192publish\u2192chiseled runtime) with proper layer caching by copying solution/project files before source code, then restoring the entire solution. Response B has 4 stages with a redundant base stage and only restores the API project, which is less explicit for multi-project solutions."
        },
        {
          "name": "rootless_and_security",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A properly uses chiseled image (noble-chiseled) providing non-root app user (UID 1654) by default with minimal attack surface (no shell/package manager). Response B uses standard slim image and attempts USER $APP_UID where $APP_UID is undefined, causing the directive to fail and the container to be non-functional."
        },
        {
          "name": "base_image_selection",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A selects aspnet:10.0-noble-chiseled, the optimal distroless variant for production ASP.NET Core apps with minimal security surface. Response B uses aspnet:8.0-bookworm-slim which is appropriate but includes more overhead than chiseled. Both avoid hardcoding patch versions."
        },
        {
          "name": "health_and_diagnostics",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 2,
          "baseline_score": 5,
          "reasoning": "Response A provides well-designed health check endpoints (/health/live, /health/ready with tag-based filtering) but the HEALTHCHECK directive is broken (dotnet doesn't accept --health-check flag, especially problematic for chiseled images with no shell). Response B correctly implements HEALTHCHECK with curl against actual /healthz endpoint plus detailed monitoring endpoints."
        },
        {
          "name": "optimization",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A is comprehensive with detailed .dockerignore, explicit SDK Container Publish MSBuild properties (ContainerBaseImage, ContainerImageTag, ContainerPort, ContainerLabel), and clear caching strategy documentation. Response B includes .dockerignore and build arguments but omits SDK Container Publish details and advanced optimization options."
        }
      ]
    },
    {
      "id": "dotnet-containers/1/0",
      "entity_id": "dotnet-containers",
      "skill_name": "dotnet-containers",
      "prompt": "What is the difference between using a multi-stage Dockerfile and dotnet publish /t:PublishContainer for containerizing a .NET app? When should I use each approach? Show me how to use the SDK container publish with chiseled base images.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2211165448,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:39:09.175041+00:00",
      "cost": 0.018466399999999997,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.5,
        "baseline_score": 2.35,
        "improvement": 2.15,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "multi_stage_build",
          "score_a": 5,
          "score_b": 1,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A provides a complete, correct multi-stage Dockerfile example with SDK build stage, separate restore, and chiseled aspnet runtime stage using --no-restore. Response B discusses multi-stage Dockerfiles conceptually but provides no actual implementation example."
        },
        {
          "name": "rootless_and_security",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A explicitly mentions UID 1654 for the app user, emphasizes no-shell attack surface reduction, and consistently uses chiseled images with port 8080. Response B covers security and non-root defaults but is less explicit about the specific UID and provides less detailed security rationale."
        },
        {
          "name": "base_image_selection",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A correctly selects aspnet for ASP.NET Core and explains chiseled-extra for globalization needs, using major.minor versioning. Response B shows multiple variants (chiseled, chiseled-extra, Alpine, AOT) but lacks explicit mapping to use cases and doesn't discuss runtime vs runtime-deps distinction."
        },
        {
          "name": "health_and_diagnostics",
          "score_a": 5,
          "score_b": 1,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A implements health checks with tag-based filtering, HealthCheckResult, and JSON response writer; acknowledges chiseled images lack curl and rely on orchestrator probes. Response B completely omits health check implementation and endpoints."
        },
        {
          "name": "optimization",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 2,
          "baseline_score": 3,
          "reasoning": "Response A demonstrates ContainerBaseImage and ContainerImageTag MSBuild properties but lacks .dockerignore, GC memory limits, and DOTNET_SYSTEM_GLOBALIZATION_INVARIANT discussion. Response B shows InvariantGlobalization property and size optimization awareness but also lacks .dockerignore and memory limit details."
        }
      ]
    },
    {
      "id": "dotnet-csharp-async-patterns/0/0",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Write an async service that loads a dashboard by fetching orders, user profile, and statistics in parallel, with a 30-second timeout and proper cancellation support. Include error handling for partial failures.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1304474040,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:39:51.374334+00:00",
      "cost": 0.028984999999999997,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.35,
        "baseline_score": 4.3,
        "improvement": 0.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "async_all_the_way",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A properly uses async/await throughout but accesses .Result after WhenAll completion (while technically safe, not idiomatic). Response B has cleaner async patterns with no .Result access antipattern."
        },
        {
          "name": "cancellation_propagation",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excellently implement CancellationTokenSource.CreateLinkedTokenSource, CancelAfter for 30-second timeout, and forward tokens to all downstream calls with proper exception handling."
        },
        {
          "name": "parallel_patterns",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses Task.WhenAll correctly but relies on .Result for completion verification. Response B uses an elegant DashboardResult<T> wrapper pattern that handles component-level results cleanly without .Result antipattern."
        },
        {
          "name": "configureawait_and_context",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 5,
          "reasoning": "Response A consistently uses ConfigureAwait(false) throughout library code, adhering to best practices. Response B omits ConfigureAwait(false) in the DashboardService (library code), which is a clear violation of the criterion requiring it in reusable service code."
        },
        {
          "name": "streaming_and_disposal",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Neither response requires IAsyncEnumerable or IAsyncDisposable patterns for this use case, so criterion is not applicable. Both handle scope appropriately with no disposal issues."
        }
      ]
    },
    {
      "id": "dotnet-csharp-async-patterns/1/0",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "I have a .NET service that sometimes deadlocks. It calls .Result on async methods and uses async void for event handlers. Show me how to fix these patterns and explain why they are dangerous.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3102428295,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:40:15.189315+00:00",
      "cost": 0.0154415,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 2.95,
        "baseline_score": 2.35,
        "improvement": 0.6,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "async_all_the_way",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A excellently explains .Result/async void dangers but presents GetAwaiter().GetResult() and Task.Run as acceptable solutions, slightly deviating from pure async-all-the-way philosophy. Response B strictly adheres to the principle with clear guidance against any blocking patterns and proper async/await throughout."
        },
        {
          "name": "cancellation_propagation",
          "score_a": 1,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Response A completely omits CancellationToken from all examples and explanations, missing a critical async pattern. Response B demonstrates practical cancellation token usage with `CancellationToken ct = default` parameters, forwarding to downstream calls, and ASP.NET Core integration, though it lacks advanced patterns like CreateLinkedTokenSource."
        },
        {
          "name": "parallel_patterns",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses equally omit coverage of Task.WhenAll, Parallel.ForEachAsync, and concurrent operation patterns. This is appropriate given the user's specific prompt focuses on .Result and async void, but both fail this criterion equally."
        },
        {
          "name": "configureawait_and_context",
          "score_a": 4,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 4,
          "reasoning": "Response A explicitly covers ConfigureAwait(false) for library code with clear explanation of SynchronizationContext deadlock avoidance. Response B completely omits ConfigureAwait(false) from all examples and recommendations, missing a library code best practice."
        },
        {
          "name": "streaming_and_disposal",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses lack coverage of IAsyncEnumerable with [EnumeratorCancellation], await using for IAsyncDisposable, and proper BackgroundService usage. Response B mentions BackgroundService in passing but doesn't explain or demonstrate it properly."
        }
      ]
    },
    {
      "id": "dotnet-csharp-coding-standards/0/0",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Review and refactor this C# service class to follow modern .NET coding standards. Fix naming, access modifiers, null handling, and file organization: class orderService { readonly IOrderRepository repo; string get_customer_name(int id) { var c = repo.GetCustomer(id); if (c == null) return null; return c.firstName + \" \" + c.lastName; } }",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 401503863,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:41:03.286320+00:00",
      "cost": 0.035527,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.6,
        "baseline_score": 3.55,
        "improvement": 1.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "naming_conventions",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A follows conventions well (PascalCase, _camelCase fields), but Response B is more thorough with a detailed comparison table and consistently applies descriptive names throughout. Both use proper PascalCase and _camelCase patterns, though Response B's explicit documentation of each naming change is clearer."
        },
        {
          "name": "code_style",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response B uses modern `is null` pattern matching which is the preferred modern approach, while Response A uses `?.FirstName is null` which is less idiomatic. Response B's alternative with `is { }` pattern demonstrates superior modern C# style. Response A's `string.Concat` alternative also lacks clarity compared to interpolation."
        },
        {
          "name": "type_design",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses use basic dependency injection but neither seals the class or enforces interface implementation in the main solution. Response A mentions interfaces as additional consideration, while Response B includes it in the comparison table, but neither fully implements type design best practices like sealing or required interface segregation."
        },
        {
          "name": "defensive_patterns",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A properly uses null-coalescing with throw and null-conditional operators, but the multi-line null check is verbose. Response B demonstrates superior defensive patterns with the modern `is null` check, proper null-coalescing in constructor, and provides an advanced pattern-matching alternative with `is { }` that's more concise and expressive."
        },
        {
          "name": "documentation_and_enforcement",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both include comprehensive XML documentation with summary, param, and returns tags. Response B uses more semantically correct XML tags (`<see langword=\"null\"/>` and `<paramref/>`) which are best practices for modern documentation. Neither addresses EditorConfig or Directory.Build.props enforcement configuration."
        }
      ]
    },
    {
      "id": "dotnet-csharp-coding-standards/1/0",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Write a well-structured C# interface and implementation for a payment processing service with proper naming conventions, CancellationToken support, XML documentation, and sealed class design.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1486380304,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:43:01.395900+00:00",
      "cost": 0.11728225,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.6,
        "baseline_score": 3.65,
        "improvement": 0.95,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "naming_conventions",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses follow PascalCase for types, I-prefix for interfaces, _camelCase for private fields, camelCase for parameters, and Async suffix on async methods. Response B uses the conventional `ct` abbreviation for CancellationToken parameters while Response A uses the full name; both are acceptable."
        },
        {
          "name": "code_style",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses traditional brace-style namespaces instead of modern file-scoped syntax and uses `== null` checks instead of the preferred `is null` pattern. Response B demonstrates modern C# 10+ style with file-scoped namespaces, `is null` pattern matching, explicit access modifiers including `sealed` and `required`, and proper null-conditional operators."
        },
        {
          "name": "type_design",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Both responses seal appropriate classes. Response A's IPaymentProcessingService violates Interface Segregation Principle by combining payment processing, refunds, status checks, and validation in a single interface. Response B better segregates concerns with separate IPaymentValidator and IPaymentGateway interfaces, allowing clients to depend only on what they need."
        },
        {
          "name": "defensive_patterns",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses properly use CancellationToken as the last parameter with default values, forward tokens to downstream async calls, use appropriate null-checking patterns, include braces for all control flow statements, and employ null-coalescing operators correctly."
        },
        {
          "name": "documentation_and_enforcement",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses provide comprehensive XML documentation with summary, param, returns, and exception tags on public API surfaces. Neither response includes EditorConfig or Directory.Build.props configuration for enforcing style rules through build-time analysis."
        }
      ]
    },
    {
      "id": "dotnet-efcore-patterns/0/0",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Set up EF Core for an ASP.NET Core API with a background order processing service. The API handles web requests and the background service processes orders in batches. Show the DbContext registration, proper lifetime management, and read-only query optimization.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3470521283,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:43:31.518684+00:00",
      "cost": 0.0215715,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.6,
        "baseline_score": 2.2,
        "improvement": 1.4,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "dbcontext_lifetime",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A properly registers both scoped DbContext for web requests and IDbContextFactory<T> for background services, with clear documentation of the pattern. Response B uses IServiceScopeFactory instead of AddDbContextFactory, which is a working workaround but not the recommended EF Core pattern for background services."
        },
        {
          "name": "query_optimization",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A demonstrates comprehensive optimization: AsNoTracking, AsNoTrackingWithIdentityResolution for deduplication, and global SplitQuery configuration to prevent Cartesian explosion. Response B uses basic AsNoTracking but omits AsNoTrackingWithIdentityResolution and split query handling when including multiple collections."
        },
        {
          "name": "interceptor_patterns",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response implements SaveChangesInterceptor, soft delete patterns, or interceptor registration via DI. Both use alternative approaches (default values, manual properties) instead of the interceptor pattern specified in the criterion."
        },
        {
          "name": "migration_practices",
          "score_a": 2,
          "score_b": 1,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A explicitly warns against Database.Migrate() at startup ('Do not call Database.Migrate() at startup in production') though doesn't show the production alternative. Response B directly violates the criterion by calling dbContext.Database.Migrate() at application startup, which is an anti-pattern for production deployments."
        },
        {
          "name": "cancellation_and_resiliency",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses properly propagate CancellationToken throughout async methods and configure EnableRetryOnFailure for connection resiliency. Response B shows more sophisticated timeout handling with CreateLinkedTokenSource, while Response A demonstrates consistent CT usage. Neither shows CreateExecutionStrategy for multi-SaveChanges atomic operations."
        }
      ]
    },
    {
      "id": "dotnet-efcore-patterns/1/0",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "My EF Core query loading Orders with Items and Payments is slow due to Cartesian explosion. How do I fix this? Also show me how to add automatic audit timestamps via an interceptor.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 4061780464,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:44:10.414320+00:00",
      "cost": 0.028144899999999997,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 2.7,
        "baseline_score": 3.15,
        "improvement": -0.45,
        "winner": "baseline"
      },
      "per_criterion_breakdown": [
        {
          "name": "dbcontext_lifetime",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both correctly implement AddDbContext for scoped registration. Response A shows basic pattern; Response B shows both web and background service patterns. Neither discusses IDbContextFactory, AddDbContextFactory, or AddDbContextPool constraints, making them equal on substance despite different presentation."
        },
        {
          "name": "query_optimization",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A explains Cartesian explosion and applies AsSplitQuery with CancellationToken propagation. Response B provides superior explanation with actual generated SQL showing the 3 separate queries, demonstrates global configuration and per-query override, and uses clearer technical terminology. Both miss AsNoTracking for read-only optimization."
        },
        {
          "name": "interceptor_patterns",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A implements SaveChangesInterceptor with async-only pattern and basic audit tracking. Response B provides more comprehensive implementation with both sync and async patterns, IHttpContextAccessor integration for user tracking, ModifiedBy field support, cleaner helper methods, and fallback to Environment.UserName. Both lack soft delete and HasQueryFilter patterns."
        },
        {
          "name": "migration_practices",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 1,
          "baseline_score": 2,
          "reasoning": "Response A provides no migration guidance whatsoever. Response B shows migration commands and OnModelCreating configuration with HasDefaultValueSql and indexes. Both lack migration bundles, idempotent scripts, explicit --project flags, warnings against Database.Migrate() startup calls, and HasData seed configuration."
        },
        {
          "name": "cancellation_and_resiliency",
          "score_a": 3,
          "score_b": 2,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A consistently propagates CancellationToken through SaveChangesAsync(ct) in usage examples. Response B omits CancellationToken from SaveChangesAsync() calls in examples, showing inconsistent propagation. Neither addresses EnableRetryOnFailure or CreateExecutionStrategy patterns."
        }
      ]
    },
    {
      "id": "dotnet-minimal-apis/0/0",
      "entity_id": "dotnet-minimal-apis",
      "skill_name": "dotnet-minimal-apis",
      "prompt": "Build a Minimal API for a product catalog with CRUD endpoints. The API should use route groups, TypedResults for response types, and an endpoint filter for request validation. Include proper OpenAPI metadata.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2485055861,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:44:30.859114+00:00",
      "cost": 0.0131858,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 5.0,
        "baseline_score": 3.5,
        "improvement": 1.5,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "typed_results_usage",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses TypedResults consistently with proper union types for all endpoints (e.g., Results<Ok<T>, NotFound>, Results<Created<T>, Conflict>). Response B uses TypedResults but inconsistently declares union types\u2014many endpoints omit possible return codes (e.g., BadRequest from validation isn't in return type union), breaking the compile-time safety contract."
        },
        {
          "name": "route_group_organization",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A demonstrates advanced patterns with nested route groups (search group under products group) and clean extension method pattern. Response B uses route groups well but doesn't demonstrate nesting or versioning patterns, making it functional but less pedagogically complete."
        },
        {
          "name": "endpoint_filters",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A implements a generic, reusable ValidationFilter<T> using System.ComponentModel.DataAnnotations.Validator and proper argument extraction via OfType<T>(). Response B's ProductValidationFilter uses manual validation logic and context.GetArgument<T>(0), which is less robust and not reusable across different DTOs."
        },
        {
          "name": "parameter_binding",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses explicit route constraints ({id:int}), proper [FromQuery] attributes for query parameters, and direct DI injection. Response B binds parameters correctly but lacks explicit type constraints in routes ({id} instead of {id:int}), making it less explicit about type expectations."
        },
        {
          "name": "openapi_integration",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A provides comprehensive OpenAPI metadata with WithName, WithSummary, WithDescription, Produces/ProducesProblem, and ConfigureHttpJsonOptions for serialization. Response B includes WithOpenApi, WithTags, and good documentation but offers less granular control over response documentation compared to Response A's more detailed approach."
        }
      ]
    },
    {
      "id": "dotnet-minimal-apis/1/0",
      "entity_id": "dotnet-minimal-apis",
      "skill_name": "dotnet-minimal-apis",
      "prompt": "I have a growing Minimal API with 30+ endpoints all in Program.cs. How should I reorganize this for maintainability? Show me the extension method pattern with route groups.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2091029073,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:45:15.424722+00:00",
      "cost": 0.0320992,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.75,
        "baseline_score": 3.4,
        "improvement": 0.35,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "typed_results_usage",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A has a critical compilation error in GetTodoById\u2014it declares return type Task<Ok<TodoResponse>> but returns TypedResults.NotFound(), which violates type safety. Response B correctly uses Results<Ok<T>, NotFound> union types throughout, with return types matching actual return statements (e.g., GetById properly declares Results<Ok<ProductDto>, NotFound>)."
        },
        {
          "name": "route_group_organization",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response A demonstrates more sophisticated organization with nested route groups (e.g., admin subgroup in UserEndpoints), centralized MapApiEndpoints orchestrator, and detailed project structure. Response B shows solid extension method pattern with clean Program.cs but uses simpler flat organization without nested subgroups or advanced hierarchical patterns."
        },
        {
          "name": "endpoint_filters",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 4,
          "reasoning": "Response A provides complete, working filter implementations with proper ValueTask<object?> signatures, EndpointFilterInvocationContext, and chaining via AddEndpointFilter on route groups. Response B only sketches a WithApiDefaults helper that references undefined RequestLoggingFilter without showing actual implementation details."
        },
        {
          "name": "parameter_binding",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses show basic binding: route parameters (implicit and explicit {id:int} constraint in Response B), DI injection, and implicit body binding. Neither demonstrates [FromQuery], [FromHeader], or [AsParameters] attributes for more complex binding scenarios."
        },
        {
          "name": "openapi_integration",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A includes WithName, WithSummary, WithDescription, WithTags, Accepts, and Produces metadata but omits Program.cs service registration (AddOpenApi, MapOpenApi). Response B demonstrates complete integration with builder.Services.AddOpenApi(), app.MapOpenApi() in Program.cs, and ConfigureHttpJsonOptions configuration, though it lacks Produces metadata examples."
        }
      ]
    },
    {
      "id": "dotnet-native-aot/0/0",
      "entity_id": "dotnet-native-aot",
      "skill_name": "dotnet-native-aot",
      "prompt": "Publish an ASP.NET Core Minimal API as a Native AOT binary. Show the project configuration, source-generated JSON serialization, CreateSlimBuilder usage, ILLink descriptors for a type that uses reflection, and a Dockerfile using runtime-deps base image.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1949536314,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:46:02.166428+00:00",
      "cost": 0.0315588,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.15,
        "baseline_score": 3.8,
        "improvement": 0.35,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "publish_configuration",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A correctly sets PublishAot and related properties but omits EnableAotAnalyzer and EnableTrimAnalyzer, missing development-time diagnostics. Response B explicitly enables these analyzers and demonstrates the proper workflow with 'dotnet build' commands for fast feedback, aligning with best practices."
        },
        {
          "name": "reflection_free_patterns",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excellently implement source-generated JsonSerializerContext, use CreateSlimBuilder (not CreateBuilder), employ explicit DI registration, and avoid reflection-based scanning. Neither uses reflection-based patterns; both demonstrate compile-time alternatives effectively."
        },
        {
          "name": "type_preservation",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A provides comprehensive ILLink.Descriptors.xml with method-level preservation and includes System.Text.Json transitive dependencies, demonstrating deeper understanding. Response B has simpler preservation. Neither uses [DynamicDependency] attributes, but Response A shows more sophisticated preservation strategy with better documentation of what to preserve and why."
        },
        {
          "name": "pinvoke_source_gen",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Neither response provides P/Invoke code examples. Response B mentions in Key Takeaways that 'If you need P/Invoke, use [LibraryImport] instead,' at least acknowledging the best practice. Response A completely omits any mention of P/Invoke considerations."
        },
        {
          "name": "size_and_deployment",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response B explicitly sets StripSymbols and OptimizationPreference=Size in .csproj and provides realistic size estimates (10-15 MB binary). Response A lacks these optimization properties and estimates 50-80 MB, which is high for a minimal AOT app. Both properly use runtime-deps base image, but Response B demonstrates superior understanding of size optimization."
        }
      ]
    },
    {
      "id": "dotnet-native-aot/1/0",
      "entity_id": "dotnet-native-aot",
      "skill_name": "dotnet-native-aot",
      "prompt": "I am converting a .NET library to be AOT-compatible. What MSBuild properties should I set? How do I replace DllImport with LibraryImport for P/Invoke? Show me how to handle a type that the trimmer cannot analyze statically.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 4269846923,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:46:37.941005+00:00",
      "cost": 0.0224359,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.25,
        "baseline_score": 2.4,
        "improvement": 0.85,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "publish_configuration",
          "score_a": 4,
          "score_b": 1,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Response A correctly distinguishes library (IsAotCompatible, IsTrimmable) from application configuration, explicitly stating 'Do not use PublishAot in library projects.' Response B contains a critical error: it includes '<PublishAot>true</PublishAot>' in the main library project configuration example, violating the fundamental distinction between library and application AOT setup. While Response B shows analyzer properties explicitly, this critical misconfiguration is a major flaw."
        },
        {
          "name": "reflection_free_patterns",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Both responses focus heavily on annotation-based approaches ([DynamicDependency], [DynamicallyAccessedMembers], [RequiresUnreferencedCode]) rather than demonstrating compile-time alternatives. Response A shows JsonSerializerContext in its complete example, but still uses reflection-based patterns in main sections. Response B extensively uses Activator.CreateInstance and Assembly.Load patterns without advocating for factory methods or source-generated alternatives. Neither demonstrates how to replace reflection patterns with compile-time DI or factory methods."
        },
        {
          "name": "type_preservation",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A excellently covers ILLink descriptor XML with proper TrimmerRootDescriptor registration and clear decision matrix on when to use attributes vs XML. Response B focuses on attribute-based approaches ([DynamicDependency], [DynamicallyAccessedMembers], [UnconditionalSuppressMessage]) but notably omits the ILLink descriptor XML approach entirely, which the criteria specifies as the recommended solution for preserving entire assemblies."
        },
        {
          "name": "pinvoke_source_gen",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response B provides superior coverage with multiple LibraryImport examples including UTF-8 string marshalling, UnmanagedCallConv for calling conventions, array marshalling with In/Out attributes, and SetLastError handling. Response A covers the basics (DllImport\u2192LibraryImport, static partial, MarshalAs) but with fewer variations and examples. Both correctly avoid DllImport, but Response B demonstrates more real-world scenarios."
        },
        {
          "name": "size_and_deployment",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 1,
          "baseline_score": 2,
          "reasoning": "Response A completely omits size and deployment optimization guidance. Response B shows OptimizationPreference (Speed/Size) and mentions binary size reduction (60-70%), but is missing StripSymbols, InvariantGlobalization, container base image guidance (runtime-deps), and detailed size optimization discussion. Both responses fall short of the criterion's requirements, but Response B provides minimal coverage where Response A provides none."
        }
      ]
    },
    {
      "id": "dotnet-observability/0/0",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Add full OpenTelemetry observability to an ASP.NET Core API: traces for HTTP requests and custom operations, metrics for business KPIs (orders processed, revenue), structured logging with trace correlation, and separate liveness/readiness health check endpoints.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1921378266,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:47:13.503034+00:00",
      "cost": 0.0255075,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.0,
        "baseline_score": 3.0,
        "improvement": 1.0,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "otel_setup",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Response A provides comprehensive setup with multiple exporters (OTLP, Prometheus, Console), clear sampler configuration, and fallback options. Response B is cleaner and modular but lacks explicit sampler configuration and fallback exporters. Both correctly use ConfigureResource, WithTracing, WithMetrics, AspNetCore/HttpClient instrumentation, AddSource, AddMeter, and OTEL_EXPORTER_OTLP_ENDPOINT environment variables."
        },
        {
          "name": "custom_metrics",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A critically fails by using 'new Meter()' directly instead of IMeterFactory from DI, which violates OpenTelemetry best practices. Response B correctly injects IMeterFactory, implements IDisposable for proper cleanup, and provides better metric separation (separate counters for success/cancellation, revenue tracking). Response B also follows superior semantic conventions (e.g., 'revenue.total' vs 'orders.amount')."
        },
        {
          "name": "structured_logging",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses correctly use structured logging templates with {Placeholder} syntax and avoid string interpolation. Neither explicitly demonstrates source-generated LoggerMessage attributes for hot paths. Both rely on OpenTelemetry's automatic Activity.Current correlation for trace context, but neither explicitly shows TraceId/SpanId enrichment in logs."
        },
        {
          "name": "health_checks",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A provides separate /healthz/live and /healthz/ready endpoints with tag filtering and custom response writer, but demonstrates only one dependency (SqlServer). Response B provides /alive and /health endpoints with multiple custom IHealthCheck implementations (Database, PaymentGateway, Startup), better separation semantics, and includes AllowCachingResponses=false for reliability."
        },
        {
          "name": "aspire_awareness",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A shows no awareness of Aspire or runtime instrumentation. Response B includes AddRuntimeInstrumentation() which demonstrates understanding of .NET runtime metrics (GC, thread pool), though neither explicitly acknowledges Aspire ServiceDefaults pattern or warns against duplication in Aspire projects."
        }
      ]
    },
    {
      "id": "dotnet-observability/1/0",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "How do I create custom metrics in .NET using System.Diagnostics.Metrics with IMeterFactory and export them via OpenTelemetry OTLP? Show the counter, histogram, and gauge patterns with proper DI registration.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1008153416,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:47:43.941436+00:00",
      "cost": 0.022261499999999997,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.7,
        "baseline_score": 2.55,
        "improvement": 1.15,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "otel_setup",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A provides basic metrics configuration but lacks ConfigureResource, WithTracing, and AddSource. Response B comprehensively implements all required elements: ConfigureResource with AddService, separate WithTracing and WithMetrics builders, AddSource for ActivitySource, AddMeter with wildcard support, and explicit OTEL_EXPORTER_OTLP_ENDPOINT environment variables throughout."
        },
        {
          "name": "custom_metrics",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both correctly use IMeterFactory and implement Counter, Histogram, and ObservableGauge with semantic naming conventions. Response B provides superior examples with thread-safe Interlocked operations, detailed callback pattern explanation, multi-dimensional metrics examples, and better TagList usage documentation."
        },
        {
          "name": "structured_logging",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A provides minimal structured logging (single {time} example). Response B demonstrates multiple structured logging examples including exception logging and metric correlation. Neither implements LoggerMessage source-generation or TraceId/SpanId enrichment for trace correlation, but Response B shows better practical logging coverage."
        },
        {
          "name": "health_checks",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses completely omit health checks implementation. Neither includes /health/live and /health/ready endpoints, AddHealthChecks with typed checks and tags, or liveness vs. readiness separation. This represents a significant gap in both responses."
        },
        {
          "name": "aspire_awareness",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A mentions Aspire Dashboard in Docker Compose but lacks awareness of ServiceDefaults auto-configuration. Response B demonstrates better OpenTelemetry knowledge by including AddRuntimeInstrumentation and more complete OTEL configuration patterns, though neither explicitly acknowledges Aspire ServiceDefaults or warns against duplication."
        }
      ]
    },
    {
      "id": "dotnet-resilience/0/0",
      "entity_id": "dotnet-resilience",
      "skill_name": "dotnet-resilience",
      "prompt": "Add resilience to an HttpClient that calls an external catalog API. Use the standard resilience pipeline with custom retry counts, circuit breaker thresholds, and timeouts. The configuration should be tunable via appsettings.json.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1828185084,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:48:05.910672+00:00",
      "cost": 0.014001,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.65,
        "baseline_score": 2.95,
        "improvement": 1.7,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "standard_pipeline",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses custom AddResilienceHandler with incorrect pipeline order (Retry \u2192 CircuitBreaker \u2192 Timeout \u2192 RateLimiter), whereas Response B correctly uses AddStandardResilienceHandler with the documented correct order (RateLimiter \u2192 TotalTimeout \u2192 Retry \u2192 CircuitBreaker \u2192 AttemptTimeout)."
        },
        {
          "name": "polly_v8_apis",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A manually builds ResiliencePipelineBuilder with HTTP-specific strategy options, which works but bypasses modern standard patterns. Response B uses AddStandardResilienceHandler which encapsulates Polly v8 correctly through Microsoft's recommended HTTP client abstraction."
        },
        {
          "name": "retry_best_practices",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A implements exponential backoff with jitter and unsafe method disabling, but only calls AddTimeout once without clearly separating total vs. attempt timeout strategies. Response B explicitly configures both TotalRequestTimeout (60s) and AttemptTimeout (10s) with clear documentation showing the correct hierarchy."
        },
        {
          "name": "di_and_configuration",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A properly registers HttpClient with ResilienceHandler and binds configuration, but uses a custom approach. Response B uses the standard AddHttpClient pattern with AddStandardResilienceHandler and .Bind(), which is the recommended modern approach in Microsoft.Extensions.Http.Resilience."
        },
        {
          "name": "telemetry_awareness",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A includes basic logging but does not acknowledge automatic telemetry emission from the pipeline. Response B explicitly mentions that telemetry (metrics and logs) is emitted automatically via DI registration and provides examples of structured logs, though OpenTelemetry integration details could be more explicit."
        }
      ]
    },
    {
      "id": "dotnet-resilience/1/0",
      "entity_id": "dotnet-resilience",
      "skill_name": "dotnet-resilience",
      "prompt": "I need to add retry logic to my EF Core repository for handling transient database failures, and a separate resilience pipeline for an external payment gateway HTTP client. Show both using Polly v8 and Microsoft.Extensions patterns.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1857921971,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:48:31.375435+00:00",
      "cost": 0.017180299999999996,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.9,
        "baseline_score": 2.85,
        "improvement": 2.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "standard_pipeline",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses custom AddResilienceHandler with manual builder configuration, not AddStandardResilienceHandler. Response B correctly implements AddStandardResilienceHandler with the standard pipeline order (total timeout \u2192 retry \u2192 circuit breaker \u2192 attempt timeout) and customizes options (Retry.MaxRetryAttempts, CircuitBreaker.FailureRatio, AttemptTimeout.Timeout) as intended."
        },
        {
          "name": "polly_v8_apis",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses ResiliencePipelineBuilder with strategy options for HTTP only via AddResilienceHandler, but relies on EF Core's built-in retry strategy instead of AddResiliencePipeline for the database layer. Response B properly implements AddResiliencePipeline('db-retry', ...) with RetryStrategyOptions and PredicateBuilder for non-HTTP scenarios, showing correct v8 API usage for both patterns."
        },
        {
          "name": "retry_best_practices",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both use exponential backoff with jitter and target specific status codes (408, 429, 5xx). Response A mentions disabling retries for unsafe methods (commented out). Response B is superior by explicitly showing attempt timeout (5s) < total timeout (60s), handling idempotency keys, and explicitly handling specific database exceptions (DbUpdateConcurrencyException), with a clear pipeline diagram explaining the correct order."
        },
        {
          "name": "di_and_configuration",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A registers via AddHttpClient and AddResilienceHandler with custom extension method, using PaymentGatewayResilienceOptions. Response B uses [FromKeyedServices('db-retry')] for keyed service injection, proper Configuration.GetSection().Bind(options) pattern for standard handler, and cleaner separation between AddResiliencePipeline and AddStandardResilienceHandler."
        },
        {
          "name": "telemetry_awareness",
          "score_a": 1,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Response A shows basic ILogger usage but no acknowledgment of automatic telemetry emission or OnRetry callbacks. Response B explicitly implements OnRetry callback for structured logging of retry attempts using ResiliencePropertyKey context, mentions 'Built-in Polly telemetry', and demonstrates advanced observability patterns."
        }
      ]
    },
    {
      "id": "dotnet-security-owasp/0/0",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Harden an ASP.NET Core Minimal API against the OWASP Top 10. Show me how to add global authorization with fallback policy, rate limiting, security headers (CSP, X-Frame-Options, HSTS), anti-forgery protection, and CORS restrictions for a known frontend origin.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3541034453,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:49:10.895046+00:00",
      "cost": 0.0271239,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.75,
        "baseline_score": 2.75,
        "improvement": 1.0,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "injection_prevention",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A only mentions parameterized EF Core queries in a table without implementation. Response B mentions parameterization and includes a warning section explicitly showing SQL concatenation as wrong with a SQL injection example, demonstrating better security awareness even though neither shows actual FromSqlInterpolated code."
        },
        {
          "name": "access_control",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A correctly implements SetFallbackPolicy and restrictive CORS but lacks resource-based authorization for IDOR prevention. Response B implements all three elements plus includes an explicit ownership validation example in the /api/users/{userId} endpoint that checks userId against currentUserId, and warns against CORS anti-patterns."
        },
        {
          "name": "security_configuration",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A provides comprehensive security headers (CSP, X-Frame-Options, HSTS) but misses Kestrel hardening. Response B includes all headers plus ConfigureKestrel with AddServerHeader=false to remove identity, MaxRequestBodySize limits (10 MB), MaxRequestHeadersTotalSize (32 KB), and RequestHeadersTimeout, providing better defense-in-depth against resource exhaustion."
        },
        {
          "name": "rate_limiting_and_antiforgery",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A implements all required elements (AddRateLimiter, RequireRateLimiting, AddAntiforgery, 429 status, proper middleware order). Response B adds SlidingWindowLimiter with SegmentsPerWindow for better distribution, explicit UseAntiforgery() middleware call, a /antiforgery/token endpoint for SPA clients, and JavaScript integration examples, making it more production-ready for modern frontends."
        },
        {
          "name": "dependency_and_data_integrity",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A mentions NuGetAudit in a table without implementation details. Response B shows the dotnet command, crucially warns against plaintext secrets in config with an example, demonstrates dotnet user-secrets usage, and provides separate appsettings.Production.json, showing stronger awareness of secret management best practices."
        }
      ]
    },
    {
      "id": "dotnet-security-owasp/1/0",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Review this .NET code for security vulnerabilities: it uses FromSqlRaw with string concatenation, stores connection strings in appsettings.json, returns detailed exception info to clients, and accepts user-provided URLs for HttpClient calls without validation.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 525205319,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:49:50.109737+00:00",
      "cost": 0.028216,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.1,
        "baseline_score": 1.85,
        "improvement": 1.25,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "injection_prevention",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A shows parameterized fixes using SqlParameter and FromSql with interpolation, but doesn't explicitly reference FromSqlInterpolated (the recommended EF Core method). Response B explicitly names FromSqlInterpolated and also shows LINQ as the safest alternative. Neither addresses HTML encoding or allowlist validation for command inputs. Response B's approach is more precise with API naming."
        },
        {
          "name": "access_control",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses completely omit required access control mechanisms including SetFallbackPolicy for global authorization, AuthorizationHandler for resource-based authorization, CORS origin validation, and justification of [AllowAnonymous] endpoints. This is a critical gap in both submissions."
        },
        {
          "name": "security_configuration",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A gates UseDeveloperExceptionPage properly but lacks explicit security headers. Response B includes comprehensive security headers (X-Content-Type-Options: nosniff, X-Frame-Options: DENY, Content-Security-Policy, Referrer-Policy), gates exception pages, shows HSTS configuration, and returns generic errors. Response B addresses most criterion requirements; both omit AddServerHeader=false and Kestrel body size limits."
        },
        {
          "name": "rate_limiting_and_antiforgery",
          "score_a": 1,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 1,
          "reasoning": "Response A does not implement rate limiting or anti-forgery middleware. Response B explicitly configures AddRateLimiter with FixedWindowLimiter, sets PermitLimit/Window, and shows app.UseRateLimiter(). However, Response B omits per-endpoint RequireRateLimiting, anti-forgery implementation, and explicit 429 status code documentation. Neither addresses anti-forgery."
        },
        {
          "name": "dependency_and_data_integrity",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A correctly moves secrets from appsettings.json and recommends Azure Key Vault and User Secrets but omits NuGet audit configuration. Response B includes all above plus explicitly configures NuGetAudit with NuGetAuditMode=all in csproj. Both lack package source mapping discussion and serialization library recommendations (System.Text.Json, MessagePack). Response B's NuGet audit addition is critical for transitive vulnerability scanning."
        }
      ]
    },
    {
      "id": "dotnet-testing-strategy/0/0",
      "entity_id": "dotnet-testing-strategy",
      "skill_name": "dotnet-testing-strategy",
      "prompt": "I have a new ASP.NET Core API with an OrderService that calls a database repository, an external payment gateway, and sends email notifications. Design a testing strategy: which parts get unit tests, integration tests, and E2E tests? Show concrete test examples with appropriate test doubles.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2764826092,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:50:18.616417+00:00",
      "cost": 0.016845199999999998,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.35,
        "baseline_score": 3.3,
        "improvement": 1.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "test_type_decision",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses correctly apply the testing pyramid with proper distribution (unit/integration/E2E). Response A provides clear visual pyramid and concrete examples. Response B adds a decision matrix and explicitly warns against the anti-pattern of mocking repositories in unit tests while skipping integration tests, showing slightly more nuanced reasoning."
        },
        {
          "name": "test_doubles_selection",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A uses Moq with extensive Verify() calls for mock interaction verification, and creates TestEmailService as a fake. Response B uses NSubstitute (more concise syntax), demonstrates clearer distinction between stubs and mocks, and explicitly warns: 'You never verify that LINQ translates to valid SQL' when mocking DbContext\u2014directly addressing the criterion requirement."
        },
        {
          "name": "test_organization",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A shows test classes with naming like ProcessOrderAsync_WithValidRequest_ReturnsSuccess but doesn't display full project structure. Response B explicitly shows the recommended project layout (MyOrderApp.Application.UnitTests, MyOrderApp.Infrastructure.IntegrationTests, etc.), clearly demonstrates Method_Scenario_ExpectedBehavior naming, and maps one test class per production class."
        },
        {
          "name": "anti_pattern_avoidance",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A tests business logic well but includes extensive mock verification (Verify() calls multiple times per test). Response B has a dedicated anti-patterns section showing what NOT to do, explaining why excessive mock.Received() breaks on refactoring, and recommending assertions on observable outcomes instead of call sequences\u2014directly educating the reader on this criterion."
        },
        {
          "name": "determinism",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Both use Testcontainers and WebApplicationFactory to avoid external network dependencies. Response A includes DateTime.UtcNow in TestEmailService (a test double), which is a minor anti-pattern. Response B avoids DateTime in test code and properly isolates test dependencies. Neither explicitly uses TimeProvider/.NET 8+ FakeTimeProvider, but Response B is cleaner in this regard."
        }
      ]
    },
    {
      "id": "dotnet-testing-strategy/1/0",
      "entity_id": "dotnet-testing-strategy",
      "skill_name": "dotnet-testing-strategy",
      "prompt": "My team over-uses mocks -- every test has 5+ mock setups and we spend more time maintaining mocks than writing features. How should we decide between mocks, fakes, and stubs? Refactor this approach for an order processing service.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3735696862,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:51:11.200151+00:00",
      "cost": 0.0318687,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.55,
        "baseline_score": 3.35,
        "improvement": 0.2,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "test_type_decision",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Both responses focus exclusively on unit test doubles without addressing the criterion's core requirement: categorizing test types (unit for pure logic with no infrastructure, integration for database/HTTP with real infrastructure, E2E for critical full-stack flows). Neither discusses Testcontainers, real database integration tests, or the testing pyramid structure."
        },
        {
          "name": "test_doubles_selection",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excel at distinguishing stubs (canned data), fakes (working in-memory implementations), and mocks (interaction verification). Response A shows sophisticated spy pattern and call counting; Response B provides a clear table and Moq examples. Both strongly advocate for fakes in domain scenarios over mocks, meeting the criterion's preferences perfectly."
        },
        {
          "name": "test_organization",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A explicitly shows folder structure mirroring src/ (`tests/MyApp.Domain.UnitTests/Orders/Fakes/`) with proper suffixes, implements sophisticated fixture patterns, and demonstrates clear naming. Response B follows traditional one-test-class-per-production-class and uses Method_Scenario_ExpectedBehavior naming correctly, but lacks folder organization guidance and uses older MSTest style ([TestClass]/[TestMethod])."
        },
        {
          "name": "anti_pattern_avoidance",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both directly address excessive mock setup as an anti-pattern and advocate testing behavior/observable outcomes rather than implementation. Response A asserts on state changes (e.g., inventory quantity), and Response B uses clear bad/good comparison examples. Neither mentions TimeProvider for time-dependent logic, which is a notable gap in both."
        },
        {
          "name": "determinism",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses present deterministic tests without external dependencies, system clock reliance, or randomness. However, neither explicitly mentions FakeTimeProvider for time control, Testcontainers for infrastructure isolation, or WebApplicationFactory strategies. Tests appear independent with fresh fixtures but lack explicit determinism control mechanisms."
        }
      ]
    },
    {
      "id": "dotnet-xunit/0/0",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit tests for a .NET service that processes customer orders, including tests for successful order creation, validation failures, and async operations. The service has methods CreateAsync, CancelAsync, and GetByIdAsync.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1258595224,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:52:31.471108+00:00",
      "cost": 0.0883195,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.55,
        "baseline_score": 2.5,
        "improvement": 2.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "xunit_v3_conventions",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A explicitly demonstrates xUnit v3 patterns including IAsyncLifetime with ValueTask return types, TheoryData<T> for strongly-typed test data, and Assert.Multiple for grouped assertions. Response B uses older patterns like IDisposable fixtures and lacks explicit v3 convention demonstrations."
        },
        {
          "name": "fixture_and_lifecycle",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A correctly implements IAsyncLifetime with async setup/teardown using ValueTask, demonstrates IClassFixture, ICollectionFixture with [CollectionDefinition] for sequential tests, and proper async disposal patterns. Response B uses synchronous IDisposable which doesn't follow modern async initialization patterns and lacks collection-level fixtures."
        },
        {
          "name": "assertion_quality",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A uses Assert.Multiple (v3 feature), Assert.Equal for value comparisons, Assert.ThrowsAsync, and domain-specific custom assertions with OrderAssertions helpers. Response B relies heavily on Assert.True/Assert.False for value checks (discouraged) and lacks Assert.Multiple usage, though it does verify logging calls appropriately."
        },
        {
          "name": "test_structure",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses follow clear Arrange/Act/Assert patterns with excellent method naming conventions (Method_Scenario_ExpectedBehavior), proper async Task return types, logical test organization with regions, and one concept per test method. Both are well-structured and readable."
        },
        {
          "name": "parallelism_awareness",
          "score_a": 5,
          "score_b": 1,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A comprehensively addresses parallelism with [CollectionDefinition] for sequential tests, DisableParallelization examples, and xunit.runner.json configuration for assembly-level parallel control. Response B completely omits any parallelism considerations or configuration guidance."
        }
      ]
    },
    {
      "id": "dotnet-xunit/1/0",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "How do I share an expensive database fixture across multiple xUnit test classes while keeping tests isolated? Show the fixture, collection definition, and test class setup.",
      "run_index": 0,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1926362517,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:53:28.118146+00:00",
      "cost": 0.050844,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.85,
        "baseline_score": 2.9,
        "improvement": 1.95,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "xunit_v3_conventions",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A correctly implements IAsyncLifetime with ValueTask return types (explicitly documented: 'xUnit v3: IAsyncLifetime uses ValueTask (not Task)'). Response B incorrectly uses Task return types for IAsyncLifetime.InitializeAsync() and DisposeAsync(), which violates xUnit v3 conventions where these methods must return ValueTask for proper async support."
        },
        {
          "name": "fixture_and_lifecycle",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A demonstrates the standard ICollectionFixture pattern cleanly with separate fixture and collection definition. Response B uses the correct interfaces but has test classes implementing IAsyncLifetime themselves for transaction management, which is unconventional and adds unnecessary complexity beyond the standard fixture pattern."
        },
        {
          "name": "assertion_quality",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses specific xUnit assertions (Assert.Equal, Assert.NotNull, Assert.Null) appropriately for value comparisons. Response B includes Assert.True(userId > 0), which is less specific than Assert.Positive() or Assert.NotEqual(0, userId); it also correctly uses Assert.ThrowsAsync but has one assertion quality issue."
        },
        {
          "name": "test_structure",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses follow Arrange/Act/Assert pattern clearly with descriptive Method_Scenario_ExpectedBehavior naming conventions and one logical concept per test. Response A provides more comprehensive examples with multiple test classes; Response B is equally well-structured but more concise."
        },
        {
          "name": "parallelism_awareness",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A provides comprehensive parallelism explanation including xunit.runner.json configuration file with detailed settings (parallelizeTestCollections: false) and a strategy comparison table. Response B mentions that tests in the same collection run sequentially but omits assembly-level configuration demonstration and provides less detailed guidance."
        }
      ]
    },
    {
      "id": "dotnet-blazor-patterns/0/1",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Set up a Blazor Web App with InteractiveAuto render mode. The home page should be Static SSR for SEO, the dashboard should use streaming rendering for slow data, and a real-time counter component should be interactive. Show proper render mode boundaries and PersistentComponentState usage.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 561945378,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:54:17.189196+00:00",
      "cost": 0.031962,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.95,
        "baseline_score": 2.5,
        "improvement": 1.45,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "render_mode_selection",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A uses [ExcludeFromInteractiveRouting] and tries to apply @rendermode on Routes component, which is incorrect syntax. Response B correctly uses @rendermode @(new StaticRenderMode()) for explicit Static SSR and InteractiveAutoRenderMode(prerender: true) with proper syntax throughout."
        },
        {
          "name": "streaming_and_prerendering",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both implement [StreamRendering] and PersistentComponentState correctly. Response B is superior because it implements IAsyncDisposable pattern with proper subscription management (storing _subscription and disposing in DisposeAsync), which is best practice for resource cleanup."
        },
        {
          "name": "project_structure",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A does not address the proper Blazor Web App structure with separate Client and Server projects. Response B explicitly shows BlazorAutoApp/ and BlazorAutoApp.Client/ structure, correctly references Client assembly in Program.cs with typeof(BlazorAutoApp.Client._Imports).Assembly, and explains the purpose of each project."
        },
        {
          "name": "routing_and_navigation",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Both responses show basic @page routing but neither demonstrates advanced concepts like route constraints, [SupplyParameterFromQuery], or enhanced navigation implementation. Response B mentions enhanced navigation in the key concepts table but doesn't show actual usage, so both score equally low."
        },
        {
          "name": "aot_safe_patterns",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Neither response explicitly configures source-generated JsonSerializerContext or ConfigureHttpJsonOptions with TypeInfoResolverChain. Both rely on framework methods (PersistAsJson, TryTakeFromJson) that are implicitly AOT-safe but don't demonstrate explicit AOT configuration patterns required for WASM optimization."
        }
      ]
    },
    {
      "id": "dotnet-blazor-patterns/1/1",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "I need to choose the right Blazor hosting model for a Line-of-Business app with 200 concurrent users, offline requirements for some features, and SEO for public-facing pages. Compare the options and show the project setup.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 4262252449,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:55:49.761596+00:00",
      "cost": 0.06561385,
      "judge_attempts": 2,
      "scores": {
        "enhanced_score": 3.4,
        "baseline_score": 1.95,
        "improvement": 1.45,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "render_mode_selection",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A correctly differentiates all four modes, applies InteractiveAuto globally, and properly overrides with Static SSR (no @rendermode) for public pages and InteractiveWebAssembly for client-only components. Response B recommends the right approach but uses [ExcludeFromInteractiveRouting] incorrectly\u2014this attribute controls navigation interception, not render modes; static pages need no @rendermode, not this attribute."
        },
        {
          "name": "streaming_and_prerendering",
          "score_a": 2,
          "score_b": 1,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A mentions prerendering for SEO in a dedicated section with project file configuration, but neither response demonstrates [StreamRendering] attribute or PersistentComponentState to avoid double data fetching and flicker during prerender-to-interactive transitions. Both load async data in OnInitializedAsync without streaming. Response A is slightly better for at least acknowledging prerendering explicitly."
        },
        {
          "name": "project_structure",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A clearly shows WASM components (OfflineDashboard) in .Client/Pages, server components in Components/Pages, and explicitly maps additional assemblies via AddAdditionalAssemblies(). Response B shows a structure diagram but lacks detail on what belongs in .Client/Pages and doesn't explicitly demonstrate the component boundary or assembly mapping needed for Blazor Web App."
        },
        {
          "name": "routing_and_navigation",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Both responses use basic @page directives but neither demonstrates route constraints ({Id:int}), [SupplyParameterFromQuery] for query parameters, NavigationManager for programmatic navigation, or enhanced navigation with data-enhance-nav attributes. Routing examples are minimal and lack these modern patterns."
        },
        {
          "name": "aot_safe_patterns",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses use JsonSerializer without source-generated JsonSerializerContext or ConfigureHttpJsonOptions registration. Neither avoids reflection-based patterns or addresses AOT/trimming safety for Blazor Web App WASM deployment. This is a critical gap in both responses for production .NET 8+ applications."
        }
      ]
    },
    {
      "id": "dotnet-containers/0/1",
      "entity_id": "dotnet-containers",
      "skill_name": "dotnet-containers",
      "prompt": "Create a production-ready Dockerfile for a multi-project .NET solution with an API project and a shared library. It should use multi-stage builds, optimized layer caching, rootless execution, and a health check endpoint.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 755599077,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:56:48.375282+00:00",
      "cost": 0.038607100000000005,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.2,
        "baseline_score": 3.2,
        "improvement": 1.0,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "multi_stage_build",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses implement excellent multi-stage builds with SDK for compilation and runtime-only base images. Response A uses 2 stages (build/runtime); Response B uses 4 stages (builder/build/publish/runtime) with slightly more sophistication. Both copy project files before source code and use --no-restore on publish."
        },
        {
          "name": "rootless_and_security",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses chiseled images which provide inherent rootless execution with UID 1654 'app' user and explicitly minimizes attack surface (no shell, no package manager). Response B attempts `USER $APP_UID` on Alpine, but this variable is not guaranteed to be defined on Alpine aspnet images, creating a portability risk. Response A better follows the criterion's emphasis on distroless/chiseled images."
        },
        {
          "name": "base_image_selection",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A selects aspnet:10.0-noble-chiseled (excellent for web apps, modern .NET, distroless). Response B selects aspnet:8.0-alpine (older .NET 8.0, uses musl libc without verifying compatibility as required by criterion). Both avoid hardcoded patch versions. Chiseled is superior to Alpine for production security."
        },
        {
          "name": "health_and_diagnostics",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 1,
          "baseline_score": 2,
          "reasoning": "Response A uses chiseled images but provides a HEALTHCHECK with `wget`, which contradicts its own claim that chiseled has no package manager. Per criterion, chiseled should rely on orchestrator-level probes, not HEALTHCHECK directives. Response B provides HEALTHCHECK with undefined `dotnet-health-check` command (should use curl on Alpine), but the docker-compose section demonstrates proper understanding with curl-based health checks."
        },
        {
          "name": "optimization",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses provide comprehensive .dockerignore files excluding .git, bin/obj, build artifacts, and IDE files. Neither addresses DOTNET_SYSTEM_GLOBALIZATION_INVARIANT, container memory auto-detection, or ContainerBaseImage/ContainerImageTag MSBuild properties mentioned in the criterion. Documentation quality is similar, with Response B providing docker-compose and more CLI examples."
        }
      ]
    },
    {
      "id": "dotnet-containers/1/1",
      "entity_id": "dotnet-containers",
      "skill_name": "dotnet-containers",
      "prompt": "What is the difference between using a multi-stage Dockerfile and dotnet publish /t:PublishContainer for containerizing a .NET app? When should I use each approach? Show me how to use the SDK container publish with chiseled base images.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2221810902,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:57:14.141423+00:00",
      "cost": 0.0168588,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.9,
        "baseline_score": 3.85,
        "improvement": 1.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "multi_stage_build",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A shows the multi-stage pattern correctly with proper --no-restore usage. Response B explicitly explains layer caching strategy with comments about why project files go first ('cached until project files change') and source code later ('changes frequently'), plus shows multi-project configuration, making the optimization reasoning crystal clear."
        },
        {
          "name": "rootless_and_security",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses properly address non-root user via chiseled images. Response A clearly states chiseled images run as non-root app user. Response B adds the specific UID 1654 and explains orchestrator-level probes for chiseled images without shell. Both meet requirements thoroughly."
        },
        {
          "name": "base_image_selection",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A shows multiple chiseled variants with size comparisons but doesn't clearly distinguish aspnet vs runtime vs runtime-deps for different workload types. Response B provides a structured table with explicit use cases for each variant and includes practical code examples for when to use chiseled-extra (culture formatting, timezone handling)."
        },
        {
          "name": "health_and_diagnostics",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A shows only a basic /health endpoint without addressing chiseled image limitations or HEALTHCHECK directives. Response B provides comprehensive health check implementation with /health/live and /health/ready endpoints, tag-based filtering, explicitly acknowledges that chiseled images lack shell/curl, and recommends orchestrator-level probes as a solution."
        },
        {
          "name": "optimization",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A mentions PublishTrimmed and PublishReadyToRun but omits .dockerignore entirely and doesn't discuss DOTNET_SYSTEM_GLOBALIZATION_INVARIANT. Response B includes a complete, well-commented .dockerignore with proper exclusion patterns and explains the build context optimization rationale, though neither explicitly covers DOTNET_SYSTEM_GLOBALIZATION_INVARIANT."
        }
      ]
    },
    {
      "id": "dotnet-csharp-async-patterns/0/1",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Write an async service that loads a dashboard by fetching orders, user profile, and statistics in parallel, with a 30-second timeout and proper cancellation support. Include error handling for partial failures.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2887362910,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:57:50.120543+00:00",
      "cost": 0.023703799999999997,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.45,
        "baseline_score": 4.25,
        "improvement": 0.2,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "async_all_the_way",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses async/await consistently throughout with proper ConfigureAwait(false). Response B is mostly correct but defines a custom ILogger<T> interface instead of relying on Microsoft.Extensions.Logging standard, and includes example code with incomplete async patterns."
        },
        {
          "name": "cancellation_propagation",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Both properly create linked CancellationTokenSource and propagate tokens. Response B excels with clear when-clause distinctions between timeout-triggered and externally-triggered cancellation (when (timeoutCts.Token.IsCancellationRequested) vs when (cancellationToken.IsCancellationRequested)), providing better observability."
        },
        {
          "name": "parallel_patterns",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Response A uses Task.WhenAll with wrapped tasks, correctly executing all operations in parallel. Response B creates parallel tasks and uses Task.WhenAll but then redundantly awaits individual tasks again after completion, showing a less efficient pattern despite correctness."
        },
        {
          "name": "configureawait_and_context",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A consistently uses ConfigureAwait(false) in library code throughout. Response B uses it correctly in the service but includes example/console code that could better demonstrate ConfigureAwait usage, and the custom logger implementation doesn't follow standard library practices."
        },
        {
          "name": "streaming_and_disposal",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both correctly use using statements for CancellationTokenSource disposal. Neither requires IAsyncEnumerable or BackgroundService patterns. Response B includes extra infrastructure (mock services) not directly contributing to core streaming/disposal concepts."
        }
      ]
    },
    {
      "id": "dotnet-csharp-async-patterns/1/1",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "I have a .NET service that sometimes deadlocks. It calls .Result on async methods and uses async void for event handlers. Show me how to fix these patterns and explain why they are dangerous.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3344108992,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T01:58:35.005679+00:00",
      "cost": 0.0317993,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.45,
        "baseline_score": 1.6,
        "improvement": 1.85,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "async_all_the_way",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A shows correct async patterns but then presents blocking alternatives (GetAwaiter().GetResult(), Task.Run().GetAwaiter().GetResult()) as fallbacks, which violates the criterion's 'never blocks' principle. Response B consistently avoids blocking patterns and shows pure async/await throughout, though neither mentions ValueTask for optimization."
        },
        {
          "name": "cancellation_propagation",
          "score_a": 1,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A completely omits CancellationToken parameters from service methods (GetUserByIdAsync has no ct parameter). Response B comprehensively demonstrates CancellationToken as last parameter, token forwarding to all downstream calls, ThrowIfCancellationRequested checks in loops, and proper OperationCanceledException handling throughout."
        },
        {
          "name": "parallel_patterns",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response addresses Task.WhenAll for concurrent operations, Parallel.ForEachAsync for bounded parallelism, or safe .Result usage after task completion. Both completely miss this important criterion despite its 0.2 weight."
        },
        {
          "name": "configureawait_and_context",
          "score_a": 1,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Response A mentions no ConfigureAwait patterns, library vs application code distinctions, or BackgroundService. Response B demonstrates BackgroundService for background work with proper scope disposal, explicit fire-and-forget error handling guidance, and correct ASP.NET Core patterns, though doesn't explicitly name ConfigureAwait(false)."
        },
        {
          "name": "streaming_and_disposal",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A lacks async enumeration, await using, or BackgroundService patterns entirely. Response B shows BackgroundService with scope disposal via using statements and demonstrates understanding of long-running work patterns, though misses IAsyncEnumerable and explicit await using examples."
        }
      ]
    },
    {
      "id": "dotnet-csharp-coding-standards/0/1",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Review and refactor this C# service class to follow modern .NET coding standards. Fix naming, access modifiers, null handling, and file organization: class orderService { readonly IOrderRepository repo; string get_customer_name(int id) { var c = repo.GetCustomer(id); if (c == null) return null; return c.firstName + \" \" + c.lastName; } }",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3183485154,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T01:59:26.000783+00:00",
      "cost": 0.041139,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.9,
        "baseline_score": 4.05,
        "improvement": 0.85,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "naming_conventions",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses correctly apply PascalCase for types/methods, _camelCase for private fields, camelCase for parameters/locals. Response A includes async method naming (GetCustomerNameAsync). Both use I-prefix for interfaces and descriptive identifiers throughout."
        },
        {
          "name": "code_style",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses file-scoped namespace, explicit access modifiers, and modern pattern matching with 'is not null' consistently. Response B also uses file-scoped namespace and explicit access modifiers but uses 'is null ? null :' which is less idiomatic than 'is not null'. Both use string interpolation and var appropriately."
        },
        {
          "name": "type_design",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A explicitly seals the class with 'public sealed class OrderService', signaling it's not designed for inheritance and enabling performance optimizations. Response B omits the 'sealed' keyword, which is a design oversight. Response B has good separation of concerns with FormatCustomerName helper method, but the missing sealed modifier is a significant omission."
        },
        {
          "name": "defensive_patterns",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A includes GetCustomerNameAsync with CancellationToken parameter (with default value) and properly forwards the token downstream, which is essential for modern async patterns. Response B lacks any async variant entirely. Both use null-handling operators, but Response A's comprehensive async support is crucial for modern .NET standards."
        },
        {
          "name": "documentation_and_enforcement",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response A provides EditorConfig rules for style enforcement. Response B provides both XML documentation with exception tags and Directory.Build.props configuration for Nullable and LangVersion settings, which is more comprehensive for enforcing build-time checks. Response B's documentation is slightly more complete with exception documentation."
        }
      ]
    },
    {
      "id": "dotnet-csharp-coding-standards/1/1",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Write a well-structured C# interface and implementation for a payment processing service with proper naming conventions, CancellationToken support, XML documentation, and sealed class design.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1462545452,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:01:36.674457+00:00",
      "cost": 0.15398099999999998,
      "judge_attempts": 2,
      "scores": {
        "enhanced_score": 4.9,
        "baseline_score": 3.85,
        "improvement": 1.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "naming_conventions",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A perfectly follows modern .NET conventions with file-scoped namespaces, I-prefix interfaces, _camelCase private fields, and proper Boolean prefixes. Response B uses traditional block namespaces and old-style naming patterns, missing modern C# 10+ conventions."
        },
        {
          "name": "code_style",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A consistently uses modern patterns: file-scoped namespaces, `is not null`/`is null` pattern matching, string interpolation, and expression-bodied members. Response B uses traditional block namespaces and old-style `== null` checks instead of pattern matching, indicating older C# conventions."
        },
        {
          "name": "type_design",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excel at type design with sealed classes, composition over inheritance, and interface segregation. Response A uses sealed records for immutable data types. Response B uses sealed classes with init-only properties and includes sophisticated custom exception hierarchy. Both are excellent implementations."
        },
        {
          "name": "defensive_patterns",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A properly uses CancellationToken defaults, modern null pattern matching, and ConfigureAwait(false). Response B includes more sophisticated timeout handling with linked tokens and distinction between timeout/cancellation, but uses older `== null` checks instead of `is null` pattern matching, which is a style deficit despite functional correctness."
        },
        {
          "name": "documentation_and_enforcement",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A has comprehensive, accurate XML documentation with proper summary, param, returns, and exception tags on all public APIs. Response B has XML documentation but contains errors (return value descriptions on constructors marked as 'Initializes'). Neither mentions EditorConfig or Directory.Build.props enforcement, but A's documentation is more accurate."
        }
      ]
    },
    {
      "id": "dotnet-efcore-patterns/0/1",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Set up EF Core for an ASP.NET Core API with a background order processing service. The API handles web requests and the background service processes orders in batches. Show the DbContext registration, proper lifetime management, and read-only query optimization.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2432708183,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:02:13.225041+00:00",
      "cost": 0.024266899999999998,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 5.0,
        "baseline_score": 2.7,
        "improvement": 2.3,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "dbcontext_lifetime",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A registers DbContext three times (AddDbContext + AddDbContextPool + AddDbContextFactory), which is confusing and problematic\u2014you should choose one pooling strategy, not all. Response B correctly registers only AddDbContext for web requests and AddDbContextFactory for background services, avoiding conflicts."
        },
        {
          "name": "query_optimization",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses AsNoTracking extensively with clear comments. Response B goes further by explicitly demonstrating AsSplitQuery() when including multiple collections (Items) to prevent Cartesian explosion, which is a key optimization pattern Response A doesn't show."
        },
        {
          "name": "interceptor_patterns",
          "score_a": 1,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A completely omits SaveChangesInterceptor and manually sets CreatedDate in business logic instead. Response B fully implements AuditTimestampInterceptor with SavingChangesAsync override, proper registration via AddInterceptors, and automatic timestamp management\u2014a critical pattern entirely missing from Response A."
        },
        {
          "name": "migration_practices",
          "score_a": 1,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A provides no migration guidance. Response B includes comprehensive migration section with dotnet ef commands, --project and --startup-project flags, idempotent scripts, migration bundle creation, seed data via HasData, and explicit warning against Database.Migrate() at startup\u2014all essential production practices."
        },
        {
          "name": "cancellation_and_resiliency",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both propagate CancellationToken to async EF methods and configure EnableRetryOnFailure. Response B additionally implements CreateExecutionStrategy() for proper transient failure handling and also passes cancellation token to CreateDbContextAsync, which Response A lacks."
        }
      ]
    },
    {
      "id": "dotnet-efcore-patterns/1/1",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "My EF Core query loading Orders with Items and Payments is slow due to Cartesian explosion. How do I fix this? Also show me how to add automatic audit timestamps via an interceptor.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2315500269,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:02:52.681125+00:00",
      "cost": 0.027330499999999997,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.15,
        "baseline_score": 2.75,
        "improvement": 0.4,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "dbcontext_lifetime",
          "score_a": 3,
          "score_b": 2,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A correctly uses AddDbContext with DI-based interceptor registration via AddInterceptors, though it lacks discussion of IDbContextFactory alternatives. Response B has anti-pattern registration by hardcoding interceptor creation in OnConfiguring rather than via DI, violating the explicit criterion requirement."
        },
        {
          "name": "query_optimization",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response A provides excellent AsSplitQuery explanation with global configuration and tradeoff analysis but omits AsNoTracking discussion. Response B comprehensively covers three solutions (AsSplitQuery, ThenInclude, manual queries) with explicit AsNoTracking usage in the manual approach, better addressing diverse scenarios."
        },
        {
          "name": "interceptor_patterns",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A correctly implements SaveChangesInterceptor with proper DI registration using AddSingleton + AddInterceptors on DbContext options, matching the explicit criterion requirement. Response B implements more features (soft delete, user tracking) but critically registers the interceptor in OnConfiguring instead of via DI, which is an anti-pattern that violates the stated requirement."
        },
        {
          "name": "migration_practices",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 1,
          "baseline_score": 2,
          "reasoning": "Response A does not address migrations at all. Response B shows HasDefaultValueSql configuration which relates to migrations, but neither discusses migration bundles, idempotent scripts, Database.Migrate() avoidance, or explicit migration generation practices."
        },
        {
          "name": "cancellation_and_resiliency",
          "score_a": 3,
          "score_b": 2,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A shows CancellationToken propagation in query examples (ToListAsync(ct)) and includes it in interceptor signatures. Response B omits CancellationToken from query examples entirely and lacks retry policy discussion. Neither addresses EnableRetryOnFailure or CreateExecutionStrategy."
        }
      ]
    },
    {
      "id": "dotnet-minimal-apis/0/1",
      "entity_id": "dotnet-minimal-apis",
      "skill_name": "dotnet-minimal-apis",
      "prompt": "Build a Minimal API for a product catalog with CRUD endpoints. The API should use route groups, TypedResults for response types, and an endpoint filter for request validation. Include proper OpenAPI metadata.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1209993465,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:03:43.001235+00:00",
      "cost": 0.0332404,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.85,
        "baseline_score": 4.7,
        "improvement": 0.15,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "typed_results_usage",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excellently utilize TypedResults with comprehensive union types (Results<Ok<T>, NotFound>, Results<Created<T>, ValidationProblem>, etc.) for type-safe endpoint responses and automatic OpenAPI schema generation."
        },
        {
          "name": "route_group_organization",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both demonstrate excellent route group organization. Response A uses individual extension methods per endpoint (MapGetAllProducts, MapCreateProduct, etc.), while Response B maps all endpoints in a single extension method. Both approaches are scalable and apply group-level metadata appropriately."
        },
        {
          "name": "endpoint_filters",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A implements ProductValidationFilter with type-specific validation checking for CreateProductRequest and UpdateProductRequest, which is effective but less reusable. Response B's ValidationFilter iterates through all arguments generically and validates each one, making it more flexible and production-ready with sealed modifier."
        },
        {
          "name": "parameter_binding",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response A demonstrates comprehensive binding patterns including [AsParameters] for complex query objects (SearchProductsQuery), [FromQuery] on nested properties, and route constraints. Response B uses simpler [FromQuery] direct binding without demonstrating the [AsParameters] pattern for complex query objects."
        },
        {
          "name": "openapi_integration",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response B provides complete OpenAPI coverage with all mentioned features: WithName, WithSummary, WithDescription, WithTags, Produces, ProducesProblem, AddOpenApi, MapOpenApi, and ConfigureHttpJsonOptions. Response A omits WithTags on endpoints and lacks ConfigureHttpJsonOptions configuration specific to Minimal APIs."
        }
      ]
    },
    {
      "id": "dotnet-minimal-apis/1/1",
      "entity_id": "dotnet-minimal-apis",
      "skill_name": "dotnet-minimal-apis",
      "prompt": "I have a growing Minimal API with 30+ endpoints all in Program.cs. How should I reorganize this for maintainability? Show me the extension method pattern with route groups.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 898111369,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:04:02.538940+00:00",
      "cost": 0.0126184,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.45,
        "baseline_score": 2.7,
        "improvement": 1.75,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "typed_results_usage",
          "score_a": 5,
          "score_b": 1,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A consistently uses TypedResults static factory methods (TypedResults.Ok, TypedResults.NotFound, TypedResults.Created) and declares union return types (Results<Ok<T>, NotFound>) for proper OpenAPI schema generation. Response B exclusively uses Results interface factory methods with generic IResult return types, completely ignoring TypedResults and type-safe union types."
        },
        {
          "name": "route_group_organization",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excellently demonstrate extension method patterns with route groups. Response A shows nested versioning (v1/v2) and central ApiEndpoints router; Response B shows nested authorization groups (public/admin) and nested report sections. Both keep Program.cs clean and scale well to 30+ endpoints."
        },
        {
          "name": "endpoint_filters",
          "score_a": 3,
          "score_b": 1,
          "enhanced_score": 3,
          "baseline_score": 1,
          "reasoning": "Response A includes an AddEndpointFilter<RequestLoggingFilter> example applied to route groups, though it lacks full implementation details. Response B does not mention or demonstrate endpoint filters at all, only using RequireAuthorization() which is authorization middleware, not a filter."
        },
        {
          "name": "parameter_binding",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A uses typed route constraints ({id:int}), proper DI injection, and demonstrates binding with Accepts<T>(). Response B shows basic binding with DI injection but uses untyped route parameters ({id}) and lacks examples of binding attributes like [FromQuery], [FromHeader], or [AsParameters]."
        },
        {
          "name": "openapi_integration",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses comprehensively implement OpenAPI integration with WithName, WithSummary, WithTags, WithOpenApi, and Produces/ProducesProblem. Response A additionally shows ConfigureHttpJsonOptions for JSON serialization and MapOpenApi registration. Response B provides equally thorough OpenAPI documentation with good status code examples."
        }
      ]
    },
    {
      "id": "dotnet-native-aot/0/1",
      "entity_id": "dotnet-native-aot",
      "skill_name": "dotnet-native-aot",
      "prompt": "Publish an ASP.NET Core Minimal API as a Native AOT binary. Show the project configuration, source-generated JSON serialization, CreateSlimBuilder usage, ILLink descriptors for a type that uses reflection, and a Dockerfile using runtime-deps base image.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2016961247,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:04:40.385407+00:00",
      "cost": 0.02699,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.4,
        "baseline_score": 2.95,
        "improvement": 1.45,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "publish_configuration",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A includes PublishAot and IsAotCompatible but omits EnableAotAnalyzer and EnableTrimAnalyzer properties, and doesn't demonstrate the dotnet build command for fast feedback. Response B includes all required analyzer properties, shows the build command for development-time diagnostics, and adds size optimization properties (StripSymbols, OptimizationPreference)."
        },
        {
          "name": "reflection_free_patterns",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A implements CreateSlimBuilder and source-generated JSON correctly, but the ReflectionService example directly uses Type.GetType and GetProperties without modern [DynamicDependency] attributes. Response B demonstrates the proper modern pattern with [DynamicDependency] attribute explicitly marking what reflection is needed, which is the recommended AOT approach."
        },
        {
          "name": "type_preservation",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses ILLink descriptors correctly but preserves types broadly without targeted attributes and doesn't demonstrate [DynamicDependency]. Response B combines targeted [DynamicDependency] attributes in code with minimal ILLink descriptors, following the best practice of using attributes for specific types and XML for assembly-level concerns."
        },
        {
          "name": "pinvoke_source_gen",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response demonstrates P/Invoke usage, [LibraryImport] attributes, [MarshalAs] attributes, or static partial methods. While not explicitly required in the prompt, both responses equally omit this AOT consideration."
        },
        {
          "name": "size_and_deployment",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses runtime-deps-alpine and mentions size ranges (15-30MB) but lacks StripSymbols, OptimizationPreference=Size, and sets InvariantGlobalization=false unnecessarily. Response B configures all size optimizations (StripSymbols, OptimizationPreference=Size, InvariantGlobalization=true), uses the minimal runtime-deps-chiseled variant, and provides realistic binary size examples (8.2M binary, 40MB container)."
        }
      ]
    },
    {
      "id": "dotnet-native-aot/1/1",
      "entity_id": "dotnet-native-aot",
      "skill_name": "dotnet-native-aot",
      "prompt": "I am converting a .NET library to be AOT-compatible. What MSBuild properties should I set? How do I replace DllImport with LibraryImport for P/Invoke? Show me how to handle a type that the trimmer cannot analyze statically.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3810144640,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:05:16.009332+00:00",
      "cost": 0.022776899999999996,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.5,
        "baseline_score": 3.15,
        "improvement": 0.35,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "publish_configuration",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A mentions PublishAot without clearly distinguishing app vs. library contexts and omits EnableAotAnalyzer/EnableTrimAnalyzer properties and the fast dotnet build feedback loop. Response B explicitly warns against using PublishAot in libraries, shows EnableAotAnalyzer and EnableTrimAnalyzer with dotnet build commands for development-time diagnostics, and demonstrates the recommended fast feedback approach."
        },
        {
          "name": "reflection_free_patterns",
          "score_a": 3,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 3,
          "reasoning": "Response A provides a strong explicit DI registration example (AddAotCompatibleServices vs AddServicesViaReflection with RequiresUnreferencedCode marking), clearly showing the contrast between AOT-compatible and reflection-based patterns. Response B touches on patterns but lacks the explicit contrast. Neither addresses JsonSerializerContext or CreateSlimBuilder. Response A better demonstrates when to avoid reflection by showing the bad pattern explicitly."
        },
        {
          "name": "type_preservation",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A covers DynamicDependency and RequiresUnreferencedCode attributes but omits the modern ILLink descriptor XML approach with TrimmerRootDescriptor. Response B comprehensively shows both DynamicDependency attributes for targeted preservation and ILLink descriptor XML for broader preservation, with clear guidance on when to use each approach."
        },
        {
          "name": "pinvoke_source_gen",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response A provides comprehensive P/Invoke examples with multiple marshalling scenarios (UTF-8, UTF-16, calling conventions, GC suppression, arrays) and a detailed migration table. Response B covers the essential LibraryImport migration with MarshalAs attributes and basic examples but is less comprehensive in demonstrating advanced marshalling patterns."
        },
        {
          "name": "size_and_deployment",
          "score_a": 2,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 2,
          "reasoning": "Response A mentions OptimizationPreference property with Speed/Size options but omits StripSymbols, InvariantGlobalization, and container deployment patterns. Response B does not address any size optimization properties, container deployment strategies, or binary size considerations, falling short on deployment guidance."
        }
      ]
    },
    {
      "id": "dotnet-observability/0/1",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Add full OpenTelemetry observability to an ASP.NET Core API: traces for HTTP requests and custom operations, metrics for business KPIs (orders processed, revenue), structured logging with trace correlation, and separate liveness/readiness health check endpoints.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1755392641,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:06:09.994496+00:00",
      "cost": 0.0394958,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.5,
        "baseline_score": 2.0,
        "improvement": 1.5,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "otel_setup",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A has basic OpenTelemetry configuration with AddOpenTelemetry, ConfigureResource, WithTracing, and WithMetrics, but creates Meter directly via 'new Meter()' instead of IMeterFactory. Response B provides better organization with TelemetryService pattern, includes additional enrichment options in instrumentation, and properly delegates Meter creation to IMeterFactory in services."
        },
        {
          "name": "custom_metrics",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A violates best practices by creating Meter instances with 'new Meter()' in Program.cs and storing them in DI as singletons, which isn't the proper pattern. Response B correctly uses IMeterFactory in service constructors to create meters, demonstrating the proper dependency injection pattern with multiple services (OrderService, PaymentService) showing the pattern."
        },
        {
          "name": "structured_logging",
          "score_a": 1,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 1,
          "reasoning": "Response A contains critical syntax errors in the logging configuration: semicolons mid-chain after property assignments (`.IncludeFormattedMessage = true;`) that would prevent compilation. Response B has correct syntax, proper OpenTelemetry logging setup, and demonstrates scope enrichment with BeginScope. Neither implements source-generated LoggerMessage, but Response B's code is actually compilable and functional."
        },
        {
          "name": "health_checks",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A separates endpoints correctly but ReadinessHealthCheck only simulates startup with Task.Delay(5000) rather than checking actual dependencies, violating the requirement for database/service health verification. Response B demonstrates the correct pattern with commented examples for database and external API checks, showing understanding of what readiness should actually verify, plus a simple liveness check."
        },
        {
          "name": "aspire_awareness",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response acknowledges .NET Aspire ServiceDefaults or mentions that Aspire automatically configures OpenTelemetry. Both provide explicit configuration appropriate for standalone APIs, but completely miss the Aspire awareness requirement stated in the criterion."
        }
      ]
    },
    {
      "id": "dotnet-observability/1/1",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "How do I create custom metrics in .NET using System.Diagnostics.Metrics with IMeterFactory and export them via OpenTelemetry OTLP? Show the counter, histogram, and gauge patterns with proper DI registration.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 4253113027,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:06:52.685674+00:00",
      "cost": 0.0324029,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.0,
        "baseline_score": 2.7,
        "improvement": 0.3,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "otel_setup",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A provides ConfigureResource and WithMetrics but critically lacks WithTracing, AddHttpClientInstrumentation, and AddSource for custom ActivitySources. Response B includes all required components: ConfigureResource, both WithTracing and WithMetrics, AspNetCore and HttpClient instrumentation in both trace and metric pipelines, AddSource, proper AddMeter registration, and environment-based OTLP configuration."
        },
        {
          "name": "custom_metrics",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 5,
          "reasoning": "Response A comprehensively demonstrates Counter, Histogram, Gauge, ObservableCounter, and ObservableGauge patterns with detailed documentation, recording methods, and semantic naming conventions. Response B covers Counter, Histogram, and ObservableGauge but omits regular Gauge and ObservableCounter patterns, providing less complete metric type coverage."
        },
        {
          "name": "structured_logging",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A provides minimal logging examples without demonstrating {Placeholder} syntax. Response B shows proper structured logging with {Placeholder} syntax in multiple places (MeterName, OrderId, DurationMs), though neither response covers source-generated LoggerMessage or TraceId/SpanId correlation enrichment."
        },
        {
          "name": "health_checks",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response addresses health checks at all. Both lack separation of liveness vs. readiness endpoints, tag-based filtering, or any health check implementation with AddHealthChecks."
        },
        {
          "name": "aspire_awareness",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Both responses include AddRuntimeInstrumentation but neither acknowledges .NET Aspire's automatic OpenTelemetry configuration or addresses the need to avoid duplication in Aspire projects. Both are equally incomplete on this criterion."
        }
      ]
    },
    {
      "id": "dotnet-resilience/0/1",
      "entity_id": "dotnet-resilience",
      "skill_name": "dotnet-resilience",
      "prompt": "Add resilience to an HttpClient that calls an external catalog API. Use the standard resilience pipeline with custom retry counts, circuit breaker thresholds, and timeouts. The configuration should be tunable via appsettings.json.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1554963920,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:08:09.684899+00:00",
      "cost": 0.0489771,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.15,
        "baseline_score": 3.0,
        "improvement": 0.15,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "standard_pipeline",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A's Option A correctly uses AddStandardResilienceHandler with proper customization, but Option B diverges by using AddResilienceHandler with manual strategy building, which violates the criterion to customize rather than build from scratch. Response B cleanly applies AddStandardResilienceHandler with clear configuration and includes a helpful pipeline diagram showing correct order (rate limiter \u2192 total timeout \u2192 retry \u2192 circuit breaker \u2192 attempt timeout)."
        },
        {
          "name": "polly_v8_apis",
          "score_a": 2,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 2,
          "reasoning": "Response A's Option B demonstrates ResiliencePipelineBuilder usage which approaches Polly v8 APIs, though it lacks PredicateBuilder for ShouldHandle configuration. Response B shows no custom Polly v8 APIs beyond the standard handler; it remains focused entirely on AddStandardResilienceHandler without exploring ResiliencePipeline or strategy option classes for non-HTTP scenarios."
        },
        {
          "name": "retry_best_practices",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A explicitly includes DisableForUnsafeHttpMethods() to prevent retrying unsafe operations, plus exponential backoff with UseJitter=true and correct timeout ordering (attempt 10s < total 30s). Response B includes exponential backoff with jitter and proper timeout ordering but omits any mention of disabling retries for POST/PUT/DELETE operations, which is a critical safety practice."
        },
        {
          "name": "di_and_configuration",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 4,
          "reasoning": "Response A correctly uses AddHttpClient<ICatalogService, CatalogService>() which automatically registers and injects the configured HttpClient without additional setup. Response B's code is incomplete: it registers a named client \"catalog-api\" but then AddScoped<CatalogApiClient>() without showing how the named client is actually injected\u2014would require IHttpClientFactory or [FromKeyedServices] pattern not shown. The code as written would inject a default HttpClient, not the configured one."
        },
        {
          "name": "telemetry_awareness",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A shows only basic logging configuration without mentioning resilience metrics or OpenTelemetry. Response B includes a dedicated \"Built-in Observability\" section explicitly listing Polly metrics (polly.strategy.attempt.duration, pipeline.duration, attempt.count), structured logging configuration, and mentions OpenTelemetry automatic integration\u2014comprehensive production monitoring awareness."
        }
      ]
    },
    {
      "id": "dotnet-resilience/1/1",
      "entity_id": "dotnet-resilience",
      "skill_name": "dotnet-resilience",
      "prompt": "I need to add retry logic to my EF Core repository for handling transient database failures, and a separate resilience pipeline for an external payment gateway HTTP client. Show both using Polly v8 and Microsoft.Extensions patterns.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3417768030,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:08:42.741762+00:00",
      "cost": 0.020574000000000002,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.4,
        "baseline_score": 3.0,
        "improvement": 1.4,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "standard_pipeline",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A correctly uses AddStandardResilienceHandler as the primary approach for HTTP clients with complete option customization (retry, circuit breaker, timeout). Response B builds a custom resilience pipeline and relegates AddStandardResilienceHandler to a commented alternative, missing the standard pipeline as the primary recommendation."
        },
        {
          "name": "polly_v8_apis",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A consistently uses Polly v8 ResiliencePipeline with RetryStrategyOptions and PredicateBuilder for both EF Core and HTTP scenarios. Response B avoids Polly v8 entirely for EF Core (using EF Core's native ExecutionStrategy instead) and builds custom handlers for HTTP rather than using the standard pattern."
        },
        {
          "name": "retry_best_practices",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A implements exponential backoff with jitter, explicit idempotency guards (reads vs writes), and correct timeout hierarchy (10s attempt < 60s total) for both scenarios. Response B shows good exponential backoff with jitter for HTTP but uses basic EF Core retry without backoff configuration, and doesn't explicitly discuss idempotency constraints."
        },
        {
          "name": "di_and_configuration",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses register resilience via DI (AddResiliencePipeline/AddStandardResilienceHandler/AddHttpClient) and include appsettings.json. However, neither demonstrates the Configuration.GetSection().Bind() pattern to bind configuration options to policy objects, instead hardcoding options directly in code."
        },
        {
          "name": "telemetry_awareness",
          "score_a": 2,
          "score_b": 1,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A mentions structured logging via OnRetry callbacks and acknowledges metrics emission. Response B includes comprehensive application-level logging but provides no recognition of automatic resilience telemetry (polly.strategy.attempt.duration, pipeline.duration) or OpenTelemetry integration patterns."
        }
      ]
    },
    {
      "id": "dotnet-security-owasp/0/1",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Harden an ASP.NET Core Minimal API against the OWASP Top 10. Show me how to add global authorization with fallback policy, rate limiting, security headers (CSP, X-Frame-Options, HSTS), anti-forgery protection, and CORS restrictions for a known frontend origin.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 528033980,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:09:25.661887+00:00",
      "cost": 0.028005199999999994,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.65,
        "baseline_score": 2.55,
        "improvement": 1.1,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "injection_prevention",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A mentions injection prevention conceptually (CSP + input validation) in summary but provides no concrete code examples demonstrating parameterized queries or input encoding. Response B shows practical EF Core LINQ parameterization (Where clauses) and explicit input validation (string.IsNullOrWhiteSpace checks), though both lack HtmlEncoder usage and allowlist validation."
        },
        {
          "name": "access_control",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A uses DefaultPolicy instead of SetFallbackPolicy (critical requirement) and provides no IDOR prevention\u2014no ownership checks despite claiming security. Response B correctly implements SetFallbackPolicy and demonstrates IDOR prevention through explicit ownership validation (OwnerId == userId checks on sensitive endpoints)."
        },
        {
          "name": "security_configuration",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A delivers excellent security headers via NetEscapades library but omits Kestrel request size/header limits. Response B provides comprehensive headers, explicitly removes server identity (AddServerHeader=false), and configures Kestrel constraints (10MB body, 32KB headers, 30s timeout), plus proper IsDevelopment exception handling gating."
        },
        {
          "name": "rate_limiting_and_antiforgery",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A defines sophisticated multi-policy rate limiting (FixedWindow, SlidingWindow, TokenBucket) but places UseRateLimiter() after UseAuthorization(), allowing expensive auth checks before rate limit protection. Response B positions rate limiting earlier (after CORS, before auth) and applies anti-forgery to state-changing endpoints, though with simpler policies."
        },
        {
          "name": "dependency_and_data_integrity",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Both responses lack NuGetAuditMode=all configuration, nuget.config package source mapping, and explicit secrets management strategies. Response A stores sensitive credentials (Authority, Audience) in appsettings.json, violating secrets best practices. Response B minimizes configuration sensitivity but neither addresses dependency confusion prevention or audit tooling."
        }
      ]
    },
    {
      "id": "dotnet-security-owasp/1/1",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Review this .NET code for security vulnerabilities: it uses FromSqlRaw with string concatenation, stores connection strings in appsettings.json, returns detailed exception info to clients, and accepts user-provided URLs for HttpClient calls without validation.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3230542284,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:10:28.997346+00:00",
      "cost": 0.0446382,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 2.35,
        "baseline_score": 2.45,
        "improvement": -0.1,
        "winner": "baseline"
      },
      "per_criterion_breakdown": [
        {
          "name": "injection_prevention",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses clearly explain SQL injection via FromSqlRaw and provide correct fixes using FromSqlInterpolated or FromSql. Response B is slightly more comprehensive with three options (FormattableString, DbParameters with allowlist, stored procedures) and explicitly shows column name whitelist validation, while Response A is more direct. Neither addresses HtmlEncoder or command-input allowlists beyond SQL context."
        },
        {
          "name": "access_control",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses completely omit access control implementation. Neither mentions SetFallbackPolicy for global authorization, resource-based authorization handlers (AuthorizationHandler), CORS restrictions, or justification of [AllowAnonymous] endpoints. This is a critical gap for both."
        },
        {
          "name": "security_configuration",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A includes AddServerHeader=false, X-Content-Type-Options, X-Frame-Options, Referrer-Policy, HSTS, and proper UseDeveloperExceptionPage gating (6/8 requirements). Response B includes X-Content-Type-Options, X-Frame-Options, HSTS, proper gating, and X-XSS-Protection but omits the required AddServerHeader=false removal and Referrer-Policy (4/8 requirements). Neither adds Content-Security-Policy or Kestrel request body size limits."
        },
        {
          "name": "rate_limiting_and_antiforgery",
          "score_a": 1,
          "score_b": 3,
          "enhanced_score": 1,
          "baseline_score": 3,
          "reasoning": "Response A completely lacks rate limiting and anti-forgery implementation. Response B provides comprehensive AddRateLimiter configuration with FixedWindowRateLimiter and automatic 429 status codes, but fails to demonstrate RequireRateLimiting per-endpoint attributes and does not show UseRateLimiter middleware placement after UseRouting. Neither addresses anti-forgery tokens."
        },
        {
          "name": "dependency_and_data_integrity",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses address secrets management by avoiding appsettings.json and using user-secrets/Key Vault, but both completely miss NuGet audit configuration (NuGetAuditMode=all), package source mapping in nuget.config, BinaryFormatter discussion, and System.Text.Json/MessagePack serialization methods. Both score 20% coverage of this criterion's requirements."
        }
      ]
    },
    {
      "id": "dotnet-testing-strategy/0/1",
      "entity_id": "dotnet-testing-strategy",
      "skill_name": "dotnet-testing-strategy",
      "prompt": "I have a new ASP.NET Core API with an OrderService that calls a database repository, an external payment gateway, and sends email notifications. Design a testing strategy: which parts get unit tests, integration tests, and E2E tests? Show concrete test examples with appropriate test doubles.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3375002058,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:11:04.126228+00:00",
      "cost": 0.0214163,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 5.0,
        "baseline_score": 3.95,
        "improvement": 1.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "test_type_decision",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses in-memory database for integration tests, which doesn't verify actual SQL generation as mentioned in the criteria. Response B uses TestContainers with real PostgreSQL and WireMock for HTTP contract testing, directly addressing the SQL generation verification requirement and matching the evaluation criteria's guidance on proper infrastructure choices."
        },
        {
          "name": "test_doubles_selection",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A relies heavily on in-memory database and Moq with verbose Setup/Verify patterns, without explicit HTTP mocking for payment gateway integration. Response B clearly distinguishes between test doubles: real PostgreSQL database (TestContainers), WireMock for HTTP mocking, and NSubstitute for behavior verification\u2014directly avoiding the pitfall of mocking DbContext and properly testing HTTP contracts."
        },
        {
          "name": "test_organization",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses have excellent organization mirroring src/ structure with appropriate suffixes (UnitTests/IntegrationTests/E2ETests vs FunctionalTests). Both use clear naming conventions (Method_Scenario_ExpectedBehavior style) and consistent Arrange-Act-Assert patterns with proper section separation. Response B uses IAsyncLifetime for lifecycle management, which is slightly more idiomatic for resource cleanup."
        },
        {
          "name": "anti_pattern_avoidance",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A has some verbose mock setup with Moq's Setup/It.IsAny patterns and verifies implementation details (Times.Exactly(3)). Response B uses cleaner NSubstitute syntax (Received/DidNotReceive), tests behavior without excessive mock setup, and shows better separation of concerns with clear decision matrix indicating what should NOT be tested in certain layers."
        },
        {
          "name": "determinism",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses in-memory database and WebApplicationFactory which are deterministic but less realistic than actual database testing. Response B uses TestContainers with IAsyncLifetime for proper initialization/cleanup per test class, ensuring fresh infrastructure for each test, and shows explicit lifecycle management patterns that guarantee test isolation and determinism."
        }
      ]
    },
    {
      "id": "dotnet-testing-strategy/1/1",
      "entity_id": "dotnet-testing-strategy",
      "skill_name": "dotnet-testing-strategy",
      "prompt": "My team over-uses mocks -- every test has 5+ mock setups and we spend more time maintaining mocks than writing features. How should we decide between mocks, fakes, and stubs? Refactor this approach for an order processing service.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1558749361,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:12:16.845288+00:00",
      "cost": 0.04531950000000001,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.7,
        "baseline_score": 3.8,
        "improvement": -0.1,
        "winner": "baseline"
      },
      "per_criterion_breakdown": [
        {
          "name": "test_type_decision",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A correctly applies unit tests with fakes but provides no integration test guidance or testing pyramid discussion. Response B explicitly separates unit tests from integration tests (with real infrastructure like RealPaymentGateway and RealInventoryDatabase), better aligning with the criterion's requirement for unit/integration/E2E distinctions."
        },
        {
          "name": "test_doubles_selection",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A excels with a clear yes/no decision tree, all four types (stub, fake, mock, spy), maintenance cost table, and explicit guidance on when spies are preferred over mocks. Response B provides a decision matrix and clear distinctions but lacks spy examples and is less comprehensive on mock usage patterns."
        },
        {
          "name": "test_organization",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Both use proper Method_Scenario_ExpectedBehavior naming and Arrange-Act-Assert patterns. However, Response B better organizes tests by separating OrderProcessingServiceTests (unit) from OrderProcessingIntegrationTests (integration) into distinct test classes, demonstrating superior structural separation. Neither shows folder structure mirroring src/tests."
        },
        {
          "name": "anti_pattern_avoidance",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A directly targets the stated problem with a stark before/after example (7 mocks setup vs. using fakes), explicitly names the anti-pattern ('test smell'), and shows the transition from `.Received()` calls to state-based assertions. Response B addresses the anti-pattern adequately but less pointedly, without the stark before/after comparison."
        },
        {
          "name": "determinism",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Neither response provides guidance on TimeProvider, FakeTimeProvider, system clock dependencies, or Testcontainers/WebApplicationFactory for infrastructure isolation. Both test examples appear deterministic but lack explicit discussion of these critical concerns."
        }
      ]
    },
    {
      "id": "dotnet-xunit/0/1",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit tests for a .NET service that processes customer orders, including tests for successful order creation, validation failures, and async operations. The service has methods CreateAsync, CancelAsync, and GetByIdAsync.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2055823040,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:13:37.649511+00:00",
      "cost": 0.09104324999999999,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 5.0,
        "baseline_score": 2.95,
        "improvement": 2.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "xunit_v3_conventions",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses basic [Fact] and [Theory] with [InlineData] but lacks xUnit v3 features like IAsyncLifetime, ValueTask, TheoryData<T>, and Assert.Multiple. Response B comprehensively demonstrates xUnit v3 conventions with ValueTask return types in IAsyncLifetime, proper TheoryData<CreateOrderRequest, decimal> usage, and Assert.Multiple for grouped assertions."
        },
        {
          "name": "fixture_and_lifecycle",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A relies on constructor-based mock injection without using IClassFixture<T> or IAsyncLifetime, missing xUnit fixture patterns entirely. Response B properly implements IClassFixture<OrderServiceFixture>, IAsyncLifetime with ValueTask methods, plus [CollectionDefinition] and [Collection] attributes for managing test execution order and parallelization."
        },
        {
          "name": "assertion_quality",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses appropriate assertions (Assert.Equal, Assert.ThrowsAsync, Assert.Contains, Assert.NotNull) and mock verification correctly. Response B adds Assert.Multiple for grouped assertions (v3 feature), includes custom OrderAssertions domain class, uses precision parameters for decimal comparisons, and maintains clean assertion patterns without messages (removed in v3)."
        },
        {
          "name": "test_structure",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses follow Arrange/Act/Assert pattern clearly with section separators and descriptive method names following Method_Scenario_ExpectedBehavior convention. Both use async Task correctly and keep one logical concept per test. Response B adds integration test scenarios but both are equally well-structured."
        },
        {
          "name": "parallelism_awareness",
          "score_a": 1,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A completely ignores parallelism concerns with no mention of collection definitions or xunit.runner.json. Response B explicitly demonstrates collection-based sequential test organization with [CollectionDefinition], DisableParallelization=true, [Collection] attributes, and mentions xunit.runner.json for assembly-level configuration with clear explanations of when/why sequential execution is needed."
        }
      ]
    },
    {
      "id": "dotnet-xunit/1/1",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "How do I share an expensive database fixture across multiple xUnit test classes while keeping tests isolated? Show the fixture, collection definition, and test class setup.",
      "run_index": 1,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 357015475,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:14:38.710133+00:00",
      "cost": 0.053980249999999994,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.85,
        "baseline_score": 3.2,
        "improvement": 1.65,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "xunit_v3_conventions",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A correctly uses ValueTask for IAsyncLifetime (with explicit comment about xUnit v3), uses [Fact] and [Theory] with [InlineData], and properly implements async patterns. Response B uses Task instead of ValueTask for IAsyncLifetime, which violates xUnit v3 conventions and is a critical incompatibility."
        },
        {
          "name": "fixture_and_lifecycle",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A provides a comprehensive implementation with ICollectionFixture, [CollectionDefinition], [Collection] attributes, and IAsyncLifetime with proper unique database creation per collection. Response B uses a transaction-based isolation approach which works but is less robust than per-collection database isolation and has potential edge cases with shared context state."
        },
        {
          "name": "assertion_quality",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses Assert.Equal, Assert.NotNull, Assert.NotEmpty, and Assert.All appropriately without boolean comparisons, with multiple examples. Response B demonstrates good assertions (Assert.NotNull, Assert.Equal) but provides fewer examples and less variety in assertion patterns."
        },
        {
          "name": "test_structure",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A follows Arrange/Act/Assert pattern clearly, uses descriptive Method_Scenario_ExpectedBehavior naming, tests one logical concept per test, and provides three separate test classes with multiple test examples. Response B follows AAA pattern with clear comments and descriptive names but provides fewer examples and less variety."
        },
        {
          "name": "parallelism_awareness",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A explains that collections run in parallel while tests within a collection run sequentially, demonstrates unique per-collection database naming for conflict avoidance, and includes a comprehensive behavior table. Response B mentions transaction rollback for isolation but completely lacks explanation of xUnit's parallel execution model, collection isolation strategy, and does not mention DisableParallelization or xunit.runner.json configuration."
        }
      ]
    },
    {
      "id": "dotnet-blazor-patterns/0/2",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "Set up a Blazor Web App with InteractiveAuto render mode. The home page should be Static SSR for SEO, the dashboard should use streaming rendering for slow data, and a real-time counter component should be interactive. Show proper render mode boundaries and PersistentComponentState usage.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 635904343,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:18:06.219200+00:00",
      "cost": 0.16803020000000002,
      "judge_attempts": 3,
      "scores": {
        "enhanced_score": 2.55,
        "baseline_score": 2.1,
        "improvement": 0.45,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "render_mode_selection",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 2,
          "baseline_score": 3,
          "reasoning": "Response A sets InteractiveAuto on Routes globally, causing Home.razor to inherit InteractiveAuto instead of being Static SSR as required; the inheritance model means Home would not be SEO-optimized. Response B correctly uses [ExcludeFromInteractiveRouting] on Home.razor and explicit @rendermode on each page, but Program.cs incompletely registers only InteractiveServerRenderMode without AddInteractiveWebAssemblyRenderMode required for InteractiveAuto to function."
        },
        {
          "name": "streaming_and_prerendering",
          "score_a": 4,
          "score_b": 1,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Response A correctly implements [StreamRendering] on both Dashboard and Counter pages with proper PersistentComponentState usage throughout (ApplicationState.RegisterOnPersisting, TryTakeFromJson, PersistAsJson patterns). Response B critically omits the [StreamRendering] attribute on Dashboard despite showing streaming data logic, rendering streaming ineffective; Dashboard also lacks any PersistentComponentState implementation, and the [PersistentState] attribute on CurrentCount property is non-standard/non-functional API."
        },
        {
          "name": "project_structure",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Response A references Client project in Program.cs (AdditionalAssemblies) but doesn't show the actual .Client folder structure; Response B shows a complete server-side folder layout but completely omits the .Client project structure required for Blazor Web App with WebAssembly support. Both are incomplete presentations of the required split architecture."
        },
        {
          "name": "routing_and_navigation",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses demonstrate basic @page routing directives and navigation links in layouts. Neither implements query string parameters with [SupplyParameterFromQuery], route constraints ({Id:int}), NavigationManager for programmatic navigation, or enhanced navigation with data-enhance-nav attribute control; coverage is functionally equivalent and basic."
        },
        {
          "name": "aot_safe_patterns",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response demonstrates source-generated JsonSerializerContext, ConfigureHttpJsonOptions with TypeInfoResolverChain, or avoidance of reflection-based patterns that fail under AOT trimming. Both rely on standard reflection-based serialization that would fail in WASM AOT scenarios; equally insufficient AOT safety."
        }
      ]
    },
    {
      "id": "dotnet-blazor-patterns/1/2",
      "entity_id": "dotnet-blazor-patterns",
      "skill_name": "dotnet-blazor-patterns",
      "prompt": "I need to choose the right Blazor hosting model for a Line-of-Business app with 200 concurrent users, offline requirements for some features, and SEO for public-facing pages. Compare the options and show the project setup.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1976738697,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:18:36.764249+00:00",
      "cost": 0.0203671,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.25,
        "baseline_score": 2.6,
        "improvement": 1.65,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "render_mode_selection",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses @attribute [ExcludeFromInteractiveRouting] to mark static pages, which is incorrect\u2014this attribute controls enhanced navigation, not render modes. It also defaults to InteractiveServer in App.razor, which is poor for 200 concurrent users. Response B correctly omits render mode for static pages, uses InteractiveAuto as default, and explicitly marks components with @rendermode at appropriate boundaries, perfectly matching the stated requirements."
        },
        {
          "name": "streaming_and_prerendering",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Neither response demonstrates [StreamRendering] or PersistentComponentState patterns. Response A mentions prerendering conceptually but shows no implementation. Response B includes .PreRender() in Program.cs and prerender: true in render modes, showing more concrete integration, though both lack detailed handling of the prerender-to-interactive transition and stream rendering for slow data sources."
        },
        {
          "name": "project_structure",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both show correct separation of server Components and Client pages. Response A provides basic structure. Response B is more comprehensive: shows wwwroot organization, Services folder separation (LobDataService, OfflineDataService), demonstrates .AddAdditionalAssemblies() in Program.cs for correct WASM interactivity registration, and shows OfflineWorkbench embedded as an island component with proper render mode boundary."
        },
        {
          "name": "routing_and_navigation",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A shows @page directives but provides minimal routing examples and lacks practical navigation patterns. Response B demonstrates @page routing, [Authorize] attribute on protected pages, NavigationManager usage with Nav.NavigateTo() for programmatic navigation, and discusses enhanced navigation. However, neither shows [SupplyParameterFromQuery] or route constraints like {Id:int}."
        },
        {
          "name": "aot_safe_patterns",
          "score_a": 1,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Critical difference: Response A uses JsonSerializer.Serialize/Deserialize directly without source generation, which fails AOT compilation on WASM. Response B correctly implements source-generated JsonSerializerContext with [JsonSerializable] attributes and [JsonSourceGenerationOptions], though it doesn't show ConfigureHttpJsonOptions integration in Program.cs to complete the AOT pattern."
        }
      ]
    },
    {
      "id": "dotnet-containers/0/2",
      "entity_id": "dotnet-containers",
      "skill_name": "dotnet-containers",
      "prompt": "Create a production-ready Dockerfile for a multi-project .NET solution with an API project and a shared library. It should use multi-stage builds, optimized layer caching, rootless execution, and a health check endpoint.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 938427357,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:19:36.337177+00:00",
      "cost": 0.0370042,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.65,
        "baseline_score": 2.6,
        "improvement": 2.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "multi_stage_build",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses an unnecessarily complex 4-stage build (restore, build, publish, runtime) with problematic .nuget cache copying and --no-dependencies flag that may break shared library compilation. Response B uses a clean, efficient 2-stage approach with project files copied first, restore, then source code, followed by runtime\u2014the optimal pattern for layer caching."
        },
        {
          "name": "rootless_and_security",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A attempts to install curl and create a user via apt-get/groupadd in a chiseled image, which will fail (chiseled images have no package manager or user management tools). Response B correctly leverages the pre-configured 'app' user (UID 1654) already present in chiseled images, though it lacks an explicit USER directive for clarity."
        },
        {
          "name": "base_image_selection",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A selects chiseled correctly but demonstrates misunderstanding of its constraints (attempts apt-get install). Response B selects chiseled-extra and explicitly explains when it's needed for globalization/timezone support, correctly avoiding hardcoding patch versions (uses 10.0, not 10.0.x), and provides clear guidance on image selection trade-offs."
        },
        {
          "name": "health_and_diagnostics",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A's health check relies on curl installed via apt-get in a chiseled image (will fail) and lacks separation between liveness and readiness probes. Response B correctly maps /health/live and /health/ready with tag-based filtering, acknowledges curl is unavailable in chiseled, provides Kubernetes httpGet probe examples, and includes custom response writers."
        },
        {
          "name": "optimization",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A provides .dockerignore but lacks deeper optimization discussion. Response B includes comprehensive .dockerignore, discusses layer caching strategy with --no-restore, provides Kubernetes resource limits, includes multi-tool examples (docker-compose, registry push), and explains image size reductions, though neither explicitly mentions ContainerBaseImage MSBuild properties."
        }
      ]
    },
    {
      "id": "dotnet-containers/1/2",
      "entity_id": "dotnet-containers",
      "skill_name": "dotnet-containers",
      "prompt": "What is the difference between using a multi-stage Dockerfile and dotnet publish /t:PublishContainer for containerizing a .NET app? When should I use each approach? Show me how to use the SDK container publish with chiseled base images.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3810970191,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:20:03.081840+00:00",
      "cost": 0.0196041,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.15,
        "baseline_score": 3.45,
        "improvement": 0.7,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "multi_stage_build",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A shows proper SDK\u2192aspnet multi-stage separation and project file ordering, but omits the --no-restore flag on dotnet publish. Response B includes all required elements: SDK build stage, aspnet runtime stage, proper layer caching with --no-restore optimization, and better multi-project restore strategy."
        },
        {
          "name": "rootless_and_security",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses effectively cover non-root user requirements and chiseled image security benefits. Response A provides more detailed explanation of chiseled variants and InvariantGlobalization settings. Response B adds port constraint details (ports >= 1024 for non-root) and includes .dockerignore security practices. Roughly equivalent overall."
        },
        {
          "name": "base_image_selection",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 5,
          "reasoning": "Response A comprehensively covers aspnet for web, runtime-deps for AOT (jammy-chiseled-aot), chiseled-extra for globalization, alpine variants, and includes a detailed decision matrix. Response B only addresses aspnet and chiseled variants, missing runtime/runtime-deps for worker services and AOT scenarios, and doesn't mention Alpine as an option."
        },
        {
          "name": "health_and_diagnostics",
          "score_a": 1,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A provides no health check discussion whatsoever. Response B includes a complete Program.cs implementation with /health/live and /health/ready endpoints, tag-based filtering, practical test commands, and correctly notes that chiseled images don't support HEALTHCHECK directives (relying on orchestrator-level probes)."
        },
        {
          "name": "optimization",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A demonstrates advanced optimization properties (PublishTrimmed, PublishReadyToRun, DebugType=none, InvariantGlobalization) and MSBuild configuration. Response B includes .dockerignore best practice and port constraint optimization but lacks coverage of PublishTrimmed and memory limit considerations. Neither mentions memory auto-detection."
        }
      ]
    },
    {
      "id": "dotnet-csharp-async-patterns/0/2",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "Write an async service that loads a dashboard by fetching orders, user profile, and statistics in parallel, with a 30-second timeout and proper cancellation support. Include error handling for partial failures.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1701257624,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:20:32.816704+00:00",
      "cost": 0.020817499999999996,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.6,
        "baseline_score": 3.1,
        "improvement": 1.5,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "async_all_the_way",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A violates async best practices by using `.Result` directly in `HandlePartialFailures` without clear safety guarantees. Response B uses `.Result` only after `Task.WhenAll` where it's guaranteed safe, and consistently applies async/await patterns throughout."
        },
        {
          "name": "cancellation_propagation",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A properly creates linked tokens and forwards cancellation, but distinguishes timeout vs user cancellation with complex when-clause conditions. Response B implements the same pattern more cleanly and consistently propagates tokens to all downstream calls."
        },
        {
          "name": "parallel_patterns",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses `Task.WhenAll` correctly but the `HandlePartialFailures` error handling using `.Result` without awaiting is less clean. Response B provides two well-designed parallel patterns: strict all-or-nothing and graceful partial-failure, both implementing safe result access after `WhenAll`."
        },
        {
          "name": "configureawait_and_context",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A omits `ConfigureAwait(false)` entirely in library code, a significant oversight for async best practices. Response B consistently applies `ConfigureAwait(false)` in library methods and appropriately omits it in ASP.NET Core controller code."
        },
        {
          "name": "streaming_and_disposal",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Both use proper `using` statements for `CancellationTokenSource` disposal. Response B demonstrates slightly better resource management patterns and would handle disposal in more complex scenarios more robustly."
        }
      ]
    },
    {
      "id": "dotnet-csharp-async-patterns/1/2",
      "entity_id": "dotnet-csharp-async-patterns",
      "skill_name": "dotnet-csharp-async-patterns",
      "prompt": "I have a .NET service that sometimes deadlocks. It calls .Result on async methods and uses async void for event handlers. Show me how to fix these patterns and explain why they are dangerous.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1070614842,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:20:59.541367+00:00",
      "cost": 0.016031899999999998,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.2,
        "baseline_score": 2.25,
        "improvement": 0.95,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "async_all_the_way",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both demonstrate async all the way principle effectively. Response A shows multiple patterns (custom events with Func<Task>, ValueTask) but undermines the message by presenting Task.Run().GetAwaiter().GetResult() as acceptable. Response B is cleaner and more direct. Neither discusses ValueTask optimization for frequent synchronous completion scenarios."
        },
        {
          "name": "cancellation_propagation",
          "score_a": 1,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Response A completely omits CancellationToken from all code examples\u2014a critical production concern. Response B consistently shows CancellationToken ct = default parameters, forwards tokens to downstream calls with .ConfigureAwait(false), includes testing with CancellationTokenSource, and emphasizes propagation in best practices. Missing only CreateLinkedTokenSource and ThrowIfCancellationRequested examples."
        },
        {
          "name": "parallel_patterns",
          "score_a": 2,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 2,
          "reasoning": "Response A demonstrates Task.WhenAll once in the BetterEventPattern for concurrent handler completion. Response B lacks parallel pattern examples entirely. Neither shows Parallel.ForEachAsync, bounded parallelism with MaxDegreeOfParallelism, or safe .Result usage post-WhenAll."
        },
        {
          "name": "configureawait_and_context",
          "score_a": 2,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A explains SynchronizationContext capture well but never implements ConfigureAwait(false) in any code examples. Response B actively uses .ConfigureAwait(false) throughout the refactored service, mentions BackgroundService for fire-and-forget work, and references proper error handling with logging."
        },
        {
          "name": "streaming_and_disposal",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A shows no streaming or disposal patterns (no IAsyncEnumerable, await using, or BackgroundService). Response B demonstrates awareness by showing background task enqueueing pattern and explicitly recommends BackgroundService over Task.Run, though it lacks concrete IAsyncEnumerable and await using examples."
        }
      ]
    },
    {
      "id": "dotnet-csharp-coding-standards/0/2",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Review and refactor this C# service class to follow modern .NET coding standards. Fix naming, access modifiers, null handling, and file organization: class orderService { readonly IOrderRepository repo; string get_customer_name(int id) { var c = repo.GetCustomer(id); if (c == null) return null; return c.firstName + \" \" + c.lastName; } }",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1488482126,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:22:43.247504+00:00",
      "cost": 0.077988,
      "judge_attempts": 2,
      "scores": {
        "enhanced_score": 4.25,
        "baseline_score": 4.0,
        "improvement": 0.25,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "naming_conventions",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Both follow PascalCase for types and methods correctly. Response A uses abbreviated parameter `id`, while Response B uses descriptive `customerId`. Response B's field naming `_orderRepository` is more descriptive than Response A's `_repo`, and Response B provides better clarity throughout."
        },
        {
          "name": "code_style",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses modern C# 10+ file-scoped namespace (`namespace MyApp.Services;`), explicit access modifiers, var appropriately, pattern matching, and string interpolation. Response B uses traditional namespace block syntax instead of file-scoped namespace, which deviates from the modern standard explicitly mentioned in the criterion."
        },
        {
          "name": "type_design",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both use composition with IOrderRepository correctly. Response A demonstrates good interface-based design. Response B adds an overloaded helper method `GetCustomerNameOrDefault` showing additional design value, and both show good separation of concerns."
        },
        {
          "name": "defensive_patterns",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A consistently uses braces for control flow (`if (customer is null) { return null; }`) and demonstrates proper CancellationToken patterns in async variants. Response B violates the braces criterion with single-line if statements (`if (customerId <= 0) throw...` without braces), though it compensates with strong constructor validation using null-coalescing operators."
        },
        {
          "name": "documentation_and_enforcement",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response A provides good XML documentation with summary, param, and returns tags. Response B goes further by including exception tags (`<exception cref=\"ArgumentException\">`), mentions enabling nullable reference types in .csproj, shows DI configuration examples, and discusses project-wide enforcement strategies."
        }
      ]
    },
    {
      "id": "dotnet-csharp-coding-standards/1/2",
      "entity_id": "dotnet-csharp-coding-standards",
      "skill_name": "dotnet-csharp-coding-standards",
      "prompt": "Write a well-structured C# interface and implementation for a payment processing service with proper naming conventions, CancellationToken support, XML documentation, and sealed class design.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1441474571,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:24:10.829210+00:00",
      "cost": 0.09660849999999999,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.9,
        "baseline_score": 3.55,
        "improvement": 1.35,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "naming_conventions",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses I-prefix for all interfaces, sealed classes throughout, _camelCase private fields, camelCase parameters, and Async suffix consistently. Response B follows naming conventions but DTOs use mutable properties (get; set;) instead of init-only, and some parameter names are unnecessarily verbose (paymentRequest vs request)."
        },
        {
          "name": "code_style",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses modern C# 10+ file-scoped namespaces (namespace X;), pattern matching (is not null/is null), and consistent .ConfigureAwait(false). Response B uses block-scoped namespaces, older-style null checks (== null instead of is null), and lacks modern C# conventions."
        },
        {
          "name": "type_design",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A seals all classes (PaymentProcessor, all DTOs) with init-only properties enforcing immutability after construction. Response B only seals PaymentService; DTOs are not sealed and use mutable get; set; properties, violating immutability best practices."
        },
        {
          "name": "defensive_patterns",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A perfectly forwards CancellationToken through all async chains with .ConfigureAwait(false), uses throw expressions in constructors, and employs modern null-check patterns. Response B handles tokens well but uses == null instead of is null patterns, which is less idiomatic modern C#."
        },
        {
          "name": "documentation_and_enforcement",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses provide comprehensive XML documentation with summary, param, returns, and exception tags on all public APIs. Response A includes a design decisions table; Response B includes usage examples. Neither mentions EditorConfig or Directory.Build.props configuration for automated style enforcement."
        }
      ]
    },
    {
      "id": "dotnet-efcore-patterns/0/2",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "Set up EF Core for an ASP.NET Core API with a background order processing service. The API handles web requests and the background service processes orders in batches. Show the DbContext registration, proper lifetime management, and read-only query optimization.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1733594138,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:24:34.214474+00:00",
      "cost": 0.030620249999999998,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.6,
        "baseline_score": 2.3,
        "improvement": 2.3,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "dbcontext_lifetime",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A correctly uses IDbContextFactory<T> pattern with AddDbContextFactory for the background service, creating short-lived contexts properly. Response B uses the older IServiceScopeFactory pattern instead of the recommended IDbContextFactory approach. Neither mentions pooling constraints, but A follows the modern best practice explicitly."
        },
        {
          "name": "query_optimization",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A comprehensively demonstrates all three optimization techniques: AsNoTracking (multiple places), UseQuerySplittingBehavior for AsSplitQuery, and AsNoTrackingWithIdentityResolution with clear explanations. Response B only uses AsNoTracking without mentioning AsSplitQuery or AsNoTrackingWithIdentityResolution."
        },
        {
          "name": "interceptor_patterns",
          "score_a": 5,
          "score_b": 1,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A implements SaveChangesInterceptor pattern with two separate interceptors (AuditTimestampInterceptor, SoftDeleteInterceptor), registers them via DI with AddInterceptors, and includes HasQueryFilter for soft delete filtering. Response B doesn't use SaveChangesInterceptor at all; instead it overrides SaveChanges methods directly, which violates the interceptor pattern requirement."
        },
        {
          "name": "migration_practices",
          "score_a": 5,
          "score_b": 1,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A demonstrates modern practices: migration bundles with --self-contained, idempotent SQL scripts, proper --project flags, HasData for reference data seeding, and design-time factory. Response B calls Database.Migrate() at application startup (an anti-pattern per criteria), omits migration bundles, idempotent scripts, and HasData seeding."
        },
        {
          "name": "cancellation_and_resiliency",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A properly propagates CancellationToken throughout async calls (.ToListAsync(ct), .SaveChangesAsync(ct)) and configures EnableRetryOnFailure correctly. Response B also propagates CancellationToken and configures retry, but has a typo (maxRetialDelay instead of maxRetryDelay). Neither shows CreateExecutionStrategy for multi-SaveChanges atomic operations."
        }
      ]
    },
    {
      "id": "dotnet-efcore-patterns/1/2",
      "entity_id": "dotnet-efcore-patterns",
      "skill_name": "dotnet-efcore-patterns",
      "prompt": "My EF Core query loading Orders with Items and Payments is slow due to Cartesian explosion. How do I fix this? Also show me how to add automatic audit timestamps via an interceptor.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 467344179,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:25:04.248956+00:00",
      "cost": 0.02736525,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.7,
        "baseline_score": 1.7,
        "improvement": 2.0,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "dbcontext_lifetime",
          "score_a": 4,
          "score_b": 1,
          "enhanced_score": 4,
          "baseline_score": 1,
          "reasoning": "Response A correctly uses AddDbContext with a DI factory pattern to inject the singleton interceptor, following proper scoped DbContext registration. Response B has critical anti-patterns: hardcodes the connection string in OnConfiguring and creates a field-level interceptor instance instead of registering via DI, which violates dependency injection principles and causes sharing issues."
        },
        {
          "name": "query_optimization",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A correctly demonstrates AsSplitQuery with clear explanation of Cartesian explosion and shows proper global configuration using UseQuerySplittingBehavior. Response B uses AsSplitQuery correctly but the global config code (ConfigureWarnings) is misleading\u2014it doesn't actually configure split query behavior. Neither addresses AsNoTracking for read-only queries."
        },
        {
          "name": "interceptor_patterns",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A implements SaveChangesInterceptor correctly and properly registers it as a singleton via DI with AddInterceptors, following the criterion requirement. Response B implements the interceptor logic adequately but registers it as a field-level instance in OnConfiguring, which is an anti-pattern that violates proper DI registration and breaks with DbContext pooling."
        },
        {
          "name": "migration_practices",
          "score_a": 3,
          "score_b": 1,
          "enhanced_score": 3,
          "baseline_score": 1,
          "reasoning": "Response A shows a migration example with proper Up/Down methods and uses the --project flag correctly, demonstrating reversibility. Response B provides no migration content whatsoever, missing an opportunity to address deployment best practices like bundles, idempotent scripts, or seeding with HasData."
        },
        {
          "name": "cancellation_and_resiliency",
          "score_a": 3,
          "score_b": 1,
          "enhanced_score": 3,
          "baseline_score": 1,
          "reasoning": "Response A consistently propagates CancellationToken through ToListAsync, SaveChangesAsync, and FindAsync calls, demonstrating proper async cancellation support. Response B omits CancellationToken entirely from all async calls and lacks any discussion of EnableRetryOnFailure or CreateExecutionStrategy for resilient connections."
        }
      ]
    },
    {
      "id": "dotnet-minimal-apis/0/2",
      "entity_id": "dotnet-minimal-apis",
      "skill_name": "dotnet-minimal-apis",
      "prompt": "Build a Minimal API for a product catalog with CRUD endpoints. The API should use route groups, TypedResults for response types, and an endpoint filter for request validation. Include proper OpenAPI metadata.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 4231945294,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:25:30.017172+00:00",
      "cost": 0.0290215,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.4,
        "baseline_score": 3.35,
        "improvement": 1.05,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "typed_results_usage",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A consistently uses union `Results<T1, T2, ...>` types across all endpoints (e.g., `Results<Ok<ProductDto>, NotFound>`, `Results<Created<ProductDto>, Conflict>`). Response B has inconsistent typing: CreateProduct returns bare `Created<ProductDto>` without union wrapping, UpdateProduct omits Conflict as a declared return type, and GetAllProducts/GetActiveProducts return bare `Ok<List<ProductDto>>` without unions, violating the requirement for automatic OpenAPI schema generation via union types."
        },
        {
          "name": "route_group_organization",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses use MapGroup(\"/api/products\") with shared metadata and extension method patterns. Response A returns `RouteGroupBuilder` for chaining; Response B uses `void` pattern. Both cleanly organize Program.cs. Neither demonstrates nested groups or versioning, which would elevate to 5."
        },
        {
          "name": "endpoint_filters",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A implements proper `IEndpointFilter` with direct `InvokeAsync` pattern, correct context usage, and returns `TypedResults.ValidationProblem()` for proper typing. Response B uses factory pattern (correctly applied via `AddEndpointFilterFactory`), but returns bare `TypedResults.BadRequest()` with raw ProblemDetails, losing type safety. Response A's filter is more robust and maintainable."
        },
        {
          "name": "parameter_binding",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A explicitly uses `[FromQuery]` attributes for pagination parameters, making binding sources clear and documented. Response B relies on implicit convention-based binding (e.g., `bool? activeOnly = null` without `[FromQuery]`), which works but lacks explicitness and clarity required for production APIs."
        },
        {
          "name": "openapi_integration",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both register AddOpenApi() and MapOpenApi(). Response A has comprehensive WithName/WithSummary/WithDescription on every endpoint plus Produces/ProducesProblem with all status codes. Response B includes similar metadata but adds less complete Produces declarations and includes optional Swagger UI setup (commented out), showing good awareness but slightly less polish."
        }
      ]
    },
    {
      "id": "dotnet-minimal-apis/1/2",
      "entity_id": "dotnet-minimal-apis",
      "skill_name": "dotnet-minimal-apis",
      "prompt": "I have a growing Minimal API with 30+ endpoints all in Program.cs. How should I reorganize this for maintainability? Show me the extension method pattern with route groups.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3785298548,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:25:52.041656+00:00",
      "cost": 0.02138525,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.0,
        "baseline_score": 3.55,
        "improvement": 0.45,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "typed_results_usage",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses correctly use TypedResults factory methods and declare union return types via Results<T1, T2>. Response A shows consistent usage across CRUD operations; Response B adds error handling examples with BadRequest variants. Both are equally comprehensive."
        },
        {
          "name": "route_group_organization",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A uses the superior IEndpointRouteBuilder extension method pattern (returns RouteGroupBuilder), enabling flexible composition. Response B uses WebApplication directly, which works but is less composable and doesn't support nested reuse. Response A's approach aligns better with modern Minimal API best practices, though Response B's feature-based folder structure is well-organized."
        },
        {
          "name": "endpoint_filters",
          "score_a": 3,
          "score_b": 2,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A shows concrete AddEndpointFilter usage with RequestLoggingFilter and ValidationFilter at the route group level, addressing cross-cutting concerns. Response B mentions error handling within endpoint logic but lacks IEndpointFilter implementation or usage. Neither shows full filter implementation details, but Response A provides more practical guidance."
        },
        {
          "name": "parameter_binding",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses demonstrate route constraints ({id:int}) and service DI injection. Both show body binding through DTOs (CreateProductDto, CreateTodoRequest). Response B additionally shows CancellationToken injection. Neither explicitly demonstrates [FromQuery], [FromHeader], [AsParameters] attributes or complex binding scenarios, making them equal in coverage."
        },
        {
          "name": "openapi_integration",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses comprehensively demonstrate OpenAPI metadata via WithTags, WithOpenApi, WithName, WithSummary, and WithDescription. Both show MapOpenApi registration. Response B adds WithDescription examples, but both achieve full integration equally well."
        }
      ]
    },
    {
      "id": "dotnet-native-aot/0/2",
      "entity_id": "dotnet-native-aot",
      "skill_name": "dotnet-native-aot",
      "prompt": "Publish an ASP.NET Core Minimal API as a Native AOT binary. Show the project configuration, source-generated JSON serialization, CreateSlimBuilder usage, ILLink descriptors for a type that uses reflection, and a Dockerfile using runtime-deps base image.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2847089298,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:26:23.975635+00:00",
      "cost": 0.02879275,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.95,
        "baseline_score": 3.4,
        "improvement": 0.55,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "publish_configuration",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both correctly use PublishAot=true, EnableAotAnalyzer, and EnableTrimAnalyzer. Response A explicitly shows build commands with analyzer property flags (/p:EnableAotAnalyzer=true), while Response B adds JsonSerializerIsReflectionEnabledByDefault and EmitCompilerGeneratedFiles. Both are strong but slightly different approaches."
        },
        {
          "name": "reflection_free_patterns",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A demonstrates excellent AOT patterns with source-generated JSON, CreateSlimBuilder, and clear comparisons of AOT-compatible vs incompatible code. Response B also shows these patterns well but includes a reflection example (GetTodoMetadata using Type.GetProperties) that, while documented, still relies on runtime reflection that requires trimmer preservation."
        },
        {
          "name": "type_preservation",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both properly use ILLink descriptor XML with TrimmerRootDescriptor, correct syntax with preserve='all', and method-level preservation examples. Neither demonstrates the [DynamicDependency] attribute approach for localized, targeted preservation, which is an important complementary technique to XML descriptors."
        },
        {
          "name": "pinvoke_source_gen",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses completely omit P/Invoke and [LibraryImport] coverage, which is a significant gap for a comprehensive Native AOT guide. This is a material omission given the criterion weight and importance for systems-level AOT applications."
        },
        {
          "name": "size_and_deployment",
          "score_a": 5,
          "score_b": 3,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A provides comprehensive size optimization details including StripSymbols, OptimizationPreference=Size, InvariantGlobalization impact, specific binary sizes (35MB default \u2192 24MB optimized), and detailed container image size comparisons (runtime-deps vs runtime vs aspnet). Response B correctly uses runtime-deps but lacks detailed discussion of StripSymbols, OptimizationPreference, and specific size impact analysis."
        }
      ]
    },
    {
      "id": "dotnet-native-aot/1/2",
      "entity_id": "dotnet-native-aot",
      "skill_name": "dotnet-native-aot",
      "prompt": "I am converting a .NET library to be AOT-compatible. What MSBuild properties should I set? How do I replace DllImport with LibraryImport for P/Invoke? Show me how to handle a type that the trimmer cannot analyze statically.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3341610431,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:27:42.901595+00:00",
      "cost": 0.06078345,
      "judge_attempts": 2,
      "scores": {
        "enhanced_score": 4.3,
        "baseline_score": 2.45,
        "improvement": 1.85,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "publish_configuration",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A correctly distinguishes library projects (IsAotCompatible only) from applications, explicitly states 'never mix them', and demonstrates fast feedback via dotnet build with EnableAotAnalyzer/EnableTrimAnalyzer properties. Response B incorrectly uses PublishAot in the library project configuration, which violates the core requirement that PublishAot is only for applications, not libraries."
        },
        {
          "name": "reflection_free_patterns",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A demonstrates source generators as the reflection-free pattern, showing how to replace runtime reflection with compile-time code generation via RegisterPlugin attribute example. Response B focuses entirely on making reflection trim-safe through DynamicallyAccessedMembers annotations rather than replacing reflection with compile-time alternatives; it does not show source generators or other reflection-free patterns like JsonSerializerContext or explicit registration."
        },
        {
          "name": "type_preservation",
          "score_a": 5,
          "score_b": 2,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A correctly covers three approaches with clear guidance: DynamicDependency for localized 1-2 type cases (Preferred), ILLink.Descriptors.xml with TrimmerRootDescriptor for multiple/external types, and source generators as best solution. Response B omits ILLink descriptor XML entirely, conflates DynamicallyAccessedMembers (parameter annotations) with type preservation, and treats DynamicDependency as 'last resort' contrary to its proper use for targeted preservation."
        },
        {
          "name": "pinvoke_source_gen",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A provides comprehensive LibraryImport examples including real-world SQLite patterns, StringMarshalling options (Utf8/Utf16), MarshalAs for boolean/string returns, and a detailed migration checklist. Response B covers LibraryImport with StringMarshalling and MarshalAs correctly but is less comprehensive; it adds UnmanagedCallConv and MarshalUsing which are valuable but not specifically required by the criterion."
        },
        {
          "name": "size_and_deployment",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 2,
          "baseline_score": 3,
          "reasoning": "Response B explicitly shows OptimizationPreference=Size configuration which is a key size optimization property. Response A omits size-specific properties (StripSymbols, OptimizationPreference, InvariantGlobalization). Neither response covers container base image selection or discusses typical binary size ranges, but Response B at least addresses the primary size configuration property."
        }
      ]
    },
    {
      "id": "dotnet-observability/0/2",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "Add full OpenTelemetry observability to an ASP.NET Core API: traces for HTTP requests and custom operations, metrics for business KPIs (orders processed, revenue), structured logging with trace correlation, and separate liveness/readiness health check endpoints.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1700611968,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:28:11.390337+00:00",
      "cost": 0.0328815,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.2,
        "baseline_score": 3.1,
        "improvement": 1.1,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "otel_setup",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both configure AddOpenTelemetry with ConfigureResource, WithTracing, WithMetrics, and AddOtlpExporter correctly. Response B uses a cleaner extension method pattern and wildcard AddSource; Response A is more verbose but comprehensive with console exporter in dev. Both properly use environment variables for OTLP endpoint."
        },
        {
          "name": "custom_metrics",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A has critical flaws: uses `new Meter()` (violates IMeterFactory gotcha) and recreates counters/histograms on every request inside handlers (memory leak). Response B correctly uses IMeterFactory from DI, creates metrics once in the constructor, and uses proper semantic conventions with KeyValuePair tags on each record call."
        },
        {
          "name": "structured_logging",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Both use proper structured logging templates with {Placeholder} syntax. Response A uses Serilog enrichers but lacks explicit trace context correlation. Response B adds explicit StructuredLoggingMiddleware that enriches logs with TraceId and SpanId for correlation and demonstrates better practice. Neither fully implements LoggerMessage source generation."
        },
        {
          "name": "health_checks",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A separates liveness/readiness with tag filtering and includes dependency checks (database, cache). Response B achieves superior separation using `Predicate = _ => false` for liveness (purest check: no dependencies), typed IHealthCheck implementations with clear documentation, and validates both database and external services in readiness. Response B's design philosophy is more aligned with Kubernetes health check best practices."
        },
        {
          "name": "aspire_awareness",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Neither response acknowledges .NET Aspire ServiceDefaults or mentions that explicit OpenTelemetry configuration may be redundant in Aspire environments. Both provide complete manual configurations without caveat for Aspire users. This omission is equally significant in both responses."
        }
      ]
    },
    {
      "id": "dotnet-observability/1/2",
      "entity_id": "dotnet-observability",
      "skill_name": "dotnet-observability",
      "prompt": "How do I create custom metrics in .NET using System.Diagnostics.Metrics with IMeterFactory and export them via OpenTelemetry OTLP? Show the counter, histogram, and gauge patterns with proper DI registration.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 4124324510,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:28:33.470070+00:00",
      "cost": 0.025200249999999997,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.4,
        "baseline_score": 2.8,
        "improvement": 0.6,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "otel_setup",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses AddOpenTelemetry and WithMetrics with OTLP export and environment variables, but critically omits ConfigureResource (explicitly required by criteria) and AddRuntimeInstrumentation. Response B comprehensively includes ConfigureResource with proper service name/version, AddRuntimeInstrumentation, development fallback to console exporter, and histogram bucket configuration via AddView."
        },
        {
          "name": "custom_metrics",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excellently implement Counter, Histogram, and ObservableGauge patterns via IMeterFactory. Both follow OpenTelemetry semantic conventions and use proper tag syntax. Response B adds thread-safe updates with Interlocked.Exchange, while Response A provides callback-based gauge; both approaches are valid."
        },
        {
          "name": "structured_logging",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Neither response adequately addresses structured logging with {Placeholder} syntax, source-generated LoggerMessage patterns, or log-to-trace correlation via TraceId/SpanId. Both show only minimal, basic logging examples. This criterion is equally neglected by both."
        },
        {
          "name": "health_checks",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response implements health checks at all. No /health/live and /health/ready endpoints, no AddHealthChecks registration, no liveness/readiness separation shown. Both completely omit this aspect of observability."
        },
        {
          "name": "aspire_awareness",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Neither response acknowledges .NET Aspire ServiceDefaults or mentions that Aspire auto-configures OpenTelemetry. Both provide standalone configurations without guidance on Aspire integration or non-Aspire scenarios."
        }
      ]
    },
    {
      "id": "dotnet-resilience/0/2",
      "entity_id": "dotnet-resilience",
      "skill_name": "dotnet-resilience",
      "prompt": "Add resilience to an HttpClient that calls an external catalog API. Use the standard resilience pipeline with custom retry counts, circuit breaker thresholds, and timeouts. The configuration should be tunable via appsettings.json.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1664198789,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:28:54.120107+00:00",
      "cost": 0.022746500000000003,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.3,
        "baseline_score": 3.5,
        "improvement": 0.8,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "standard_pipeline",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses AddResilienceHandler() to manually build a custom pipeline (Retry -> CircuitBreaker -> Timeout) without a rate limiter, violating the standard pipeline order. Response B correctly uses AddStandardResilienceHandler() with the proper standard order: Rate Limiter -> Total Timeout -> Retry -> Circuit Breaker -> Attempt Timeout."
        },
        {
          "name": "polly_v8_apis",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 4,
          "reasoning": "Response A explicitly showcases Polly v8 APIs (HttpRetryStrategyOptions, HttpCircuitBreakerStrategyOptions, TimeoutStrategyOptions) with custom ShouldHandle predicates. Response B uses AddStandardResilienceHandler which abstracts the v8 APIs internally but doesn't showcase them directly or use PredicateBuilder for fine-grained strategy configuration."
        },
        {
          "name": "retry_best_practices",
          "score_a": 5,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 5,
          "reasoning": "Response A demonstrates excellent retry practices with UseJitter=true, exponential backoff, DisableUnsafeHttpMethods=true, custom ShouldHandle targeting specific status codes (408, 429, 5xx), and proper timeout ordering (10s < 45s). Response B implements jitter and exponential backoff but relies on standard handler defaults without demonstrating explicit control over which status codes trigger retries."
        },
        {
          "name": "di_and_configuration",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A properly registers HttpClient with AddResilienceHandler and binds configuration via GetSection, but uses a custom pipeline. Response B uses the modern AddStandardResilienceHandler pattern, correctly binds configuration with GetSection().Bind(options), and follows the recommended DI pattern for the standard resilience handler."
        },
        {
          "name": "telemetry_awareness",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A includes application-level logging but doesn't mention automatic Polly telemetry emission or structured logging from Polly itself. Response B explicitly states that Polly automatically emits structured logs and metrics, provides example log output, explains how to enable Polly logging in appsettings.json, and references OpenTelemetry integration."
        }
      ]
    },
    {
      "id": "dotnet-resilience/1/2",
      "entity_id": "dotnet-resilience",
      "skill_name": "dotnet-resilience",
      "prompt": "I need to add retry logic to my EF Core repository for handling transient database failures, and a separate resilience pipeline for an external payment gateway HTTP client. Show both using Polly v8 and Microsoft.Extensions patterns.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2368690379,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:29:45.150405+00:00",
      "cost": 0.0501626,
      "judge_attempts": 2,
      "scores": {
        "enhanced_score": 4.8,
        "baseline_score": 2.9,
        "improvement": 1.9,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "standard_pipeline",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses custom AddResiliencePipeline and deprecated AddResilienceHandler, missing the modern AddStandardResilienceHandler pattern. Response B correctly uses AddStandardResilienceHandler with customized options (Retry.MaxRetryAttempts, CircuitBreaker.FailureRatio, AttemptTimeout.Timeout) without building from scratch."
        },
        {
          "name": "polly_v8_apis",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A correctly uses Polly v8 APIs (RetryStrategyOptions, CircuitBreakerStrategyOptions, PredicateBuilder) for database pipelines but mixes in deprecated AddResilienceHandler. Response B cleanly separates v8 APIs: AddResiliencePipeline for database with PredicateBuilder, and AddStandardResilienceHandler for HTTP without API mixing."
        },
        {
          "name": "retry_best_practices",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A implements exponential backoff and jitter correctly but doesn't explicitly address idempotency for retry safety. Response B goes further by explicitly implementing idempotency keys in the refund method, documenting retry safety per operation type, and stating the principle: 'Only safe for reads; writes need idempotency key.'"
        },
        {
          "name": "di_and_configuration",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A hardcodes all settings in code, uses ResiliencePipelineProvider.GetPipeline() instead of [FromKeyedServices], and omits appsettings.json binding. Response B uses [FromKeyedServices], provides complete appsettings.json configuration with Configuration.GetSection().Bind(), and explicitly warns against the superseded Microsoft.Extensions.Http.Polly package."
        },
        {
          "name": "telemetry_awareness",
          "score_a": 2,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A focuses on manual OnRetry and OnOpened callbacks without mentioning automatic telemetry emission from DI registration. Response B acknowledges 'automatic metrics collection' and 'structured logging' through DI integration, though neither explicitly names specific metrics (polly.strategy.attempt.duration, etc.) or OpenTelemetry."
        }
      ]
    },
    {
      "id": "dotnet-security-owasp/0/2",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Harden an ASP.NET Core Minimal API against the OWASP Top 10. Show me how to add global authorization with fallback policy, rate limiting, security headers (CSP, X-Frame-Options, HSTS), anti-forgery protection, and CORS restrictions for a known frontend origin.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2160590530,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:30:29.181202+00:00",
      "cost": 0.03841525,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.2,
        "baseline_score": 2.45,
        "improvement": 0.75,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "injection_prevention",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Response A mentions 'parameterized queries (EF Core)' in the OWASP coverage table but never demonstrates it in code. Response B uses DTOs and structured logging but also lacks demonstration of parameterized queries, HtmlEncoder usage, or allowlist validation. Neither shows actual database operations with FromSqlInterpolated or LINQ examples."
        },
        {
          "name": "access_control",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A implements SetFallbackPolicy correctly with justified AllowAnonymous endpoints but lacks resource-level authorization checks. Response B implements all the same global controls PLUS includes explicit IDOR prevention in the CreateOrder handler with `if (request.UserId != userId)` check, though ideally this would use a custom AuthorizationHandler rather than inline logic."
        },
        {
          "name": "security_configuration",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A includes CSP, X-Frame-Options, HSTS, and Permissions-Policy but omits Kestrel hardening (AddServerHeader=false) and request size/timeout constraints. Response B adds Kestrel limits (MaxRequestBodySize, MaxRequestHeadersTotalSize, RequestHeadersTimeout), removes server header, gates UseDeveloperExceptionPage behind IsDevelopment, and includes generic error handler\u2014meeting all security configuration criteria."
        },
        {
          "name": "rate_limiting_and_antiforgery",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A implements rate limiting with GlobalLimiter and custom policies, sets 429 status, and adds antiforgery validation, but places UseRateLimiter() before authentication without explicit comment justifying the middleware order. Response B provides clearer configuration with fixed-window and sliding-window limiters, explicit '// Rate limiter must come after UseRouting()' comment, proper middleware sequence, and more sophisticated antiforgery cookie hardening with SameSite=Strict."
        },
        {
          "name": "dependency_and_data_integrity",
          "score_a": 1,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 1,
          "reasoning": "Response A does not address NuGet audits, package source mapping, or secrets management concerns. Response B includes a pre-flight checklist with `dotnet list package --vulnerable --include-transitive` and mentions in the gotchas section to avoid plaintext secrets, though neither provides comprehensive guidance on NuGetAuditMode or dependency confusion prevention."
        }
      ]
    },
    {
      "id": "dotnet-security-owasp/1/2",
      "entity_id": "dotnet-security-owasp",
      "skill_name": "dotnet-security-owasp",
      "prompt": "Review this .NET code for security vulnerabilities: it uses FromSqlRaw with string concatenation, stores connection strings in appsettings.json, returns detailed exception info to clients, and accepts user-provided URLs for HttpClient calls without validation.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 1481058461,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:30:51.323186+00:00",
      "cost": 0.017455899999999996,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 2.5,
        "baseline_score": 1.85,
        "improvement": 0.65,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "injection_prevention",
          "score_a": 4,
          "score_b": 3,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A clearly explains FromSqlInterpolated vs FromSqlRaw parameterization and recommends LINQ as preferred, but lacks HtmlEncoder and command allowlist validation. Response B covers SQL injection adequately with type validation (int.Parse) but is less thorough on parameterization mechanics and also missing HTML encoding and allowlist concepts."
        },
        {
          "name": "access_control",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses completely omit access control topics: neither mentions SetFallbackPolicy, AuthorizationHandler for IDOR prevention, CORS configuration restrictions, nor [AllowAnonymous] endpoint justification. This is a critical gap in both."
        },
        {
          "name": "security_configuration",
          "score_a": 4,
          "score_b": 2,
          "enhanced_score": 4,
          "baseline_score": 2,
          "reasoning": "Response A provides comprehensive security headers (X-Content-Type-Options, X-Frame-Options, CSP, Referrer-Policy, HSTS) plus AddServerHeader=false and proper UseDeveloperExceptionPage gating. Response B only addresses exception handling without implementing any security headers or removing server identity, though it does mention client timeout constraints."
        },
        {
          "name": "rate_limiting_and_antiforgery",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses completely ignore rate limiting middleware (.NET 7+), anti-forgery tokens for form endpoints, and 429 status code configuration. Neither addresses this important security category."
        },
        {
          "name": "dependency_and_data_integrity",
          "score_a": 2,
          "score_b": 2,
          "enhanced_score": 2,
          "baseline_score": 2,
          "reasoning": "Both responses correctly demonstrate not storing secrets in appsettings.json (Response A: user secrets/env vars; Response B: Azure Key Vault/env vars) but both omit NuGet audit configuration, package source mapping, BinaryFormatter warnings, and serialization method guidance."
        }
      ]
    },
    {
      "id": "dotnet-testing-strategy/0/2",
      "entity_id": "dotnet-testing-strategy",
      "skill_name": "dotnet-testing-strategy",
      "prompt": "I have a new ASP.NET Core API with an OrderService that calls a database repository, an external payment gateway, and sends email notifications. Design a testing strategy: which parts get unit tests, integration tests, and E2E tests? Show concrete test examples with appropriate test doubles.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 3264568454,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:31:57.287138+00:00",
      "cost": 0.04116380000000001,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.45,
        "baseline_score": 3.5,
        "improvement": 0.95,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "test_type_decision",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Both correctly map unit/integration/E2E tests to components. Response A shows a clear decision table. Response B provides an explicit decision framework ('does this depend on external infrastructure?') and correctly categorizes payment gateway as integration+E2E rather than just unit, demonstrating better understanding of HTTP contract verification."
        },
        {
          "name": "test_doubles_selection",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A relies exclusively on Moq mocks with verbose Setup chains throughout, creating brittle tests. Response B uses NSubstitute for less verbose code AND implements a proper FakePaymentGateway class\u2014exactly what the criteria prefers: 'Prefers fakes for domain-heavy scenarios over excessive mock setup.' Response B demonstrates both mock and fake approaches, showing superior understanding."
        },
        {
          "name": "test_organization",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Response A uses namespace suffixes (Unit/Integration/E2E) and basic naming convention. Response B mirrors src/ structure more precisely with domain/infrastructure separation, uses 'FunctionalTests' terminology, explicitly states 'one test class per production class,' and more consistently follows Method_Scenario_Expected naming. Slightly better structure and clarity in Response B."
        },
        {
          "name": "anti_pattern_avoidance",
          "score_a": 3,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 3,
          "reasoning": "Response A tests observable behavior through mocks and assertions, which is valid, but relies heavily on mock verification across unit tests\u2014potentially brittle and implementation-focused. Response B emphasizes testing outcomes (HTTP status, database state) and uses FakePaymentGateway to avoid excessive mock setup. E2E test in Response B asserts on actual database state rather than mock interactions, demonstrating better separation of concerns."
        },
        {
          "name": "determinism",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both use Testcontainers or WebApplicationFactory with fresh isolated infrastructure (Response A uses in-memory DB; Response B uses real PostgreSQL containers). Both avoid external network dependencies. Neither explicitly mentions FakeTimeProvider despite discussing DateTime.UtcNow in test data. Both tests appear independent; roughly equivalent on this criterion."
        }
      ]
    },
    {
      "id": "dotnet-testing-strategy/1/2",
      "entity_id": "dotnet-testing-strategy",
      "skill_name": "dotnet-testing-strategy",
      "prompt": "My team over-uses mocks -- every test has 5+ mock setups and we spend more time maintaining mocks than writing features. How should we decide between mocks, fakes, and stubs? Refactor this approach for an order processing service.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 745235581,
      "ab_assignment": "enhanced=A,baseline=B",
      "timestamp": "2026-02-26T02:32:28.202563+00:00",
      "cost": 0.0177826,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 3.6,
        "baseline_score": 3.3,
        "improvement": 0.3,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "test_type_decision",
          "score_a": 3,
          "score_b": 2,
          "enhanced_score": 3,
          "baseline_score": 2,
          "reasoning": "Response A provides a conceptual framework for deciding between test doubles but lacks explicit guidance on unit vs integration vs E2E test types and the testing pyramid. Response B's decision tree focuses on system boundaries and interaction verification, not on classifying test types, making it less aligned with the criterion. Neither adequately addresses when to use unit vs integration tests."
        },
        {
          "name": "test_doubles_selection",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses excellently distinguish stubs, fakes, mocks, and spies with clear decision frameworks. Both provide concrete fake implementations (FakeOrderRepository, FakePaymentService) and correctly identify internal services for fakes vs external boundaries for stubs/mocks. Both explain the fundamental difference: mocks verify interaction HOW while fakes verify behavior WHAT."
        },
        {
          "name": "test_organization",
          "score_a": 3,
          "score_b": 3,
          "enhanced_score": 3,
          "baseline_score": 3,
          "reasoning": "Both responses demonstrate proper Method_Scenario_ExpectedBehavior naming and clear Arrange-Act-Assert patterns. Response A mentions a test fixtures library structure briefly; Response B shows [SetUp] organization. Neither explicitly discusses mirroring src/ directory structure with test suffixes (UnitTests, IntegrationTests) or one test class per production class principles."
        },
        {
          "name": "anti_pattern_avoidance",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses strongly emphasize testing behavior over implementation details and avoiding excessive mock setup. Response A explicitly states the key principle: 'Test behavior, not implementation.' Response B shows clear before/after comparisons and states 'only mock the boundary.' Both effectively transition from brittle Received() assertions to state-based assertions, addressing the core anti-pattern of over-mocking."
        },
        {
          "name": "determinism",
          "score_a": 1,
          "score_b": 1,
          "enhanced_score": 1,
          "baseline_score": 1,
          "reasoning": "Both responses completely omit determinism considerations. Neither mentions TimeProvider or FakeTimeProvider for time-dependent logic. Response B actually introduces a determinism problem by using `DateTime.UtcNow` in the service code without addressing test time control. Neither discusses Testcontainers, WebApplicationFactory, or independent test fixture isolation."
        }
      ]
    },
    {
      "id": "dotnet-xunit/0/2",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "Write xUnit tests for a .NET service that processes customer orders, including tests for successful order creation, validation failures, and async operations. The service has methods CreateAsync, CancelAsync, and GetByIdAsync.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 560253351,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:33:57.417728+00:00",
      "cost": 0.098492,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 5.0,
        "baseline_score": 2.5,
        "improvement": 2.5,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "xunit_v3_conventions",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses xUnit 2.x patterns with [Fact], [Theory], and [InlineData], but doesn't leverage xUnit v3 features like ValueTask returns for IAsyncLifetime or TheoryData<T>. Response B explicitly implements IAsyncLifetime with ValueTask, uses TheoryData<T> for complex test data, and demonstrates proper xUnit v3 conventions throughout."
        },
        {
          "name": "fixture_and_lifecycle",
          "score_a": 2,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 2,
          "reasoning": "Response A uses constructor-based Moq setup without IAsyncLifetime or IClassFixture<T> patterns, relying on direct mock injection. Response B properly implements OrderServiceFixture with IAsyncLifetime using async ValueTask.InitializeAsync(), applies IClassFixture<T>, and includes ICollectionDefinition with DisableParallelization for sequential tests."
        },
        {
          "name": "assertion_quality",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses appropriate assertions (Assert.Equal, Assert.ThrowsAsync, Assert.Contains) but lacks Assert.Multiple, an important xUnit v3 feature. Response B uses Assert.Multiple for grouped assertions, Assert.Equal, Assert.Single, and Assert.ThrowsAsync without assertion messages, properly aligned with xUnit v3 assertion patterns."
        },
        {
          "name": "test_structure",
          "score_a": 5,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 5,
          "reasoning": "Both responses demonstrate excellent test structure with clear Arrange/Act/Assert patterns, well-organized regions, descriptive method names following Method_Scenario_ExpectedBehavior convention, and proper async Task returns. Both avoid one-concept-per-test violations effectively."
        },
        {
          "name": "parallelism_awareness",
          "score_a": 1,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 1,
          "reasoning": "Response A shows no awareness of test parallelization, collection definitions, or runner configuration. Response B explicitly defines [CollectionDefinition] with DisableParallelization=true, applies [Collection] attributes to sequential tests, and includes xunit.runner.json with parallelization settings, demonstrating comprehensive understanding of xUnit's parallel execution model."
        }
      ]
    },
    {
      "id": "dotnet-xunit/1/2",
      "entity_id": "dotnet-xunit",
      "skill_name": "dotnet-xunit",
      "prompt": "How do I share an expensive database fixture across multiple xUnit test classes while keeping tests isolated? Show the fixture, collection definition, and test class setup.",
      "run_index": 2,
      "model": "haiku",
      "judge_model": "haiku",
      "run_id": "f648b036-c39e-4e57-8c40-bc197438109f",
      "seed": 42,
      "case_seed": 2509731331,
      "ab_assignment": "enhanced=B,baseline=A",
      "timestamp": "2026-02-26T02:35:51.191079+00:00",
      "cost": 0.08558274999999999,
      "judge_attempts": 1,
      "scores": {
        "enhanced_score": 4.5,
        "baseline_score": 3.75,
        "improvement": 0.75,
        "winner": "enhanced"
      },
      "per_criterion_breakdown": [
        {
          "name": "xunit_v3_conventions",
          "score_a": 3,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 3,
          "reasoning": "Response A uses Task return types for IAsyncLifetime methods, while the xUnit v3 convention requires ValueTask. Response B correctly implements IAsyncLifetime with ValueTask for both InitializeAsync and DisposeAsync, following modern best practices for efficiency and v3 standards."
        },
        {
          "name": "fixture_and_lifecycle",
          "score_a": 4,
          "score_b": 5,
          "enhanced_score": 5,
          "baseline_score": 4,
          "reasoning": "Response A correctly uses ICollectionFixture with [CollectionDefinition] but adds complexity by having test classes also implement IAsyncLifetime with Task-based methods. Response B cleanly implements ICollectionFixture with IAsyncLifetime using proper ValueTask returns, and provides an optional isolated transaction pattern without overcomplicating the core setup."
        },
        {
          "name": "assertion_quality",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses use appropriate xUnit assertions (Assert.NotNull, Assert.Equal, Assert.ThrowsAsync) correctly for value comparisons. Both avoid unnecessary boolean assertions and follow xUnit best practices. Quality is equivalent between the two."
        },
        {
          "name": "test_structure",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Both responses follow Arrange/Act/Assert pattern clearly with good section separation. Test method names follow Method_Scenario_ExpectedBehavior convention appropriately (CreateUser_WithValidEmail_ShouldSucceed vs Insert_ValidOrder_Persists). Both demonstrate one logical concept per test with proper async/await usage."
        },
        {
          "name": "parallelism_awareness",
          "score_a": 4,
          "score_b": 4,
          "enhanced_score": 4,
          "baseline_score": 4,
          "reasoning": "Response A explains collection-based parallel execution and provides xunit.xml configuration. Response B provides equally clear explanation of parallel execution with detailed trade-offs section explaining sequential behavior within collections. Both demonstrate solid understanding of xUnit parallelism, though Response A includes config file details while Response B emphasizes architectural implications."
        }
      ]
    }
  ],
  "artifacts": {}
}